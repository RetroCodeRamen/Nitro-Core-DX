SUPER  NINIENOO 


ENTERTAINMENT  SYSTEM 


DEVELOPMENT 

MANUAL 


BOOK  II 


SNES  DEVELOPMENT  MANUAL 


[ 


“Confidential” 

This  document  contains  confidential  and 
proprietary  information  of  Nintendo  and 
is  also  protected  under  the  copyright  laws 
of  the  United  States  and  foreign  countries. 
No  part  of  this  document  may  be  released, 
distributed,  transmitted  or  reproduced  in 
any  form  or  by  any  electronic  or 
mechanical  means,  including  information 
storage  and  retrieval  systems,  without 
permission  in  writing  from  Nintendo. 

© 1993,  1994, 1995  Nintendo 

The  terms  Sony  and  Sony  NEWS  are 
registered  trademarks  of  Sony  Corporation. 
® and  ™ are  registered  trademarks  of 
Nintendo. 


Table  of  Contents 

BOOK  II 


TABLE  of  CONTENTS 


SUBJECT  PAGE 

SECTION  1 - SUPER  ACCELERATOR  (SA-1)  l-l-l 

Super  Accelerator  System  Functions 1-1-1 

Configuration  of  SA-1 1-2-1 

Super  Accelerator  Memory  Map 1-3-1 

SA-1  Internal  Register  Configuration 1-4-1 

Multi-Processor  Processing 1-5-1 

Character  Conversion 1-6-1 

Arithmetic  Function 1-7-1 

Variable-Length  Bit  Processing 1-8-1 

DMA 1-9-1 

SA-1  Timer 1-10-1 

SECTION  2 - SUPER  FX® 2-1-1 

Introduction  to  Super  FX 2-1-1 

GSU  Functional  Operation 2-2-1 

Memory  Mapping 2-3-1 

GSU  Internal  Register  Configuration 2-4- 1 

GSU  Program  Execution 2-5-1 

Instruction  Execution 2-6-1 

Data  Access 2-7-1 

GSU  Special  Functions 2-8-1 

Description  of  Instructions 2-9-1 

SECTION  3 - DSP/DSP1 3-1-1 

Introduction  to  DSP1 3-1-1 

Command  Summary 3-2-1 

Parameter  Data  Type 3-3-1 

Use  of  DSP1 3-4-1 

Description  of  DSP1  Commands 3-5-1 

Math  Functions  and  Equations 3-6-1 


TABLE  of  CONTENTS 


Table  of  Contents  (Continued) 

SUBJECT  PAGE 

SECTION  4 - ACCESSORIES 4-1-1 

The  Super  NES  Super  Scope®  System 4-1-1 

Principles  of  the  Super  NES  Super  Scope 4-2-1 

Super  NES  Super  Scope  Functional  Operation 4-3-1 

Super  NES  Super  Scope  Receiver  Functions 4-4-1 

Graphics 4-5-1 

Super  NES  Mouse  Specifications 4-6-1 

Using  the  Standard  BIOS 4-7-1 

Programming  Cautions 4-8- 1 

MultiPlayer  5 Specifications 4-9-1 

MultiPlayer  5 Supplied  BIOS 4-10-1 

SUPPLEMENTAL  INFORMATION 

Super  NES  Parts  List 1 

Game  Content  Guidelines 3 

Guidelines  Concerning  Commercialism  and  Promotion  of  Licensee 

Products  or  Services  in  Nintendo  Licensed  Games 5 

Super  NES  Video  Timing  Information 10 

INDEX 

BULLETINS 


ii 


LIST  of  FIGURES 


List  of  Figures 
BOOK  11 


TITLE 


FIGURE 

NUMBER  PAGE 


Super  Accelerator  System  Configuration 

SAS  Bus  Image 

SA-1  Block  Diagram 

Bitmap  Register  Files  0~7 

Bitmap  Register  Files  8~F 

Accelerator  Mode 

Parallel  Processing  Mode 

Mixed  Processing  Mode 

Character  Conversion  1 

Character  Conversion  2 

Compressed  Bitmap  Data 

Bitmap  Image  Projection 

Bitmap  Data  Expansion 

Memory  Addresses  for  the  Bitmap  Area 

Character  Conversion  Buffers 

Fixed  Mode  Process  Flow  Diagram 

Auto-increment  Mode  Process  Flow  Diagram  ... 

Barrel  Shift  Process 

Normal  DMA 

Character  Conversion  DMA 

Super  FX  System  Configuration 

Game  Pak  ROM/RAM  Bus  Diagram 

GSU  Functional  Block  Diagram 

Super  NES  CPU  Memory  Map 

Super  FX  Memory  Map 

Example  of  General  Register 

128  Dot  High  BG  Character  Array 

160  Dot  High  BG  Character  Array 

192  Dot  High  BG  Character  Array 

OBJ  Character  Array 

Plot  Operations  Assigned  by  CMODE 

System  Block  Diagram  (DSP1) 

Super  NES  CPU  and  DSP1  Communications  .... 

DSP  1 Command  Execution 

Mode  20/DSP  Memory  Map 

Mode  21 /DSP  Memory  Map 

Super  NES/DSP1  Memory  Mapping  (Mode  21) 
DSP1  Status  Register  Configuration 


.1-1-1 

1-1-3 

.1-1-2 

1-1-4 

.1-2-1 

1-2-1 

.1-4-1 

1-4-24 

.1-4-2 

1-4-25 

.1-5-1 

1-5-6 

.1-5-2 

1-5-7 

.1-5-3 

...1-5-8 

.1-6-1 

1-6-1 

.1-6-2 

1-6-2 

.1-6-3 

1-6-3 

.1-6-4 

1-6-3 

.1-6-5 

1-6-5 

.1-6-6 

1-6-6 

.1-6-7 

1-6-7 

.1-8-1 

1-8-2 

.1-8-2 

1-8-3 

.1-8-3 

1-8-5 

.1-9-1 

1-9-1 

.1-9-2 

1-9-1 

.2-1-1 

2-1-3 

.2-1-2 

2-1-4 

.2-2-1 

2-2-1 

.2-3-1 

2-3-2 

.2-3-2 

2-3-4 

.2-4-1 

2-4-2 

.2-8-1 

2-8-2 

.2-8-2 

2-8-2 

.2-8-3 

2-8-2 

,2-8-4 

2-8-3 

.2-8-5 

2-8-13 

.3-1-1 

3-1-2 

.3-1-2 

3-1-3 

3-1-3 

3-1-3 

3-1-4 

3-1-4 

3-1-5 

3-1-5 

3-4-1 

3-4-1 

3-4-2 

3-4-2 

LIST  of  FIGURES 


List  of  Figures  (Continued) 


title 


FIGURE 

NUMBER  PAGE 


DSP1  Operations  Flow  Diagram 3-4-3.. 

Super  NES  CPU/DSP  1 Operational  Timing 3-4-4.. 

Trigonometric  Calculation 3-5-1 .. 

Vector  Calculation 3-5-2 .. 

Vector  Size  Comparison 3-5-3 .. 

Vector  Absolute  Value  Calculation 3-5-4.. 

Two-Dimensional  Coordinate  Rotation 3-5-5.. 

Examples  of  Three-Dimensional  Rotation 3-5-6.. 

Assignment  of  Projection  Parameter 3-5-7.. 

Relationship  of  Sight  and  Projected  Plane 3-5-8.. 

Calculation  of  Raster  Data 3-5-9.. 

BG  Screen  and  Displayed  Area 3-5-10 

Calculation  of  Projected  Position  of  Object 3-5-11 

Projection  Image  of  Object 3-5-12 

Calculation  of  Coordinates  for  the  Indicated  Point  on  the  Screen 3-5-13 

Attack  Point  and  Position  Indicated  on  Screen  (Side  View) 3-5-14 

Attitude  Computation 3-5-15 

Object  Coordinate  Rotated  on  Y Axis 3-5-16 

Object  Coordinate  Rotated  on  X Axis 3-5-17 

Object  Coordinate  Rotated  on  Z Axis 3-5-18 

Conversion  of  Global  to  Objective  Coordinates 3-5-19 

Conversion  of  Object  to  Global  Coordinates 3-5-20 

Calculation  of  Inner  Product  with  Forward  Attitude 3-5-21 

Position  of  Aircraft  and  Vector  Code 3-5-22 

Calculation  of  Rotation  Angle  After  Attitude  Change 3-5-23 

Signal  Flow 4-1-1 .. 

Optical  Alignment 4-1-2.. 

Virtual  Screen  Alignment 4-1-3.. 

Address  and  Bit  Assignments 4-1-4.. 

Picture  Tube 4-2-1 .. 

Scanning 4-2-2.. 

Area  Seen  by  Super  NES  Super  Scope 4-2-3.. 

Vertical  Positioning 4-2-4.. 

Horizontal  Positioning 4-2-5.. 

Horizontal/Vertical  Counter 4-2-6.. 

Super  NES  Super  Scope  Block  Diagram 4-3-1  .. 

Super  NES  Super  Scope  Flow  Diagram 4-3-2.. 

Raster  Signal 4.3.3 ... 

Definition  of  One  Bit 4-3-4.. 

Output  Signal  Code 4-3-5.. 

Definitions  of  Codes 4-3-6.. 


.3-4-3 

.3-4-4 

.3-5-3 

.3-5-4 

.3-5-6 

.3-5-7 

.3-5-8 

.3-5-11 

.3-5-13 

.3-5-13 

.3-5-16 

.3-5-16 

.3-5-18 

.3-5-19 

.3-5-20 

.3-5-21 

.3-5-23 

.3-5-23 

.3-5-23 

.3-5-23 

.3-5-26 

.3-5-28 

.3-5-29 

.3-5-30 

.3-5-32 

.4-1-1 

.4-1-2 

.4-1-2 

.4-1-5 

.4-2-1 

.4-2-2 

.4-2-3 

.4-2-4 

.4-2-5 

.4-2-6 

.4-3-2 

.4-3-3 

.4-3-4 

.4-3-5 

.4-3-5 

4-3-6 


IV 


LIST  of  FIGURES 


List  of  Figures  (Continued) 


TITLE 


FIGURE 

NUMBER  PAGE 


Raster  Signal  Transmission  Timing 

Receiver  Block  Diagram 

Operation  Flow  Diagram 

Receiver/Transmitter  Interface  Schematic 

One  Bit  Code  Detection 

Cursor  Mode  Raster  Detection  Cycle 

Trigger  Mode,  Single  Shot 

Trigger  Mode,  Multiple  Shots 

Noise  Flag 

Null  Bit 

Pause  Bit 

Trigger,  Single  Shot 

Trigger,  Multiple  Shots 

Optical  Color  Sensitivity  Chart 

Valid  Hyper  Mouse  Data  String 

Serial  Data  Read  Timing 

Explanation  of  Data  Strings  2 Bits  or  Longer 

Super  NES  Hyper  Mouse  Dimensions 

Standard  BIOS,  Output  Register 

Examples  of  Speed  Switching  Program  Subroutine  Call 

MultiPlayer  5 Device  Hardware  Connections 

MultiPlayer  5 Read  Timing  Chart,  5P  Mode 

Data  Read  Timing  for  Dissimilar  Devices 

Valid  Controller  Data  String 

Sample  Program  Display  Format 


.4-3-7 

4-3-7 

.4-4-1 

4-4-1 

.4-4-2 

4-4-2 

.4-4-3 

4-4-3 

.4-4-4 

4-4-4 

.4-4-5 

4-4-6 

.4-4-6 

4-4-7 

.4-4-7 

4-4-8 

.4-4-8 

4-4-9 

.4-4-9 

4-4-9 

.4-4-10 

4-4-10 

.4-4-11 

4-4-11 

.4-4-12 

4-4-12 

.4-5-1 

4-5-2 

.4-6-1 

4-6-2 

.4-6-2 

4-6-3 

.4-6-3 

4-6-6 

.4-6-4 

4-6-7 

.4-7-1 

4-7-3 

.4-7-2 

4-7-4 

.4-9-1 

4-9-2 

.4-9-2 

4-9-5 

.4-9-3 

4-9-8 

.4-9-4 

4-9-12 

.4-10-1 

4-10-2 

LIST  of  TABLES 


List  of  Tables 
BOOK  II 


TITLE 

Types  of  Interrupts 

Interrupt  Identification  and  Clear 

Interrupt  Mask 

Sending  and  Receiving  a Message 

Situation  Dependant  Vectors 

Operating  Modes  and  Processing  Speeds 

Horizontal  Size  of  VRAM  (CDMA  Register) 

Number  of  Zero  Bits  in  BW-RAM 

Character  Conversion  and  Data  Format 

Arithmetic  Operations  Settings  and  Cycles .... 

Amount  of  Barrel  Shift 

Source  Device  Settings 

Destination  Device  Settings 

DMA  Transmission  Speed 

Timer  Modes  and  Their  Ranges 

Timer  Interrupts 

Registers  Listed  by  Functional  Group 

Instruction  Set 

GSU  General  Registers 

GSU  Status  Register  Flags 

Screen  Height 

Color  Gradient 

Dummy  Interrupt  Vector  Addresses 

Dummy  Data 

Functions  of  CM  ODE 

DSP1  Command  Summary 

Parameter  Data  Type 

Signal  Bit  Definitions 

MultiPlayer  5 Switch  Function 

MultiPlayer  5 Data  Format 


TABLE 

NUMBER 

PAGE 

1-5-1 

1-5-2 

1-5-2 

1-5-2 

1-5-3 

1-5-3 

1-5-4 

1-5-3 

1-5-5 

1-5-4 

1-5-6 

1-5-9 

1-6-1 

1-6-6 

1-6-2 

1-6-8 

1-6-3 

1-6-10 

1-7-1 

1-7-1 

1-8-1 

1-8-4 

1-9-1 

1-9-3 

1-9-2 

1-9-3 

1-9-3 

1-9-4 

1-10-1 

1-10-1 

1-10-2 

1-10-2 

2-2-1 

2-2-3 

2-2-2 

2-2-6 

2-4-1 

2-4-1 

2-4-2 

2-4-4 

2-4-3 

2-4-8 

2-4-4 

2-4-8 

2-5-1 

2-5-4 

2-5-2 

2-5-5 

2-8-1 

2-8-9 

3-2-1 

3-2-1 

3-3-1 

3-3-1 

4-1-1 

4-1-6 

4-9-1 

4-9-3 

4-9-2 

4-9-6 

VI 


SUPER  ACCELERATOR  SYSTEM  FUNCTIONS 


Chapter  1 Super  Accelerator  System  Functions 

The  co-processor  installed  on  the  Super  Accelerator  System  (SA-1 ) is  an  LSI  developed 
to  work  with  the  Super  NES  CPU  and  enhance  its  processing  speed,  graphics,  and  arith- 
metic functions. 

1.1  SA-1  FEATURES 

1.1.1  CPU  CORE 

The  SA-1  uses  a 16-bit  65C816  processor  for  its  CPU  core  (SA-1  CPU). 
It  can  process  the  same  commands  as  the  Super  NES  CPU.  No  new  ar- 
chitecture needs  be  learned  and  existing  programs  can  be  used  without 
modification. 

Because  the  65C816  is  a 16-bit  CPU,  it  efficiently  processes  16-bit  oper- 
ations such  as  X and  Y character  coordinates. 

Due  to  the  commonality  of  the  core  CPUs,  evaluation  of  the  coprocessor 
in  the  middle  of  game  development  is  quite  simple  and  program  modifica- 
tions are  kept  to  a minimum. 

1.1.2  CPU  SPEED 

The  SA-1  CPU  operates  at  10.74  MHz,  which  is  four  times  faster  than  the 
normal  operating  speed  of  the  Super  NES  CPU. 

The  SA-1  CPU  and  the  Super  NES  CPU  operate  simultaneously,  which 
results  in  five  times  greater  performance  of  the  Super  Accelerator  System 
(SAS)  over  the  current  Super  NES. 

1.1.3  INTERNAL  RAM 

The  SA-1  has  a 2 Kbyte  internal  work  RAM  (SA-1  l-RAM).  This  RAM  can 
be  used  as  the  SA-1  CPU’s  page-zero  stack,  or  as  protected  memory 
with  a backup  battery,  when  connected  to  an  external  battery. 

1 .1 .4  COMMON  MEMORY  MAPPING 

The  Super  NES  CPU  and  SA-1  CPU  use  the  same  memory  mapping. 
SA-1  programs  can  be  developed  with  the  Super  NES  Emulator-SE. 

Subroutines  can  be  shared  by  both  CPUs,  resulting  in  efficient  use  of 
memory. 

1.1.5  LARGE-CAPACITY  MEMORY 

The  SAS  has  a total  capacity  of  64  Mbits  of  ROM  and  2 Mbytes  of  RAM. 
SRAM  is  used  for  l-RAM  and  back-up/work  RAM  (BW-RAM),  and  can  be 
protected  with  a backup  battery. 


SNES  DEVELOPMENT  MANUAL 


] 


1 .1 .6  ARITHMETIC  HARDWARE 

The  SA-1  has  hardware  for  high-speed  execution  of  multiplication  (16  bits 
x 16  bits),  division  (16  bits  x 16  bits),  and  cumulative  arithmetic  (X(16  bits 
x 16  bits))  operations.  This  results  in  high-speed  calculation  of  matrix  and 
3D  arithmetic  operations. 

1 .1 .7  BIT-MAP  DATA  OPERATIONS 

The  SAS  allows  virtual  bitmap  VRAM  to  be  set  up  in  the  SA-1  CPU’s 
RAM  area.  The  bitmap  data  in  virtual  VRAM  can  be  converted  to  Super 
NES  PPU  character  format  via  hardware  using  DMA  functions. 

1 .1 .8  VARIABLE-LENGTH  BIT  DATA  OPERATIONS 

The  SA-1  has  a function  to  read  ROM  data  as  1—16  bit  variable-length 
data,  treating  ROM  data  as  strings  of  one-bit  data.  This  allows  for  high- 
speed expansion  of  compressed  data. 

1 .1 .9  CUSTOM  DMA  CIRCUIT 

The  SA-1  has  a custom  DMA  cr-nit  in  addition  to  the  Super  NES  CPU’s 
multi-purpose  H-DMA.  The  DMA  circuit  performs  data  transfer  between 
ROM,  RAM  and  SA-1  BW-RAM.  During  DMA  transfer,  bitmap-to-charac- 
ter  conversion,  and  sequential  operations  with  the  Super  NES  CPU  multi- 
purpose DMA  can  be  performed. 

1.1.10  TIMER  FUNCTION 

The  SA-1  has  an  HV  timer  synchronized  to  the  Super  NES  PPU.  The  HV 
timer  can  be  used  to  reference  the  scan  line  position  on  the  screen  by  the 
SA-1  CPU  or  to  generate  HV  interrupts.  The  timer  can  also  be  used  as  a 
linear  timer. 

1 .1 .1 1 INCREASED  LEVEL  OF  SECURITY 

The  SA-1  is  connected  between  the  Super  NES  CPU  and  memory  . 
(ROM,  RAM).  The  SA-1  ROM  is  also  different  from  the  standard  Super 
NES  game  pak  ROM.  This  guards  against  unlicensed  products  and  FD 
copies. 


1-1-2 


SUPER  ACCELERATOR  SYSTEM  FUNCTIONS 


1 .2  SYSTEM  CONFIGURATION 

The  following  diagram  depicts  the  SAS  system  configuration. 

The  SA-1  and  memory  (game  pak  ROM  and  BW-RAM)  are  installed  in  the  game 
pak.  When  desired,  data  can  be  protected  by  connecting  a backup  battery  to  BW- 
RAM  or  SA-1  l-RAM. 

When  external  RAM  is  not  required,  the  system  can  also  be  configured  without 
BW-RAM. 


Figure  1-1-1  Super  Accelerator  System  Configuration 


1-1-3 


SNES  DEVELOPMENT  MANUAL 


1.3  BUS  IMAGE  DIAGRAM 

The  bus  image  as  seen  by  the  SAS  software  is  depicted  below.  The  SA-1  CPU 
can  access  game  pak  ROM,  BW-RAM  and  l-RAM. 

The  Super  NES  CPU  can  access  game  pak  ROM,  BW-RAM,  l-RAM,  Super  NES 
PPU,  Super  NES  WRAM  and  Super  NES  APU. 


SA-1  CPU 


Super  NES 

| 

, 

Super  NES 

PPU 

l 

> 

L 

WRAM 

Super  NES 
CPU 


Figure  1-1-2  SAS  Bus  Image 

The  two  MPUs  (Super  NES  CPU  and  SA-1  CPU)  can  freely  access  memory 
(game  pak  ROM,  BW-RAM  and  l-RAM).  If  the  two  MPUs  try  to  access  the  same 
memory  at  the  same  time,  one  of  the  MPUs  is  automatically  excluded,  and  any 
conflict  is  averted. 


1-1-4 


Chapter  2 Configuration  of  S A- 1 

2.1  SA-1  FUNCTIONAL  DESCRIPTION 


CONFIGURA  TION  OF  SA-1 


The  SA-1  is  internally  comprised  of  nine  components.  A block  diagram  is  illustrat- 
ed below. 


Figure  1-2-1  SA-1  Block  Diagram 


1-2-1 


SNES  DEVELOPMENT  MANUAL 


2.1.1  SA-1  CPU 

The  65C816  serves  as  the  CPU  core.  It  operates  at  10.74  MHz. 

2.1.2  l-RAM 

The  l-RAM  consists  of  a 16  Kbit  RAM.  The  SA-1  CPU  can  access  the  I- 
RAM  at  10.74  MHz  in  a no-wait  state. 

The  l-RAM  data  can  be  protected  by  connecting  RAM  to  an  external  bat- 
tery. 

2.1.3  SUPER  MMC 

The  Super  MMC  performs  memory  control  in  a map  mode  where  the 
ROM  capacity  exceeds  32  Mbits  (Map  Mode  22). 

The  SA-1  has  a Super  MMC  chip  emulation  circuit. 

The  Super  MMC  includes  a backup  data  protection  function. 

2.1.4  INTERNAL  CONTROLLER 

This  controls  bus  access  within  the  SA-1 . It  performs  collision  control 
functions  between  Super  NES  CPU  and  SA-1  CPU. 

2.1.5  ARITHMETIC  CIRCUIT 

The  arithmetic  circuit  hardware  performs  multiplication,  division,  and  cu- 
mulative arithmetic  operations. 

2.1 .6  CHARACTER  CONVERSION  CIRCUIT 

The  character  conversion  circuit  hardware  converts  bitmap  data  to  char- 
acter data  format. 

2.1.7  VARIABLE-LENGTH  BIT  PROCESSING  CIRCUIT 

The  variable-length  bit  processing  circuit  hardware  processes  data  in  the 
game  pak  ROM  as  1—16  bit  variable-length  data. 

2.1.8  TIMER  CIRCUIT 

The  SA-1  has  a HV  timer  which  is  equivalent  to  the  Super  NES  PPU  tim- 
er. The  timer  can  also  be  used  as  an  18-bit  linear  timer. 

2.1.9  DMA  CIRCUIT 

The  DMA  circuit  transfers  data  between  game  pak  ROM,  BW-RAM  and  I- 
RAM. 


1-2-2 


CONFIGURATION  OF  S A- 1 


2.2  MEMORY  ACCESS 

2.2.1  GAME  PAK  ROM  ACCESS 

The  Super  NES  CPU  and  SA-1  CPU  share  the  entire  game  pak  ROM 
area  and  can  both  freely  access  it.  This  is  known  as  2-phase  access. 

When  only  the  SA-1  CPU  uses  game  pak  ROM,  the  SA-1  CPU  operates 
at  10.74  MHz.  During  this  period  the  Super  NES  CPU  executes  its  pro- 
gram on  Super  NES  WRAM. 

When  both  the  Super  NES  CPU  and  SA-1  CPU  execute  a program  on 
game  pak  ROM,  the  SA-1  CPU  runs  at  5.37  MHz  and  the  Super  NES 
CPU  runs  at  2.68  MHz. 

The  SAS  cannot  utilize  the  Super  NES  CPU’s  high-speed  mode  (3.58 
MHz).  It  operates  at  a fixed  speed  of  2.68  MHz  even  when  only  the  Super 
NES  CPU  uses  game  pak  ROM.  This  timing  is  illustrated  below  for  each 
of  these  conditions. 

2.2.1 .1  ONLY  SA-1  CPU  USES  ROM 


— 

r — 1 0-74  MHz  C=SA-1  CPU 

C 

C 

C 

C 

C 

C 

C 

C 

C 

c 

c 

c 

c 

c 

c 

SA-1 

CPU 

2.2.1 .2  SUPER  NES  CPU  ACCESSES  ROM  DURING  SA-1  CPU  OP- 
ERATIONS 


2.2.1 .3  BOTH  PROCESSORS  ACCESS  ROM  (2-PHASE  ACCESS) 


1-2-3 


SNES  DEVELOPMENT  MANUAL 

I 


2.2.2  BW-RAM  ACCESS 

The  Super  NES  CPU  and  SA-1  CPU  share  all  areas  of  BW-RAM  and  can 
freely  access  it  (two-phase  access). 

The  SA-1  CPU  accesses  BW-RAM  at  5.37  MHz  and  the  Super  NES  CPU 
accesses  BW-RAM  at  2.68  MHz. 

2.2.2. 1 ONLY  SA-1  CPU  USES  BW-RAM 


^ 5.37MHz 


Read 


Read 


T 


No  Access  I 

No  Access 


Read 


Write 


Read 


No  Access 


2.2.2. 2 SUPER  NES  CPU  ACCESSES  BW-RAM  DURING  SA-1  CPU 
OPERATIONS 


.5.37MHz 


C-CPU=SA-1  CPU  Access 
S-CPU=Super  NES  CPU  Access 


C-CPU 


C-CPU 


S-CPU 


C-CPU 


C-CPU 


S-CPU 


No  Access 


No  Access 


2. 2. 2. 3 BOTH  PROCESSORS  ACCESS  BW-RAM  (2-PHASE  ACCESS) 


1-2-4 


CONFIGURATION  OF  SA-1 


2.2.3  SA-1  l-RAM  ACCESS 

The  Super  NES  CPU  and  SA-1  CPU  can  both  access  all  areas  of  SA-1  I- 
RAM  at  any  time. 

2.2.3. 1 ONLY  THE  SA-1  CPU  ACCESSES  l-RAM 


C=SA-1  CPU  Access 


.10.74  MHz 


C C 


SA-1 

CPU  No  Access  No  Access  No  Access  No  Access 


2. 2.3.2  BOTH  SA-1  CPU  AND  SUPER  NES  CPU  ACCESS  l-RAM 


1-2-5 


Super  NES  Memory  Map  (SAS,  Super  NES  CPU) 


Super  NES  Memory  Map  (SAS,  SA-1  CPU) 


3.2  MEMORY  MAP  FROM  SA-1  CPU  PERSPECTIVE 


^ © 

M S> 

OCL  g ^ CO 


VI/  — — 

0 C ^ 

■ro3| 


O 


'j-cx 

j0©Q«- 


vvKw 
vvKw 
wKw 

tVVVVVV 

*sf5i  iWAVV 

■nMtt 

f triWW 

Wf  >!♦!♦!♦!♦!♦!♦: 

■■■■■  lV4%>V4 

iVVVrA 

VWW<ir4 


■HI 


♦ w;v 

♦ w;v 
w>8i 

■ a;  *TatatatJ 


»ra  $!♦>>>« 

tiifl  SiSAfc? 


3 E 

Ji- 

^U- 

S Is- 

© i . 
U-  X ll 
h-  OCD 
* O l 

o o o 

O CD  CO 


■a:<2  <cnuj< 


a mm 


-CE<2  CD  — h-  2<Q-  < QC  LLI  < 


B I 


*I*81aoJBa. 


0 o)i— . ^cyS 

1 i£o  «£2o CO 
connect  m o 


ih^ 


✓ 


^ © 

1§6 

2 ®t> 


►ViViViM 

A A A A A A iff] 

I wawK 
vwKvK 
wawf 
wKwt 

wKw  I 
vw#w  5 
wKw  ■ 
waw 
waw 
v4X%wJ 
Cwtw 


h’VAvl 

v*x*£l 

1 ♦;  oIAj  H 

♦*»»li 

£&W:«| 

♦*>>:« 


1-3-2 


3.3  SUPER  MMC 


The  Super  MMC  is  a Super  NES  memory  controller  which  can  support  a ROM  ca- 
pacity in  excess  of  32  Mbits.  The  memory  map  used  by  the  Super  MMC  is  called 
Map  Mode  22.  The  SA-1  contains  the  Super  MMC  memory  control  function.  Map 
Mode  22  features  are  described  below. 

3.3.1  ROM  BANK  SWITCHING 

The  entire  mask  ROM  is  divided  into  8 Mbit  blocks,  which  can  be  project- 
ed onto  the  8 Mbit  areas,  0000H-FFFFH  in  banks  COH-CFH,  DOH-DFH, 
EOH-EFH,  and  FOH-FFH.  The  same  8 Mbit  data  can  be  projected  onto 
multiple  areas. 

3.3.2  ROM  IMAGE  PROJECTION 

The  ROM  data  in  banks  CXH,  DXH,  EXH,  and  FXH,  described  above,  is 
image  projected  onto,  respectively,  the  8 Mbit  area  8000H-FFFFH,  in 
banks  00H-1FH,  20H-3FH,  80H-9FH,  and  AOH-BFH. 

The  image  projection  method  used  is  different  from  that  used  in  Map 
Mode  21  in  that  the  ROM  data  is  projected  in  successive  order,  as  dem- 
onstrated below. 

C0:0000H~C0:7FFFH  ->  00:8000H~00:FFFFH 
C0:8000H~C0:FFFFH  -»  01 :8000H~01  :FFFFH 
Cl  :0000H~C1 :7FFFH  ->  02:8000H~02:FFFFH 


CF:8000H~CF:7FFFH  ->  1F:8000H~1F:FFFFH 

It  is  also  possible  to  project  the  first  8 Mbits  of  data  in  the  mask  ROM 
(00:0000H~0F:FFFFH)  onto  bank  00H-1 FH,  regardless  of  the  settings 
for  banks  CXH,  DXH,  EXH,  and  FXH.  In  a similar  manner,  data  in 
10:0000H~1F:FFFFH,  20:0000H~2F:FFFFH,  and  30:0000H~3F:FFFFH 
can  be  projected  onto  banks  20H-3FH,  80H-9FH,  and  AOH-BFH,  re- 
spectively. 

3.3.3  BACKUP  RAM 

Backup  RAM  is  assigned  to  areas  in  bank  40H,  justified  to  0000H,  as  il- 
lustrated below. 

16K  RAM:  40:0000H~40:07FFH 

64K  RAM:  40:0000H~40:1FFFH 

256K  RAM:  40:0000H~40:7FFFH 

1M  RAM:  40:0000H~41  :FFFFH 


1-3-3 


SUPER  ACCELERATOR  MEMORY  MAP 


Backup  RAM  is  image  projected  to  the  64  Kbit  areas  in  6000H-7FFFH  of 
banks  00H-3FH  and  80H-BFH.  The  backup  area  can  be  divided  into  64 
Kbit  blocks.  Any  of  these  blocks  can  be  projected  as  images.  The  data  is 
identical  in  banks  00H-3FH  and  80H-BFH. 

3.3.4  PROTECTION  OF  BACKUP  DATA 

A write-protect  setting  is  available  to  prevent  data  in  the  backup  data  area 
(banks  40H-7DH  from  being  damaged.  This  setting  protects  data  even  in 
case  of  a CPU  crash. 

3.3.5  CONTROL  REGISTERS 

The  Super  MMC  control  registers  are  assigned  to  2200H-23FFH  of 
banks  00H-3FH  and  80H-BFH. 

3.3.6  CAUTIONS 

Note  that  when  the  SA-1  Super  MMC  emulation  function  is  used,  the  fol- 
lowing specifications  for  the  Super  MMC  do  not  apply. 

3.3.6. 1 HIGH  SPEED  MODE 

The  SAS  cannot  use  the  Super  NES  CPU  high-speed  mode 
(3.58  MHz). 

3.3. 6.2  ROM  AND  BACKUP  RAM  AREA 

The  maximum  mask  ROM  area  is  64  Mbits.  The  maximum  back- 
up RAM  area  is  2 Mbits. 

3. 3.6. 3 SHARED  ROM  MEMORY  MAP 

The  Super  NES  CPU  and  SA-1  CPU  share  a common  ROM 
memory  map. 

The  ROM  data  in  banks  CXH,  DXH,  EXH,  and  FXH  is  identical 
(the  same  data  is  projected)  for  the  Super  NES  CPU  and  SA-1 
CPU.  However,  the  program  can  be  executed  in  different  banks 
for  each  processor. 

3.3. 6. 4 BACKUP  RAM  PROTECTION 

The  image  projected  to  Backup  RAM  is  specified  separately. 

The  RAM  data  which  is  projected  to  the  backup  RAM  image  area 
in  00H-3FH  and  80H-BFH  can  be  specified  separately  for  the 
Super  NES  CPU  and  SA-1  CPU. 


1-3-4 


SNES  DEVELOPMENT  MANUAL 

I 


SA-1  l-RAM  PRE-ASSIGNED 


3. 3.6. 5 

SA-1  internal  RAM  (l-RAM)  is  assigned  according  to  memory 
mapping. 

The  l-RAM  is  assigned  to  3000H-37FFH  in  banks  00H-3FH  and 
80H-BFH  during  Super  NES  CPU  access  and  to  3000H-37FFH 
and  0000H-07FFH  in  banks  00H-3FH  and  80H-BFH  during 
SA-1  CPU  access. 

3.4  VECTORS  AND  ROM-REGISTERED  DATA 

Set  the  address  for  the  Super  NES  CPU  vectors  and  ROM-registered  data  to 
00:7FB0H~00:7FFFH.  When  set  to  this  area,  they  are  assigned  to 
FFBOH-FFFFH  in  bank  00H  at  Super  NES  start-up. 


1-3-5 


Chapter  4 SA-1  Internal  Register  Configuration 


The  SA-1  internal  registers  are  assigned  to  addresses  2200H-23FFH  in  the  Super  NES 
CPU  and  SA-1  CPU  banks  00H-3FH  and  80H-BFH.  Registers  with  addresses  22**H 
are  write  registers  and  those  with  addresses  23**H  are  read  registers. 

4.1  EXPLANATION  OF  REGISTERS 

4.1.1  SA-1  CPU  CONTROL  (CCNT) 

Access:  Super  NES  CPU  Write 
Address:  **2200H 

Size:  8 bits 
Initial  value:  20H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SA-1 

SA-1 

SA-1 

SA-1 

CPU 

CPU 

CPU 

CPU 

SMEG3 

SMEG2 

SMEG1 

SMEGO  2200H 

IRQ 

RDY  B 

RESB 

NMI 

1 i 

SA-1  CPU  IRQ:  SA-1  CPU  IRQ  (from  Super  NES  CPU) 

0:  No  Interrupt 
1 : Interrupt 

SA-1  CPU  RDY  B:  Ready 

0:  Ready 
1 : Wait 

SA-1  CPU  RESB:  SA-1  CPU  reset 

0:  Cancel 
1 : Reset 

SA-1  CPU  NMI:  SA-1  CPU  NMI  (from  Super  NES  CPU) 

0:  No  Interrupt 
1 : Interrupt 

SMEG0-SMEG3:  Message  from  Super  NES  CPU  to  SA-1  CPU 


1-4-1 


SNES  DEVELOPMENT  MANUAL 


4.1 .2  SUPER  NES  CPU  INT  ENABLE  (SIE) 

Access:  Super  NES  CPU  Write 
Address:  **2201 H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SA-1 

CPU 

IRQEN 

0 

CHDMA 

IRQEN 

0 

0 

0 

0 

0 

2201 H 


SA-1  CPU  IRQEN:  IRQ  enable/disable  from  the  SA-1  CPU 
0:  Disable 
1:  Enable 

CHDMA  IRQEN:  Character  conversion  DMA  IRQ  enable/disable 

0:  Disable 
1:  Enable 

4.1 .3  SUPER  NES  CPU  INT  CLEAR  (SIC) 

Access:  Super  NES  CPU  Write 
Address:  **2202H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SA-1 

CPU 

IRQCL 

0 

CHDMA 

IRQCL 

0 

0 

0 

0 

0 

2202H 


SA-1  CPU  IRQCL:  IRQ  clear  from  the  SA-1  CPU 
0:  No  change 
1:  Clear 


CHDMA  IRQCL:  Character  conversion  DMA  IRQ  clear 

0:  No  change 
1 : Clear 


1-4-2 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .4  SA-1  CPU  RESET  VECTOR  (CRV) 

Access:  Super  NES  CPU  Write 
Address:  **2203H,  **2204H 

Size:  16  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2203H 
2204H 


CRV7 

CRV6 

SA-1  t 
CRV5 

;pu  Reset  Vectc 
CRV4  | CRV3 

— 

r 

CRV2 

CRV1 

CRVO 

CRV15 

CRV14 

SA-1  C 
CRV13 

PU  Reset  Vecto 
CRV12  CRV11 

r 

CRV10 

CRV9 

CRV8 

4.1 .5  SA-1  CPU  NMI  VECTOR  (CNV) 

Access:  Super  NES  CPU  Write 
Address:  **2205H,  **2206H 

Size:  16  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 


2205H 


2206H 


CNV7 

S$A-1  CP 
CNV6  1 CNV5 

J NMI  Vector  (Low) 
CNV4  | CNV3  | CNV2 

CNV1 

CNVO 

CNV15 

CNV14 

A-1  CPI 
CNV13 

NMI  Vc 
CNV12 

;ctor  (Hi 
CNV11 

gh) 

CNV10 

CNV9 

CNV8 

4.1 .6  SA-1  CPU  IRQ  VECTOR  (CIV) 

Access:  Super  NES  CPU  Write 
Address:  **22071-1,  **2208H 

Size:  16  bits 
Initial  value:  Unspecified 

D7  D6  D5  D4  D3  D2  D1  DO 


2207H 


2208H 


CIV7 

CIV6 

SA-1  ( 
CIV5 

^PU  IRC 
CIV4 

1 Vector 
CIV3 

(Low) 

CIV2 

CIV1 

CIVO 

CIV15 

CIV14 

SA-1  C 
CIV13 

)P\J  IRQ 
CIV12 

Vector 

CIV11 

High) 

CIV10 

CIV9 

CIV8 

1-4-3 


SNES  DEVELOPMENT  MANUAL 


4.1 .7  SUPER  NES  CPU  CONTROL  (SCNT) 

Access:  SA-1  CPU  Write 
Address:  **2209H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SNES 

CPU 

IRQ 

SNES 

CPU 

IVSW 

0 

SNES 

CPU 

NVSW 

CMEG3 

CMEG2 

CMEG1 

CMEGO 

2209H 


Super  NES 
CPU  IRQ: 

IRQ  from  SA-1  CPU  to  Super  NES  CPU 
0:  No  IRQ  interrupt 
1:  IRQ  interrupt 

Super  NES 
CPU  IVSW: 

Super  NES  CPU  IRQ  vector  selection 
0:  Game  pak  ROM 

1 : Super  NES  CPU  IRQ  vector  register 

Super  NES 
CPU  NVSW 

Super  NES  CPU  NMI  vector  selection 
0:  Game  pak  ROM 

1:  Super  NES  CPU  NMI  vector  register 

CMEG0-CMEG3:  Message  from  SA-1  CPU  to  Super  NES  CPU 


1-4-4 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .8  SA-1  CPU  INT  ENABLE  (CIE) 

Access:  SA-1  CPU  Write 
Address:  **220AH 

Size:  8 bits 
Initial  value:  OOH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SNES 

CPU 

IRQEN 

Timer 

IRQEN 

DMA 

IRQEN 

SNES 

CPU 

NMIEN 

0 

0 

0 

0 

220AH 


Super  NES 
CPU  IRQEN: 


Timer  IRQEN: 


DMA  IRQEN: 


IRQ  control  from  Super  NES  CPU  to  SA-1  CPU 
0:  Disable 
1:  Enable 

IRQ  control  from  timer  to  SA-1  CPU 
0:  Disable 
1:  Enable 

IRQ  control  to  SA-1  CPU  at  end  of  SA-1  DMA 
0:  Disable 
1:  Enable 


Super  NES 

CPU  NMIEN:  NMI  control  from  Super  NES  CPU  to  SA-1  CPU 

0:  Disable 
1:  Enable 


1-4-5 


SNES  DEVELOPMENT  MANUAL 


4.1 .9  SA-1  CPU  INT  CLEAR  (CIC) 

Access:  SA-1  CPU  Write 
Address:  **220BH 

Size:  8 bits 
Initial  value:  OOH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SNES 

CPU 

IRQCL 

Timer 

IRQCL 

DMA 

IRQCL 

SNES 

CPU 

NMICL 

0 

0 

0 

0 

220BH 


Super  NES 

CPU  IRQCL: 

IRQ  clear  from  Super  NES  CPU  to  SA-1  CPU 
0:  No  change 
1 : Clear 

Timer  IRQCL: 

IRQ  clear  from  timer  to  SA-1  CPU 
0:  No  change 
1:  Clear 

DMA  IRQCL: 

IRQ  clear  to  SA-1  CPU  at  end  of  SA-1  DMA 
0:  No  change 
1 : Clear 

Super  NES 

CPU  NMICL: 

NMI  clear  from  Super  NES  CPU  to  SA-1  CPU 
0:  No  change 
1:  Clear 

1-4-6 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .1 0 SUPER  NES  CPU  NMI  VECTOR  (SNV) 

Access:  SA-1  CPU  Write 
Address:  **220CH,  **220DH 

Size:  16  bits 
Initial  value:  Nonspecific 


D7 

D6  D5  D4 

D3 

D2  D1 

DO 

SNV7 

3uper  NES  CPU 
SNV6  1 SNV5  1 SNV4 

MMI  Vec 
SNV3 

tor  (Low) 

SNV2  | SNV1 

SNVO 

SNV15 

Super  NES  CPU  f 
SNV14  SNV13  SNV12 

4 Ml"  Vec 
SNV11 

or  (High) 
SNV10  SNV9 

SNV8 

220CH 

220DH 


4.1 .1 1 SUPER  NES  CPU  IRQ  VECTOR  (SIV) 

Access:  SA-1  CPU  Write 
Address:  **220EH,  **220FH 

Size:  16  bits 
Initial  value:  Nonspecific 


D7 

D6 

D5 

D4 

D3 

D2  D1 

DO 

SIV7 

c 

V- 

SIV6 

uper  NE 
SIV5 

IS  CPU 
SIV4 

RQ  Vec 
SIV3 

tor  (Low) 

SIV2  1 SIV1 

SIVO 

SIV15 

S 

SIV14 

uper  NE 
SIV13 

S CPU  1 
SIV12 

RQ  Vec 
SIV11 

or  (High) 
SIV10  SIV9 

SIV8 

220EH 

220FH 


1-4-7 


4.1.12  H/V  TIMER  CONTROL  (TMC) 


Access:  SA-1  CPU  Write 
Address:  **221  OH 

Size:  8 bits 
Initial  value:  00H 


2210H 


HVSELB:  Select  HV  timer 

0:  HV  Timer 
1 : Linear  Timer 

VEN,  HEN:  V count  enable,  H count  enable 

00:  Disable  both  H and  V 
01 : Enable  H only:  IRQ  at  H timer  value 
10:  Enable  V only:  IRQ  at  V timer  value 
1 1 : Enable  both  H and  V:  IRQ  at  H/V  timer  values 

4.1 .1 3 SA-1  CPU  TIMER  RESTART  (CTR) 

Access:  SA-1  CPU  Write 

Address:  **221 1 H 

Size:  8 bits 

Initial  value:  Nonspecific 


Writing  any  value  to  this  register  restarts  the  timer  at  0. 


1-4-8 


SA-1  INTERNAL  REGISTER  CONFIGURATION 

1 

4.1 .1 4 SET  H-COUNT  (HCNT) 

Access:  SA-1  CPU  Write 
Address:  **2212H,**2213H 

Size:  16  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

221 2H 
221 3H 


H7 

H6 

H5 

H-Coun 

H4 

: (Low) 
H3 

H2 

HI 

HO 

0 

0 

0 

H-Coun 

0 

(High) 

0 

0 

0 

H8 

HV  timer:  Timer  IRQ  H count  value  (0-340) 

Linear  timer:  Lower  9 bits  of  the  timer  IRQ  linear  counter  (0-511) 

4.1.15  SET  V COUNT  (VCNT) 

Access:  SA-1  CPU  Write 
Address:  **221 4H,  ’*221 5H 

Size:  16  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2214H 


221 5H 


V7 

V6 

V5 

V-Coun 

V4 

(Low) 

V3 

V 2 

VI 

VO 

0 

0 

0 

V-Counl 

0 

(High) 

0 

0 

0 

V8 

HV  timer:  Timer  IRQ  V count  value 

NTSC,  0-261 
PAL,  0-311 

Linear  timer:  Upper  9 bits  of  the  timer  IRQ  linear  counter  (0-511) 


1-4-9 


4.1.16  SET  SUPER  MMC  BANK  C (CXB) 

Access:  Super  NES  CPU  Write 
Address:  **2220H 

Size:  8 bits 
Initial  value:  OOH 


2220H 


CBM:  CXH  Bank  Image  Projection 

1 : CXH  bank  data  is  copied  into  addresses 

8000H-FFFFH  of  banks  0XH-1XH  (shaded). 

0:  The  game  pak  ROM  area  © is  copied  to  ad- 

dresses 8000H-FFFFH  of  banks  0XH-1XH. 


FX  EX  DX  CX  BX  AX  9X  8X  7X  6X  5X  4X  3X  2X  IX  OX 


1-4-10 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


I 

4.1 .1 7 SET  SUPER  MMC  BANK  D (DXB) 

Access:  Super  NES  CPU  Write 
Address:  **2221 H 

Size:  8 bits 
Initial  value:  01 H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

DBM 

0 

0 

0 

0 

CB2 

CB1 

CBO 

2221 H 


DBM:  DXH  Bank  Image  Projection 

1 : DXH  bank  data  is  copied  into  addresses 

8000H-FFFFH  of  banks  2XH-3XH  (shaded). 

0:  The  game  pak  ROM  area  © is  copied  to  ad- 

dresses 8000H-FFFFH  of  banks  2XH-3XH. 


FX  EX  DX  CX  BX  AX  9X  8X  7X  6X  5X  4X  3X  2X  IX  OX 


FFFFH 


8000H 


0000H 


|- 

© 

- 

© 

- 

© 

- 

© 

- 

@ 

- 

© 

- 

© 

- 

© 

7F:FFFFH 

70:0000H 

60:OOOOH 

50:0000H 

40:0000H 

30:0000H 

20:0000H 

10:OOOOH 

00:000QH 


ROM  Area  Selection  (CB0-CB2) 


CB2 

CB1 

CBO 

ROM  Area 

0 

0 

0 

© 

0 

0 

1 

© 

0 

1 

0 

(D 

0 

1 

1 

© 

1 

0 

0 

© 

1 

0 

1 

© 

1 

1 

0 

© 

1 

1 

1 

© 

1-4-11 


! 


SNES  DEVELOPMENT  MANUAL 


4.1.18  SET  SUPER  MMC  BANK  E (EXB) 

Access:  Super  NES  CPU  Write 
Address:  **2222H 

Size:  8 bits 
Initial  value:  02H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

EBM 

0 

0 

0 

0 

CB2 

CB1 

CB0 

2222H 


EBM: 


EXH  Bank  Image  Projection 

1 : EXH  bank  data  is  copied  into  addresses 

8000H-FFFFH  of  banks  8XH-9XH  (shaded). 

0:  The  game  pak  ROM  area  ® is  copied  to  ad- 

dresses 8000H-FFFFH  of  banks  8XH-9XH. 


FX  EX  DX  CX  BX  AX  9X  8X  7X  6X  5X  4X  3X  2X  IX  OX 


FFFFH 


8000H 


0000H 


r- 

© 

- 

- 

© 

- 

© 

- 

© 

- 

© 

- 

© 

- 

7F:FFFFH 
70:0000H 
60: 000 OH 
50:0000H 
40:0000H 
30:OOOOH 
20:0000H 

10:0000H  - - I 

£ 8 Mbit  f 


64  Mbit 


00:0000H  1 


ROM  Area  Selection  (CB0-CB2) 


CB2 

CB1 

CB0 

ROM  Area 

0 

0 

0 

© 

0 

0 

1 

© 

0 

1 

0 

© 

0 

1 

1 

@ 

1 

0 

0 

1 

0 

1 

© 

1 

1 

0 

© 

1 

1 

1 

1-4-12 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1.19  SET  SUPER  MMC  BANK  F (FXB) 

Access:  Super  NES  CPU  Write 
Address:  **2223H 

Size:  8 bits 
Initial  value:  03H 

D7  D6  D5  D4  D3  D2  D1  DO 

2223H 


FBM:  FXH  Bank  Image  Projection 

1 : FXH  bank  data  is  copied  into  addresses 

8000H-FFFFH  of  banks  AXH-BXH  (shaded). 

0:  The  game  pak  ROM  area  © is  copied  to  ad- 

dresses 8000H-FFFFH  of  banks  AXH-BXH. 


FX  EX  DX  CX  BX  AX  9X  8X  7X  6X  5X  4X  3X  2X  IX  OX 


FFFFH 


8000H 


0000 H 


© 

7F:FFFFH 

© 

/ U.UUUUn 
fin-nnnnu 

© 

DU.UUUUn 

© 

OU.UUUUM 

© 

4U.UUUUH 

© 

JU.UUUUn 

on-nnnnu 

© 

DU.UUUUn 

© 

1 U.UuUOH 
00:0000H 

1-4-13 


SNES  DEVELOPMENT  MANUAL 

I 


4.1.20  SUPER  NES  CPU  BW-RAM  ADDRESS  MAPPING  (BMAPS) 

Access:  Super  NES  CPU  Write 
Address:  **2224H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

0 

0 

0 

SBM4 

SBM3 

SBM2 

SBM1 

SBMO 

2224H 


SBMO-4:  BW-RAM  Address  Image  Mapping  for  Super  NES 

CPU 

The  BW-RAM  image  to  be  mapped  to  addresses 
6000H-7FFFH  of  banks  00H-3FH  and  80H-BFH  is 
user  selectable  from  00~1  F. 


FX  CX  BX  AX  9X  8X  7X  43  42  41  40  3X  2X  IX  OX 


FFFFH 


8000H 

6000H 


0000H 


Note:  The  same  image  is  mapped  to  all  areas,  (i.e., 
00:6000H~00:7FFFH,  01:6000H~01:7FFFH  .... 
BF:6000H~BF:7FFFH). 


1-4-14 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1.21  SA-1  CPU  BW-RAM  ADDRESS  MAPPING  (BMAP) 

Access:  SA-1  CPU  Write 
Address:  **2225H 

Size:  8 bits 
Initial  value:  OOH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SW46 

CBM6 

CBM5 

CBM4 

CBM3 

CBM2 

CBM1 

CBM0 

2225H 


CBM0-CBM6:  BW-RAM  Address  Image  Mapping  for  SA-1  CPU 

This  selects  the  BW-RAM  image  to  be  mapped  to 
the  SA-1  CPU  at  addresses  6000H-7FFFH  of  banks 
00H-3FH  and  80H-BFH. 


SW46:  Specifies  the  BW-RAM  source  to  be  projected 

0:  Banks  40H-43H  are  displayed  in  32 

blocks  using  CBM0-CBM4. 

1 : Banks  60H-6FH  are  displayed  in  128 

blocks  using  CBM0-CBM6. 


FX  CX  BX  AX  9X  8X  7X6F  60  43  42  41  40  3X  2X  IX  OX 


FFFFH 


8000H 
6000 H 


0000H 


Note:  The  same  image  is  mapped  to  all  areas,  (i.e., 
00:6000H~00:7FFFH,  01:6000H~01:7FFFH  .... 
BF:6000H~BF:7FFFH). 


1-4-15 


SNES  DEVELOPMENT  MANUAL 

I 


4.1 .22  SUPER  NES  CPU  BW-RAM  WRITE  ENABLE  (SBWE) 

Access:  Super  NES  CPU  Write 
Address:  **2226H 

Size:  8 bits 
Initial  value:  OOH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SWEN 

0 

0 

0 

0 

0 

0 

0 

SWEN:  Cancels  BW-RAM  write  protection  from  Super  NES 

CPU 

0:  Protect 
1 : Write  enable 

4.1.23  SA-1  CPU  BW-RAM  WRITE  ENABLE  (CBWE) 

Access:  SA-1  CPU  Write 
Address:  **2227H 

Size:  8 bits 
Initial  value:  OOH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

CWEN 

0 

0 

0 

0 

0 

0 

0 

2227H 


CWEN:  Cancels  BW-RAM  write  protection  from  SA-1  CPU 

0:  Protect 
1:  Write  enable 


1-4-16 


SA-1  INTERNAL  REGISTER  CONFIGURATION 

1 

4.1 .24  BW-RAM  WRITE-PROTECTED  AREA  (BWPA) 

Access:  Super  NES  CPU  Write 
Address:  **2228H 

Size:  8 bits 
Initial  value:  FFH 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

0 

0 

0 

0 

BWP3 

BWP2 

BWP1 

BWPO 

2228H 


BWPO-3:  BW-RAM  Write  Protected  Area  Setting 


BWP3 

BWP2 

BWP1 

BWPO 

BW-RAM  Write  Protected  Area 

Area 

Size  (bits) 

0 

0 

0 

0 

400000  - 4000FF 

2K 

0 

0 

0 

1 

400000  - 4001 FF 

4K 

0 

0 

1 

0 

400000  - 4003 FF 

8K 

0 

0 

1 

1 

400000  - 4007FF 

16K 

0 

1 

0 

0 

400000  - 400FFF 

32K 

0 

1 

0 

1 

400000  - 401 FFF 

64K 

0 

1 

1 

0 

400000  - 403FFF 

128K 

0 

1 

1 

1 

400000  - 407FFF 

256K 

1 

0 

0 

0 

400000  - 40FFFF 

512K 

1 

0 

0 

1 

400000- 41 FFFF 

1M 

1 

0 

1 

0 

400000  - 43FFFF 

2M 

At  start-up,  all  areas  are  write-protected. 


1-4-17 


SNES  DEVELOPMENT  MANUAL 


4.1.25  SA-1  l-RAM  WRITE  PROTECTION  (SIWP) 

Access:  Super  NES  CPU  Write 
Address:  **2229H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SIWP7 

SIWP6 

SIWP5 

SIWP4 

SIWP3 

SIWP2 

SIWP1 

SIWPO 

2229H 


SIWPO-7:  SA-1  l-RAM  Write  Protection  Setting 


0:  Write  disable 
1 : Write  enable 


SIWPO:  Sets  3000H  ~ 30FFH 
SIWP1:  Sets  3100H  ~ 31FFH 
SIWP2:  Sets  3200H  ~ 32FFH 
SIWP3:  Sets  3300H  ~ 33FFH 
SIWP4:  Sets  3400H  - 34FFH 
SIWP5:  Sets  3500H  ~ 35FFH 
SIWP6:  Sets  3600H  ~ 36FFH 
SIWP7:  Sets  3700H  ~ 37FFH 


SA-1  l-RAM 
37FFH 

3700H 

3600H 

3500H 

3400H 

3300H 

3200H 

3100H 

3000H 


(D 

" * * 

a 

© 

® 

(D 

16Kt 

© 

© 

© 

© 

2Kbit  v 

1-4-18 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .26  SA-1  l-RAM  WRITE  PROTECTION  (CIWP) 

Access:  SA-1  CPU  Write 
Address:  **222AH 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

CIWP7 

CIWP6 

CIWP5 

CIWP4 

CIWP3 

CIWP2 

CIWP1 

CIWPO 

222AH 


CIWP0~CIWP7:  SA-1  l-RAM  write  protection  setting 

0:  Write  disable 
1 : Write  enable 


CIWPO:  Sets  3000H  - 30FFH 
0000H  ~ OOFFH 
CIWP1 : Sets  31 00H  ~ 31 FFH 
0100H  ~ 01  FFH 
CIWP2:  Sets  3200H  ~ 32FFH 
0200H  ~ 02FFH 
CIWP3:  Sets  3300H  ~ 33FFH 
0300H  ~ 03FFH 
CIWP4:  Sets  3400H  - 34FFH 
0400H  ~ 04FFH 
CIWP5:  Sets  3500H  ~ 35FFH 
0500H  - 05FFH 
CIWP6:  Sets  3600H  - 36FFH 
0600H  - 06FFH 
CIWP7:  Sets  3700H  ~ 37FFH 
0700H  ~ 07FFH 


07FFH 

0700H 

0600H 

0500H 

0400H 

0300H 

0200H 

0100H 

0000H 


0 


© 


37FFH- 
3700H 
3600H 
3500H 
3400 FI 
3300 H 
3200 H 
3100H- 
3000H- 


16Kbit 


2Kbit 


1-4-19 


SNES  DEVELOPMENT  MANUAL 

r 


4.1 .27  DMA  CONTROL  (DCNT) 

Access:  SA-1  CPU  Write 
Address:  **2230H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

DMAEN 

DPrio 

CDEN 

CDSEL 

0 

DD 

SD1 

SDO 

2230H 


DMAEN:  DMA  Enable  Control 

0:  DMA  disable 
1:  DMA  enable 

DPrio:  Processing  priority  between  SA-1  CPU  and  DMA 

0:  SA-1  CPU  priority 
1 : DMA  priority 

DD:  Destination  device 


0:  SA-1  l-RAM 
1:  BW-RAM 

SDO,  SD1:  Source  Device 


SD1 

SDO 

Device 

0 

0 

Game  Pak  ROM 

0 

1 

BW-RAM 

1 

0 

SA-1  l-RAM 

CDEN:  DMA  mode  selection 


0:  Normal  DMA 
1 : Character  conversion  DMA 

CDSEL:  Character  conversion  DMA  type 

0:  SA-1  CPU  — > SA-1  l-RAM  write  (CHR  conv  2) 

1:  BW-RAM  -4  SA-1  l-RAM  transfer  (CHR  conv  1) 


1-4-20 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .28  CHARACTER  CONVERSION  DMA  PARAMETERS  (CDMA) 

Access:  SA-1  CPU/Super  NES  CPU  Write 
Address:  **2231 H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

CHDEND 

0 

0 

SIZE2 

SIZE1 

SIZEO 

CB1 

CBO 

2231 H 


CBO  and  CB1 : Character  conversion  DMA  color  mode 


CB1 

CBO 

Character  Format 

0 

0 

8 Bit/Dot 

0 

1 

4 Bit/Dot 

1 

0 

2 Bit/Dot 

1 

1 

SIZE  0~2:  Number  of  virtual  VRAM  horizontal  characters 


SIZE2 

SIZE1 

SIZEO 

Number  of  Characters 

0 

0 

0 

1 

0 

0 

1 

2 

0 

1 

0 

4 

0 

1 

1 

8 

1 

0 

0 

16 

1 

0 

1 

32 

CHDEND:  End  character  conversion  1 

When  character  conversion  1 is  completed, 
CHDEND  is  set  to  “1”  by  the  Super  NES  CPU. 


1-4-21 


SNES  DEVELOPMENT  MANUAL 


4.1 .29  DMA  SOURCE  DEVICE  START  ADDRESS  (SDA) 


Access:  Super  NES  CPU/SA-1  CPU  Write 
Address:  **2232H  ~ **2234H 

Size:  24  bits 
Initial  value:  Nonspecific 


D7  D6  D5  D4  D3  D2  D1  DO 


DSA7 

DMA  Source  1 
DSA6  DSA5 

Device  A 
DSA4 

Start  A< 
DSA3 

Idress  (Low) 
DSA2  DSA-1 

DSAO 

DSA-1J 

DMA  Source  Device  A 5 
i DS  A- 1 1 DSA- 1 i DSA- 1 S 

start  Adc 
l DSA-1  j 

ress  (Mi 
DSA-1  C 

ddle) 

DSA9 

DSA8 

DSA23 

DMA  1 
DSA22 

Source  C 
DSA21 

device  A 
DSA20 

Start  Ac 
DSA- IS 

dress  (H 
DSA-1  E 

tigh) 
DSA- 17 

DSA-1 0 

2232 H 
2233H 
2234H 


DSA0-DSA23:  DMA  source  device  A start  address 

Data  should  be  stored  to  the  SDA  registers  in  the  order  of  Low  — » Middle 
->  High. 

4.1 .30  DMA  DESTINATION  START  ADDRESS  (DDA) 

Access:  Super  NES  CPU/SA-1  CPU  Write 
Address:  **2235H  ~ **2237H 

Size:  24  bits 
Initial  value:  Nonspecific 


2235  H 
2236H 
2237H 


D7  D6  D5  D4  D3  D2  D1  DO 


DDA7 

DMA  Destination  Device  Start  / 
DDA6  DDA5  DDA4  DDA3 

\ddress  '(Low) 
DDA2  | DDA1 

DDAO 

DDA15 

DMA  De 
DDA14 

stinatior 

DDA13 

i Device 
DDA12 

Start  Ac 
DDA11 

dress  (1^ 
DDA10 

/liddle) 

DDA9 

DDA8 

DDA23 

DMA  C 
DDA22 

estinatic 

DDA21 

>n  Devic 
DDA20 

3 Start  A 
DDA19 

ddress  i 
DDA18 

High) 

DDA17 

DDA16 

DDA0-DDA23:  DMA  destination  device  start  address 

When  transmitting  to  SA-1  l-RAM,  DMA  transfer  is  initiated  by  the  write  to 
register  2236H. 

When  transmitting  to  BW-RAM,  DMA  transfer  is  initiated  by  the  write  to 
register  2237H. 

Data  should  be  stored  to  the  DDA  registers  in  the  order  of  Low  -4  Middle 
-»  High. 


1-4-22 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .31  DMA  TERMINAL  COUNTER  (DTC) 

Access:  SA-1  CPU  Write 

Address:  **2238H,  “2239H 

Size:  16  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2238H 


2239H 


TO-T 1 5:  Number  of  bytes  (1  ~ 65535)  for  DMA  transmission 

4.1 .32  BW-RAM  BIT  MAP  FORMAT  (BBF) 

Access:  SA-1  CPU  Write 

Address:  **223FH 

Size:  8 bits 
Initial  value:  00H 


T7 

T6 

DMA 

T5 

Termina 

T4 

Counter  (Low) 
T3  T2 

T1 

TO 

T15 

T14 

DMA' 

T13 

"ermina 

T12 

Counte 

Til 

■(High) 

T10 

T9 

T8 

D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SEL42 

223FH 


SEL42:  BW-RAM  bitmap  logical  space  format  setting  from 

the  perspective  of  the  SA-1  CPU 
0:  16  color  mode  (4  bits/dot) 

1 : 4 color  mode  (2  bits/dot) 


1-4-23 


SNES  DEVELOPMENT  MANUAL 


4.1 .33  BIT  MAP  REGISTER  FILE  (BRF) 

Access:  SA-1  CPU  Write 

Address:  **2240H  ~ **224FH 

Size:  16  bytes 
Initial  value:  Nonspecific 


D7  D6  D5  D4  D3  D2  D1  DO 


BM07 

BM06 

Bit 

BM05 

map  Rec 
BM04 

lister  File  0 
BM03  1 BM02 

BMOI 

BMOO 

2240 H 
2241 H 
2242 H 
2243 H 
2244 H 
2245H 
2246 H 
2247H 

BM17 

BM16 

Biti 

BM15 

map  Rec 
BM14 

ister  Fil 
BM13 

3 1 

BM12 

BM1 1 

BMIO 

BM27 

BM26 

Bit 

BM25 

map  Rec 
BM24 

ister  Fil 
BM23 

32 

BM22 

BM21 

BM20 

BM37 

BM36 

Bit 

BM35 

map  Rec 
BM34 

lister  Fil 
BM33 

e 3 
BM32 

BM31 

BM30 

BM47 

BM46 

Bit 

BM45 

map  Rec 
BM44 

ister  Fil 
BM43 

3 4 

BM42 

BM41 

BM40 

BM57 

BM56 

Bit 

BM55 

map  Rec 
BM54 

jister  Fill 
BM53 

35 

BM52 

BM51 

BM50 

BM67 

BM66 

Biti 

BM65 

map  Rec 
BM64 

lister  File 
BM63 

36 

BM62 

BM61 

BM60 

BM77 

BM76 

Bitr 

BM75 

map  Rec 
BM74 

lister  File 
BM73 

37 

BM72 

BM71 

BM70 

Figure  1-4-4  Bitmap  Register  Files  0 ~ 7 


1-4-24 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


BM87 

BM86 

Bitr 

BM85 

nap  Rec 
BM84 

ister  File 
BM83 

>8 

BM82 

BM81 

BM80 

BM97 

BM96 

Bitr 

BM95 

nap  Rec 
BM94 

ister  File 
BM93 

39 

BM92 

BM91 

BM90 

BMA7 

BMA6 

Bitr 

BMA5 

nap  Rec 
BMA4 

ister  File 
BMA3 

3 A 

BMA2 

BMA1 

BMAO 

BMB7 

BMB6 

Bitr 

BMB5 

nap  Rec 
BMB4 

ister  File 
BMB3 

B 

BMB2 

BMB1 

BMBO 

BMC7 

BMC6 

Bitr 

BMC5 

hap  Reg 
BMC4 

'ister  File 
BMC3 

C 

BMC2 

BMC1 

BMCO 

BMD7 

BMD6 

Bitr 

BMD5 

nap  Rec 
BMD4 

ister  File 
BMD3 

D 

BMD2 

BMD1 

BMDO 

BME7 

BME6 

Bitr 

BME5 

nap  Rec 
BME4 

ister  File 
BME3 

E 

BME2 

BME1 

BMEO 

BMF7 

BMF6 

Bitr 

BMF5 

hap  Rec 
BMF4 

ister  File 
BMF3 

F 

BMF2 

BMF1 

BMFO 

2248H 
2249H 
224AH 
224BH 
224CH 
224DH 
224EH 
224 FH 


Figure  1-4-5  Bitmap  Register  Files  8 ~ FF 
BRFO  ~ BRF7:  Buffer  1 

BRF8  - BRFF:  Buffer  2 


1-4-25 


SNES  DEVELOPMENT  MANUAL 


4.1 .34  ARITHMETIC  CONTROL  (MCNT) 

Access:  SA-1  CPU  Write 

Address:  **2250H 

Size:  8 bits 
Initial  value:  00H 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

0 

0 

0 

0 

0 

0 

ACM 

M/D 

2250H 


Types  of  M/D  and  ACM  arithmetic  operations 


ACM 

M/D 

TYPE  OF  OPERATION 

0 

0 

Multiplication 

0 

1 

Division 

1 

0 

Cumulative  Sum 

NOTE:  Store  a “1”  in  ACM  to  clear  the  result  register  during  cumulative 
sum  operations. 


1-4-26 


SA-1  INTERNAL  REGISTER  CONFIGURATION 

1 

4.1 .35  ARITHMETIC  PARAMETERS:  MULTIPLICAND/DIVIDEND  (MA) 

Access:  SA-1  CPU  Write 

Address:  **2251 H,  **2252H 

Size:  1 6 bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2251 H 
2252 H 


MA7 

Arithme 

MA6 

ic  Parameters:  l\ 
MA5  | MA4 

/lultiplicand/Divic 
MA3  1 MA2 

end  (Lo’ 
MAI 

N) 

MAO 

i 

MAI  5 

^rithmet 

MAM 

ic  Parameters:  Iv 
MAI  3 | MAI  2 

ultiplica 
MA1 1 

id/Divid 

MA10 

end  (His 
MA9 

n) 

MA8 

MA0-MA15:  Multiplicand/Dividend  setting  (signed  16-bit  data) 

The  data  contained  in  MA0-MA15  is  saved  even  after  it  is  acted  upon. 
The  register  does  not  need  to  be  reset,  when  used  for  multiplication. 
When  used  for  division,  however,  the  register  must  be  reset  each  time. 

4.1.36  ARITHMETIC  PARAMETERS:  MULTIPLIER/DIVISOR  (MB) 

Access:  SA-1  CPU  Write 

Address:  **2253H,**2254H 

Size:  1 6 bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2253H 


2254H 


MB7 

Arithmetic  Pai 
MB6  MB5 

'a  meters 
MB4 

: Multiplier/Divisor  (Low) 
MB3  | MB2  | MB1 

MBO 

MB15 

Arithrr 

MB14 

etic  Par 
MB13 

ameters: 

MB12 

Multipli 
MB1 1 

ar/Divisc 

MB10 

r (High) 
MB9 

MB8 

MB0-MB15:  Multiplier/divisor  setting 

• Signed  data  when  used  for  multiplication 

• Unsigned  data  when  used  for  division 

The  arithmetic  operation  is  executed  following  a write  to  register  2254H. 
The  multiplier/divisor  must  be  reset  each  time  an  operation  is  performed. 


1-4-27 


SNES  DEVELOPMENT  MANUAL 


0 


14 


SA-1  INTERNAL  REGISTER  CONFIGURATION 
1 

4.1 .38  VARIABLE-LENGTH  BIT  GAME  PAK  ROM  START  ADDRESS  (VDA) 

Access:  SA-1  CPU  Write 

Address:  **2259H-**225BH 

Size:  24  bits 
Initial  value:  Nonspecific 

D7  D6  D5  D4  D3  D2  D1  DO 

2259H 
225AH 
225BH 

VA0-VA23:  Game  Pak  ROM  variabie-length  bit  area  start  ad- 

dress setting. 

Variable-length  bit  execution  begins  with  a write  to  register  225BH. 


Var 

VA7 

able-Length  Bit 1 
VA6  VA5 

tBame  Pak  ROM 
VA4  1 VA3 

Start  Ac 
VA2 

dress  (Low) 
VA1  1 VAO 

Varia 

VA15 

ble-Lenc 

VA14 

3th  Bit  G 
VA13 

ame  Pa 
VA12 

ROM  S 
VA1 1 

tart  Adc 
VA10 

ress  (Mi 
VA9 

ddle) 

VA8 

Van 

VA23 

able-Ler 

VA22 

lgth  Bit 
VA21 

Same  Pak  ROM 
VA20  | VA19 

Start  Ad 
VA18 

dress  (h 
VA17 

igh) 

VA16 

1-4-29 


SNES  DEVELOPMENT  MANUAL 


4.1.39  SUPER  NES  CPU  FLAG  READ  (SFR) 

Access:  Super  NES  CPU  Read 
Address:  **2300H 

Size:  8 bits 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SA-1 

CPU 

IRQ 

IVSW 

CHDMA 

IRQ 

NVSW 

CMEG3 

CMEG2 

CMEG1 

CMEG0 

2300H 


SA-1  CPU  IRQ:  IRQ  flag  from  SA-1  CPU 

0:  No  IRQ 
1:  IRQ 


IVSW:  Super  NES  CPU  IRQ  vector  setting 

0:  Game  pak  ROM  data 
1 :SIV  register  data 

CHDMA  IRQ:  Character  conversion  DMA  IRQ  flag 

0:  No  IRQ 

1:  IRQ  (character  conversion  1 stand-by) 

NVSW:  Super  NES  CPU  NMI  vector  setting 

0:  Game  pak  ROM  data 
1 : SNV  register  data 


CMEG0-CMEG3:  Message  port  from  SA-1  CPU:  0-15 

NOTE:  Reading  this  register  does  not  clear  its  contents. 


1-4-30 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1.40  SA-1  CPU  FLAG  READ  (CFR) 

Access:  SA-1  CPU  Read 
Address:  **2301 H 

Size:  8 bits 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

SNES 

CPU 

IRQ 

Timer 

IRQ 

DMA 

IRQ 

SNES 

CPU 

NMI 

SMEG3 

SMEG2 

SMEG1 

SMEGO 

2301 H 


Super  NES 
CPU  IRQ: 

IRQ  flag  from  Super  NES  CPU 
0:  No  IRQ 
1:  IRQ 

Timer  IRQ: 

IRQ  flag  from  timer. 
0:  No  IRQ 
1:  IRQ 

DMA  IRQ: 

IRQ  flag  at  the  end  of  DMA 
0:  No  IRQ 

1:  IRQ  (end  of  DMA) 

Super  NES 
CPU  NMI: 

NMI  flag  from  Super  NES  CPU 
0:  No  NMI 
1:  NMI 

SMEG0-SMEG3:  Message  port  from  Super  NES  CPU:  0~15 

NOTE:  Reading  this  register  does  not  clear  its  contents. 


1-4-31 


SNES  DEVELOPMENT  MANUAL 


4.1 .41  H-COUNT  READ  (HCR) 

Access:  SA-1  CPU  Read 
Address:  **2302H,  “2303H 

Size:  16  bits 

D7  D6  D5  D4  D3  D2  D1  DO 

2302H 
2303H 


H7 

H6 

Timer  H-Count  Read 
H5  H4  H3 

'Low) 

H2 

HI 

HO 

Timer 

H-Cour 

t Read i 

High) 

H8 

H0-H8: 

HV  timer:H-count  (dots, 0-340)  read 
Linear  timer:  Lower  9-bit  count  (0-511)  read 

All  HV  counter  values  are  latched  when  register  2302H  is  read. 

4.1 .42  V-COUNT  READ  (VCR) 

Access:  SA-1  CPU  Read 
Address:  **2304H,  **2305H 

Size:  16  bits 

D7  D6  D5  D4  D3  D2  D1  DO 


2304H 


2305 H 


V7 

V6 

Time 

V5 

r V-Count  Read 
V4  V3 

Low) 

V2 

VI 

VO 

Timer 

V-Cour 

t Read  < 

High) 

V8 

V0-V8: 

HV  timer:V-count  (lines)  read 
NTSC,  0-261 
PAL,  0-31 1 

Linear  timer:  Upper  9-bit  counter  value  (0-51 1 ) 
read 


1-4-32 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1 .43  ARITHMETIC  RESULT  [PRODUCT/QUOTIENT/ACCUMULATIVE  SUM]  (MR) 

Access:  SA-1  CPU  Read 
Address:  **2306H  ~ **230AH 

Size:  40  bits 

D7  D6  D5  D4  D3  D2  D1  DO 


2306H 


2307H 


2308H 


2309H 


230AH 


D0-D39:  Arithmetic  result 

Multiplication:  16  (S)  x 16  (S)  = 32  (S)...D0-D31 
Division:  16  (S)  16  (U)  = 16  (S)  ...D0-D15 

Remainder:  16  (U) 

...D16-D31 

Cumulative  Sum:  £(16  (S)  x 16  (S))  = 40  (S) 
...D0-D39 


Reac 

D7 

Arithmetic  Result  (product/quotient/cumulative  sum)  WO 
D6  D5  1 D4  D3  D2  D1  1 DO 

Reac 

D15 

Arithm< 

D14 

Stic  Rest 
D13 

jit  (prodi 
D12 

jct/quoti 

Dll 

snt/cumi 

DIO 

jlative  si 
D9 

jm)  W1 
D8 

Read 

D23 

Arithme1 

D22 

ic  Resu 
D21 

(produi 

D20 

;t/remair 

D19 

lder/curr 

D18 

lulative  i 
D17 

>um) 

D16 

Read  - 
D31 

Arithmet 

D30 

ic  Resul 
D29 

: (produc 
D28 

:t/remair 

D27 

ider/curr 

D26 

lulative  s 
D25 

;um)  W; 
D24 

D39 

Read 

D38 

Arithme 

D37 

tic  Resu 
D36 

(cumu 

D35 

ative  su 
D34 

m)  W4 
D33 

D32 

1-4-33 


SNES  DEVELOPMENT  MANUAL 

I 


] 

4.1 .44  ARITHMETIC  OVERFLOW  FLAG  (OF) 

Access:  SA-1  CPU  Read 
Address:  **230BH 

Size:  8 bits 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

OF 

230BH 


OF:  Overflow  flag 

1 : Overflow 
0:  No  overflow 

4.1 .45  VARIABLE-LENGTH  DATA  READ  PORT  (VDP) 

Access:  SA-1  CPU  Read 
Address:  **230CH,  “230DH 

Size:  1 6 bits 

D7  D6  D5  D4  D3  D2  D1  DO 


230CH 


230 DH 


VD7 

Variable-Length  Dg 
VD6  VD5  VD4 

ta  Read 
VD3 

Port  (Lc 
VD2 

>w) 

VD1 

VDO 

VD15 

Va 

VD14 

riable-Le 

VD13 

ngth  Da 
VD12 

ta  Read 
VD1 1 

Port  (Hii 
VD10 

Jh) 

VD9 

VD8 

VD0-VD15:  The  16-bit  data  resulting  from  barrel-shifting  the  val- 

ues stored  in  the  VBD  register  (**2258H). 


1-4-34 


SA-1  INTERNAL  REGISTER  CONFIGURATION 


4.1.46  VERSION  CODE  REGISTER  (VC) 

Access:  Super  NES  CPU  Read 
Address:  **230EH 

Size:  8 bits 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

VC7 

VC6 

VC5 

VC4 

VC3 

VC2 

VC1 

VCO 

230EH 


VCO  ~ VC7: 


SA-1  Device  Version 


SNES  DEVELOPMENT  MANUAL 


Chapter  5 Multi-Processor  Processing 

5.1  MULTI-PROCESSOR  SYSTEM 

The  Super  Accelerator  System  (SAS)  is  a multi-processor  system  in  which  two 
MPUs  (the  Super  NES  CPU  and  the  SA-1  CPU)  operate  in  parallel.  The  Super 
NES  CPU  performs  as  the  main  processor,  controlling  execution  of  the  SA-1 
CPU.  The  SA-1  CPU  cannot  control  Super  NES  CPU  operations.  This  main/sub 
relationship  is  a hardware  arrangement.  Software  can  be  used  to  manipulate  flags 
and  interrupts  to  use  the  faster  SA-1  CPU  as  the  main  processor. 

5.2  STARTING  AND  STOPPING  THE  SA-1  CPU 

When  power  is  applied  to  the  Super  NES  control  deck  or  its  reset  button  is 
pressed,  the  SA-1  CPU  is  placed  in  its  “stop”  state.  The  Super  NES  CPU  manipu- 
lates SA-1  internal  registers  to  start  and  stop  the  SA-1  CPU  as  directed  by  soft- 
ware. 

5.2.1  STARTING  THE  SA-1  CPU 

The  Super  NES  CPU  sets  the  SA-1  CPU  program  start  address  into  the 
RV  register  (2203H,  2204H)  and  resets  the  SA-1  CPU  RES  bit  of  the 
CCNT  register  (2200H)  to  “0”  to  initiate  SA-1  CPU  processing  from  the 
address  set  in  the  RV  register. 

5.2.2  STOPPING  THE  SA-1  CPU 

When  the  Super  NES  CPU  sets  the  SA-1  CPU  RES  bit  of  the  CCNT  reg- 
ister (2200H)  to  “1”,  the  SA-1  CPU  stops  processing  and  is  placed  in  stop 
status. 


1-5-1 


MULTI-PROCESSOR  PROCESSING 


5.3  MPU  HANDSHAKES 

Because  the  Super  NES  CPU  and  SA-1  CPU  collaborate  in  processing  programs, 
the  SAS  defines  the  following  handshakes  between  the  two  MPUs. 

5.3.1  INTERRUPTS 


The  Super  NES  CPU  and  SA-1  CPU  can  each  transmit  interrupts  such  as 
IRQ  and  NMI  to  each  other,  as  listed  in  the  following  table. 


Interrupt 

type 

Direction 

Register  Set 

IRQ 

S->C 

CCNT  (2200H),  SA-1  CPU  IRQ  bit  = 1 

NMI 

S->C 

CCNT  (2200H),  SA-1  CPU  NMI  bit  = 1 

IRQ 

C ->  S 

SCNT  (2209H),  Super  NES  CPU  IRQ  bit  = 1 

NMI 

C->S 

Not  possible 

Table  1-5-1  Types  of  Interrupts 


An  NMI  interrupt  cannot  be  sent  from  the  SA-1  CPU  to  the  Super  NES 
CPU. 


The  MPU  being  interrupted  identifies  the  source  of  the  interrupt  and 
clears  the  interrupt  when  the  source  is  the  other  MPU. 


Interrupt 

type 

Direction 

Interrupt 

Identification 

Clear  Register 

IRQ 

S->C 

CFR  (2301 H) 

Super  NES  CPU  IRQ 
bit 

CIC  (220BH) 
Super  NES  CPU 
IRQCL  bit=1 

NMI 

S->C 

CFR  (2301 H) 

Super  NES  CPU  NMI 
bit 

CIC  (220BH) 

Super  NES  CPU  NMI 
CL  bit  =1  ; 

IRQ 

C ^ S 

SFR  (2300H) 

SA-1  CPU  IRQ  bit 

SIC  (2202H) 

SA-1  CPU  IRQCL  bit 
= 1 

Table  1-5-2  Interrupt  Identification  and  Clear 


1-5-2 


SNES  DEVELOPMENT  MANUAL 

I' 


5.3.2 


To  temporarily  block  interrupts,  they  can  be  masked  in  an  MPU. 


Interrupt 

Type 

Direction 

Mask  Register 

IRQ 

S->C 

CIE  (220AH),  Super  NES  CPU  IRQEN  bit  = 0 

NMI 

S->C 

CIE  (220AH),  Super  NES  CPU  NMIEN  bit  = 0 

IRQ 

C->S 

SIE  (2202H),  SA-1  CPU  IRQEN  bit  = 0 

Table  1-5-3  Interrupt  Mask 

A masked  interrupt  becomes  active  after  the  mask  is  cancelled.  To  pre- 
vent this  interrupt  when  the  mask  is  cancelled,  the  programmer  may  use 
the  interrupt  identification  registers,  described  in  the  table  on  the  previous 
page,  to  identify  an  interrupt,  then  clear  that  interrupt  before  cancelling 
the  mask. 

MESSAGE 

A four-bit  message  can  be  sent  along  with  an  interrupt  signal  between  the 
MPUs,  as  described  in  the  table  below. 


Interrupt 

Type 

Direction 

Register  Sending 
the  Message 

Register  Receiving 
the  Message 

IRQ 

S -»C 

CCNT  (2200H), 
SMEGO-3 

SFR  (2300H) 
CMEGO-3 

S ->C 

CCNT  (2200H) 
SMEGO-3 

SFR  (2300H) 
CMEGO-3 

IRQ 

C ->  S 

SCNT  (2209H) 
CMEGO-3 

CFR  (2301 H) 
SMEGO-3 

Table  1-5-4  Sending  and  Receiving  a Message 


1-5-3 


MULTI-PROCESSOR  PROCESSING 


5.4  SHARED  MEMORY 

Since  SA-1  l-RAM  can  be  accessed  by  both  MPUs,  a section  of  the  SA-1  l-RAM 
can  be  used  as  a command  exchange  window.  This  window  can  be  used  in  lieu  of 
an  interrupt  to  perform  a handshake  between  the  two  MPUs.  It  also  allows  more 
command  information  to  be  sent  than  is  possible  with  a “message”,  described  pre- 
viously. The  size  of  shared  memory  in  SA-1  l-RAM  can  be  assigned  by  each  pro- 
gram. 

The  SA-1  has  a collision-control  circuit  for  memory  access,  so  that  simultaneous 
read/write  access  by  both  MPUs  does  not  cause  any  problems.  If  simultaneous 
access  does  occur,  the  Super  NES  CPU  has  priority  access  and  the  SA-1  CPU  is 
put  on  hold. 

The  BW-RAM  also  has  an  area  assigned  to  joint  access  and  can  be  used  as 
shared  memory  as  well.  However,  it  is  generally  best  to  use  SA-1  l-RAM  due  to 
the  RAM  access  speed  (operating  speed)  and  because  BW-RAM  cannot  be  used 
during  character  conversion  DMA. 

5.5  VECTOR  SWITCHING 

Parts  of  the  Super  NES  CPU  and  SA-1  CPU  vectors  are  registers  in  the  SAS.  This 
permits  situation  dependant  multiple  routines  to  be  used.  For  example,  interrupt 
processing  can  be  expedited  by  preparing  multiple  IRQ  routines  in  advance  and 
setting  the  IRQ  interrupt  destination  address  in  response  to  game  situations. 

Vectors  which  can  be  specified  in  registers  include  the  following. 


Vector  Type 

Destination  Setting 

Valid/Invalid  Selection  Bits 

Super  NES  CPU 
NMI 

SNV  (220CH,  220DH) 

SCNT  Super  NES  CPU 
NVSW  bit 

Super  NES  CPU 
IRQ 

SIV  (220EH,  220FH) 

SCNT  Super  NES  CPU 
IVSW  bit 

SA-1  CPU  reset 

CRV  (2203H,  2204H) 

Always  valid 

SA-1  CPU  NMI 

CNV  (2205H,  2206H) 

Always  valid 

SA-1  CPU  IRQ 

CIV  (2207H,  2208H) 

Always  valid 

Table  1-5-5  Situation  Dependant  Vectors 

When  the  Super  NES  CPU  register  setting  vector  is  set  to  invalid,  the  program 
jumps  to  the  address  indicated  in  ROM. 


1-5-4 


SNES  DEVELOPMENT  MANUAL 


5.6  SA-1  CPU  CORE 


The  SA-1  core  CPU  is  the  same  16-bit  CPU  (65C816)  used  in  the  Super  NES 
CPU  and  can  execute  all  the  Super  NES  instructions.  The  differences  between 
the  SA-1  CPU  and  Super  NES  CPU  cores  are  as  follows: 


5.6.1 


VECTORS 


The  reset,  NMI,  IRQ  and  other  vectors  registered  in  the  M-ROM  are  for 
the  Super  NES  CPU.  The  SA-1  CPU  vectors  must  be  set  separately.  The 
SA-1  CPU  vectors  should  be  set  in  the  following  registers  using  the  Su- 
per NES  CPU. 


Reset  vector: 
NMI  vector: 
IRQ  vector: 
Other  vectors: 


RV  (2203H,  2204H) 

CNV  (2205H,  2206H) 

CIV  (2207H,  2208H) 

Same  as  the  Super  NES  CPU  (M-ROM 
data) 


5.6.2  SA-1  CPU  WAIT 

The  SA-1  CPU  operates  at  10.74  MHz,  but  a wait  cycle  may  be  intro- 
duced when  some  commands  and  functions  are  executed,  or  when  it  is 
accessed  by  the  Super  NES  CPU.  This  happens  when: 

1 . the  following  instructions  are  executed: 

RTS,  RTI,  RTL,  JMP  (a),  JML  (a),  JMP  a,  JMP  al,  JMP  (a,x),  JSR 
(a,x),  JSR  a,  JSL  al,  BRA  cop 

2.  the  destination  address  of  the  following  commands  is  odd: 

BPL,  BMI,  BVC,  BVS,  BRA,  BCC,  BCS,  BNE,  BEQ,  BRL 

3.  data  is  read  from  Game  Pak  ROM  or  BW-RAM. 

4.  the  SA-1  CPU,  Super  NES  CPU  or  the  Super  NES  CPU’s  DMA  access 
the  same  device  (Game  Pak  ROM,  BW-RAM,  or  SA-1  l-RAM)  simulta- 
neously. 

5.  the  BW-RAM  write  buffer  is  full  when  writing  to  BW-RAM. 

6.  the  source  of  the  SA-1  DMA  transmission  is  Game  Pak  ROM 


1-5-5 


5.7  OPERATION  MODES 


The  SA-1  does  not  have  special  registers  for  setting  the  operation  mode.  The  Su- 
per NES  CPU  is  always  in  program  execution  state  and  controls  the  SA-1  CPU 
operations  (start  and  stop). 

The  remainder  of  this  chapter  introduces  representative  relationships  between  the 
Super  NES  CPU  and  SA-1  CPU  operations.  They  are  examples  and  do  not  repre- 
sent the  entire  SAS  operation  modes. 

5.7.1  ACCELERATOR  MODE 

In  the  accelerator  mode,  the  SA-1  CPU  is  used  only  to  handle  the  high- 
load  part  of  the  program  as  subroutines.  While  the  SA-1  CPU  is  process- 
ing, the  Super  NES  CPU  waits,  in  a loop,  for  the  end  of  this  processing. 
When  the  SA-1  CPU  finishes  processing,  it  informs  the  Super  NES  CPU 
by  an  interrupt,  as  illustrated  below. 


PREVIOUS  OPERATION 
Super  NES 
CPU 


OPERATION  W/SA-1 


Super  NES 
CPU 


SA-1  CPU 


Figure  1-5-1  Accelerator  Mode 


1-5-6 


In  the  accelerator  mode,  the  process  flow  is  like  a single-thread  and  it  is 
easy  to  avoid  programming  errors.  This  mode  is  suitable  for  utilizing  the 
speed  of  SA-1  without  much  complexity.  On  the  other  hand,  it  is  not  very 
efficient  due  to  MPU  stop  and  loop  time. 

5.7.2  PARALLEL  PROCESSING  MODE 

The  parallel  processing  mode  is  a multi-processing  mode  in  which  both 
MPUs  are  operating  simultaneously  and  are  synchronized  by  hand- 
shakes. Both  MPUs  can  freely  access  memory  thanks  to  the  SA-I’s  auto- 
matic collision  control. 

The  handshake  between  MPUs  is  achieved  by  using  interrupt  signals  and 
shared  memory. 

The  SA-1  CPU  can  process  the  program  while  the  Super  NES  CPU  is 
processing  the  multi-use  DMA,  as  demonstrated  below. 


PREVIOUS  OPERATION 
Super  NES 
CPU 


OPERATION  W/SA-1 


Super  NES 
CPU 


SA-1  CPU 


Figure  1-5-2  Parallel  Processing  Mode 


1-5-7 


MULTI-PROCESSOR  PROCESSING 


In  the  parallel  processing  mode  the  highest  processing  efficiency  can  be 
achieved,  as  both  MPUs  operate  without  waiting  for  one  anther.  Howev- 
er, the  process  flow  is  complicated  and  more  care  must  be  taken  to  avoid 
programming  errors,  unsuccessful  handshakes,  and  crashes. 

5.7.3  MIXED  PROCESSING  MODE 

In  the  mixed  processing  mode,  the  SA-1  CPU  can  be  used  as  a Super 
NES  CPU  accelerator  during  parallel  processing  in  the  parallel  process- 
ing mode.  In  the  SA-1 , an  operation  mode  is  nothing  more  than  program 
architecture,  therefore,  this  type  of  processing  is  possible. 


PREVIOUS  OPERATION 
Super  NES 
CPU 


Process 

A 


Process 

B 

' -v 


Process 

C 


■MMM 

■liiai 

Process 


Process 

E 


OPERATION  W/SA-1 
Super  NES 


CPU 


Process 

A 


Part  of 
Process 
C 


Wait 


Continue 

Process 

C 


Process 

E 


IRQ 


SA-1  CPU 


Start 


is  '<  > ' 


Process 

B 

w: 


Part  of 
Process 
C 


Continue 

Process 

B 


Process 

D 


Figure  1-5-3  Mixed  Processing  Mode 


1-5-8 


SNES  DEVELOPMENT  MANUAL 

5.8  OPERATING  MODES  AND  PROCESSING  SPEEDS 

The  operating  speed  of  the  SA-1  CPU  in  each  of  the  SA-1  operating  modes  is  as 
follows. 


SA-1 

Operation 

Mode 

SA-1  CPU 
Operating 
Speed 

Memory 
Used  by  SA- 
1 CPU 

Super  NES 
CPU 

Operations 

Memory 
Used  by 
Super  NES 
CPU 

Accelerator 

10.74MHz 

Game  Pak 
ROM 

SA-1  l-RAM 

Loop 

program 

WRAM 

Parallel 

Processing 

10.74MHz 

Game  Pak 
ROM 

Multi- 

purpose 

DMA 

Other  than 
Game  Pak 
RAM 

10.74MHz 

SA-1  l-RAM 

Multi- 

purpose 

DMA 

Other  than 
SA-1  l-RAM 

5.37MHz 

Game  Pak 
ROM 

Multi- 

purpose 

DMA 

Game  Pak 
ROM 

5.37MHz 

Game  Pak 
ROM 

Normal 

operations 

Game  Pak 
ROM 

10.74MHz 

SA-1  l-RAM 

Normal 

operations 

Game  Pak 
ROM 

10.74MHz 

Game  Pak 
ROM 

SA-1  l-RAM 

Normal 

operations 

WRAM 

Table  1-5-6  Operating  Modes  and  Processing  Speeds 


1-5-9 


CHARACTER  CONVERSION 


Chapter  6 Character  Conversion 

6.1  INTRODUCTION  TO  CHARACTER  CONVERSION 

The  SA-1  contains  a function  for  converting  VRAM  data  stored  in  virtual  bitmap 
format  on  BW-RAM  and  SA-1  l-RAM  to  Super  NES  PPU  character  format  VRAM 
data. 

Rotation,  enlargement,  and  reduction  of  screen  data  and  3-D  displays,  such  as 
polygons,  are  performed  readily  when  the  data  is  stored  in  bitmap  format.  Data 
compression  can  also  be  done  more  efficiently  when  the  data  to  be  compressed  is 
stored  in  bitmap  format. 

6.1.1  BITMAP  FORMAT 

“Bitmap  format”  refers  to  a data  format  where  one  address  is  assigned  to 
each  pixel  (dot)  on  the  screen.  The  SA-1  uses  byte-long  addresses.  The 
effective  data  length  is  2 bits  in  the  4 color  mode  and  4 bits  in  the  16  color 
mode.  The  remaining  bits  in  the  byte  are  ignored. 

The  Super  NES  PPU  is  incapable  of  directly  processing  bitmap  data.  The 
SA-1  includes  a function  which  converts  bitmap  data  to  Super  NES  PPU 
character  formatted  data  using  DMA. 

6.2  CHARACTER  CONVERSION  FUNCTIONS 

The  SA-1  has  two  character  conversion  functions  for  converting  bitmap  data  to 
character  data  (Character  Conversion  1 and  Character  Conversion  2). 

6.2.1  CHARACTER  CONVERSION  1 

Character  Conversion  1 sends  bitmapped  data  contained  on  BW-RAM  to 
the  VRAM  of  the  Super  NES  PPU  and  displays  it  on  the  screen  by  simul- 
taneously performing  the  DMA  function  in  the  SA-1  and  Super  NES  gen- 
eral purpose  DMA,  as  demonstrated  below. 


Super  NES 


LDMAsjpccur  simultaneously. 


Figure  1-6-1  Character  Conversion  1 


SNES  DEVELOPMENT  MANUAL 


Character  conversion  1 uses  the  buffer  area  in  SA-1  l-RAM  to  convert 
and  transmit  data  to  the  VRAM  of  the  Super  NES  PPU.  The  buffer  can  be 
a maximum  of  128  bytes  (256  color  mode)  or  32  bytes  minimum  (4  color 
mode). 

6.2.2  CHARACTER  CONVERSION  2 

Character  conversion  2 is  used  when  the  bitmap  data  is  in  SA-1  l-RAM  or 
game  pak  ROM,  or  when  the  game  pak  is  configured  without  BW-RAM, 


Figure  1-6-2  Character  Conversion  2 


1-6-2 


CHARACTER  CONVERSION 


6.3  BITMAP  ACCESS 

The  bitmap  data  storage  area  (virtual  VRAM)  is  normally  assigned  to  BW-RAM. 
Bitmap  data  is  compressed  (packed)  and  stored  in  BW-RAM  as  illustrated  below. 


4 Color  Mode 
16  Color  Mode 
256  Color  Mode 


4 Pixel/Byte 
2 Pixel/Byte 
1 Pixel/Byte 

| b7  | b6  | b5  | b4  | b3  | b2  | bl  | bO  | 

1 Byte 


1 

Pixel 

1 

1 

Pix 

— 

el 

1 

Pix 

— 

:el 

1 

Pi) 

— 

cel 

1 

1 

Pix 

:el 

Pi) 

cel 

1 1 

1 ! 

Pi) 

1 

(el 

1 1 

Figure  1-6-3  Compressed  Bitmap  Data 

6.3.1  BW-RAM  IMAGE  PROJECTION 

Within  the  SA-1 , the  BW-RAM  image  is  projected  into  6 x H banks  in  the  SA-1 
CPU’s  memory  map.  When  BW-RAM  is  accessed  in  these  6 x H banks,  it  can  be 
accessed  at  one  pixel  per  byte  in  either  the  4 color  or  16  color  modes. 


Figure  1-6-4  Bitmap  Image  Projection 


SNES  DEVELOPMENT  MANUAL 


For  64  Kbit  BW-RAM: 

BW-RAM  Bitmap  (1 6 color)  / Bitmap  (4  color) 

4C):0000H~40: 1 FFFH  =>  60:0000H~60:3FFFH  / 60:0000H~60:7FFFH 

For  256  Kbit  BW-RAM: 

BW-RAM  Bitmap  (1 6 color)  / Bitmap  (4  color) 

40:0000H~40:7FFFH  =>  60:0000H~60:FFFFH  / 60:0000H~61  :FFFFH 

For  2 Mbit  BW-RAM: 

BW-RAM  Bitmap  (1 6 color)  / Bitmap  (4  color) 

40:0000H~43:FFFFH  =>  60:0000H~67:FFFFH/  60:0000H~6F:FFFFH 

In  the  256  color  mode,  the  bitmap  data  is  copied  directly  on  the  BW-RAM  area. 


1-6-4 


6.3.2  BW-RAM  DATA  EXPANSION 


The  compressed  BW-RAM  data  is  expanded  sequentially  and  assigned 
from  address  60:0000H.  This  is  demonstrated  in  the  figure  below.  All  ar- 
eas of  BW-RAM  are  expanded  during  this  operation  and  no  special  regis- 
ter is  provided  for  designating  the  expanded  area.  Therefore,  when  only  a 
partial  area  of  BW-RAM  is  used  for  virtual  VRAM,  the  bitmap  area  corre- 
sponding to  the  area  assigned  as  virtual  VRAM  must  be  accessed. 


Figure  1-6-5  Bitmap  Data  Expansion 

The  color  mode  of  the  bitmap  access  area  is  set  in  bit  SEL42  of  the  BBF 
register  (223FH). 

SEL42  = 0:  16  color  mode 

SEL42  = 1:4  color  mode 


1-6-5 


SNES  DEVELOPMENT  MANUAL 


The  bitmap  area  is  configured  as  follows. 


0) 

o 

-O 


<D 

N 

if) 

o 

tr 

$ 

< 

DC 

> 


VRAM  Horizontal  Size  (n  dots) 


i { 

X 

x+1 

x+2 

x+3 

x+n-1 

x+n 

x+n+1 

x+n+2 

x+2n-1 

x+2n 

x+2n+1 

x+2n+2 

x+2n+3 

x+3n-1 

V 

x+(m-1)n 

x+(m-1)n+1  | 

x+(m-1)n+2 

x+mn-1 

Figure  1-6-6  Memory  Addresses  for  the  Bitmap  Area 

The  variable  “x”  indicates  the  start  address  of  the  bitmap  area  in  virtual 
VRAM.  The  variable  “n”  is  the  horizontal  size  (dots)  of  VRAM  and  “m”  is 
the  vertical  size  (dots)  of  VRAM.  Variable  “n”  can  be  specified  in  bits 
SIZEO-2  of  the  CDMA  register  (2231 H),  as  demonstrated  below.  No  reg- 
ister is  provided  for  specifying  vertical  size  “m”.  Vertical  size  can  be  set 
within  the  limits  of  BW-RAM  size  as  a function  of  internal  program  logic. 
Variable  “m”  is  processed  in  character  units  and  must  be  a multiple  of 
eight. 


SIZEO 

SIZE1 

SIZE2 

Horizontal  Character  Number 

0 

0 

0 

1 (8  dots) 

0 

0 

1 

2 (16  dots) 

0 

1 

0 

4 (32  dots) 

0 

1 

’ 1 

8 (64  dots) 

1 

0 

0 

16  (128  dots) 

1 

0 

1 

32  (256  dots) 

Table  1-6-1  Horizontal  Size  of  VRAM  (CDMA  Register) 


1-6-6 


6.4  CHARACTER  CONVERSION  1 , DETAILED  DESCRIPTION 


Character  conversion  1 is  used  to  convert  the  bitmap  screen  data  in  BW-RAM  to 
Super  NES  PPU  character  formatted  VRAM  data,  with  SA-1  DMA  and  Super  NES 
general  purpose  DMA  working  in  parallel.  A larger  volume  of  data  can  be  convert- 
ed at  one  time  with  character  conversion  1 than  with  character  conversion  2,  due 
to  efficient  usage  of  both  DMAs. 

Character  conversion  1 requires  two  characters  of  memory  space  in  SA-1  l-RAM 
for  use  as  buffers  (work  space).  The  required  l-RAM  size  is  32  bytes  in  the  4 color 
mode,  64  bytes  in  the  16  color  mode,  and  128  bytes  in  the  256  color  mode.  Any  I- 
RAM  address  can  be  specified  by  the  user. 

Character  conversion  1 uses  these  two  buffers  to  read  the  data  from  BW-RAM  to 
VRAM  in  parallel.  Since  the  processing  speed  is  determined  by  the  speed  of  the 
Super  NES  CPU’s  general  purpose  DMA,  the  same  amount  of  characters  can  be 
converted  as  with  the  Super  NES,  alone. 


Figure  1-6-7  Character  Conversion  Buffers 


1-6-7 


SNES  DEVELOPMENT  MANUAL 


6.5  CHARACTER  CONVERSION  1 PROGRAMMING  PROCEDURE 

When  character  conversion  1 is  used,  the  user  must  carefully  coordinate  register 
settings  in  the  Super  NES  CPU  and  SA-1  CPU.  The  following  procedure  is  provid- 
ed to  aid  the  user  in  coordinating  these  settings. 

STEP  1 . Set  DCNT  (2230H)  using  the  SA-1  CPU. 

CDEN  bit  = 1 (character  conversion  enable) 

CDSEL  = 1 (BW-RAM  to  SA-1  l-RAM  transmission) 

NOTE:  The  registers  indicated  in  the  following  steps  are  set  using  the 

Super  NES  CPU. 

STEP  2.  Specify  the  SA-1  DMA  transmission  source  address  using  the  Super 
NES  CPU. 

Store  the  transmission  source  address  (BW-RAM)  in  SDA 
(2232H-2234H). 

A specific  number  of  low  bit  of  the  address  must  be  set  to  “0”, 
as  a function  of  the  color  mode  and  the  number  of  horizontal 
characters  set  in  SIZEO-2  of  CDMA  (2231 H).  The  specific 
number  of  “0”  bits  can  be  determined  from  the  table  below. 


Color  Mode 

4 

4 

4 

4 

4 

4 

16 

16 

16 

16 

16 

16 

256 

256 

256 

256 

256 

256 

Number  of 
Horizontal 
Characters 

1 

2 

4 

8 

16 

32 

1 

2 

4 

8 

16 

32 

1 

2 

4 

8 

16 

32 

Zero  Bits 

4 

5 

6 

7 

8 

9 

5 

6 

7 

8 

9 

10 

6 

7 

8 

9 

10 

11 

Table  1-6-2  Number  of  Zero  Bits  in  BW-RAM 

STEP  3.  Set  CDMA  (2231 H)  using  the  Super  NES  CPU. 

Store  the  color  mode  (4,  1 6,  or256)  in  CBO  and  CB1 . 

Store  the  number  of  virtual  VRAM  horizontal  characters  in 
SIZEO-2. 

STEP  4.  Specify  the  SA-1  l-RAM  address  for  the  buffers  as  the  transmission 
destination. 

Store  the  buffer  address  in  DDA  (2235H  and  2236H). 

NOTE:  It  is  not  necessary  to  set  2237H  because  l-RAM  is  specified. 

The  lowest  5 bits  of  the  l-RAM  address  must  all  be  “0”  for  4 col- 
or mode.  The  lowest  6 bits  of  the  l-RAM  address  must  be  “0” 
for  16  color  mode.  And,  the  lowest  7 bits  of  the  l-RAM  address 
must  be  “0”  for  256  color  mode. 


1-6-8 


CHARACTER  CONVERSION 


STEP  5.  Wait  for  the  IRQ  (CHRIRQ)  generated  from  SA-1  to  the  Super  NES 
CPU. 

The  Super  NES  CPU  waits  for  the  IRQ  and  verifies  that  the 
CHRDMA  IRQ  bit  of  the  SFR  register  (2300H)  = 1 (character 
conversion  1 DMA  standby).  IRQ  is  generated  for  some  other 
reason  when  CHRDMA  IRQ  = 0. 

STEP  6.  Transmit  the  character  data  in  SA-1  l-RAM  to  VRAM. 

Character  data  which  has  been  converted  by  the  Super  NES 
CPU’s  general  purpose  DMA  is  transmitted  to  VRAM.  Set  the 
general  purpose  DMA  source  address  to  the  start  address  of 
the  virtual  VRAM  in  BW-RAM. 

STEP  7.  Use  the  Super  NES  CPU  to  notify  the  SA-1  that  the  conversion  is 
complete. 

Set  bit  CHDEND  of  the  CDMA  register  (2231 H)  to  “1”  to  indi- 
cate that  one  cycle  of  character  conversion  1 has  been  com- 
pleted and  return  control  of  register  access  to  the  SA-1  CPU. 

When  necessary,  use  an  IRQ  or  SA-1  l-RAM  to  notify  the  SA-1  CPU  of  the  end  of 
character  conversion. 

Using  the  above  procedure,  the  SA-1  internal  character  conversion  circuit  con- 
verts characters  in  order  based  upon  the  request  from  the  Super  NES  CPU’s 
DMA. 

The  SA-1  CPU  can  return  to  program  processing  after  STEP  1 has  been  per- 
formed, however,  it  must  wait  during  any  simultaneous  access  to  BW-RAM  or  SA! 
l-RAM  as  DMA  has  priority. 

Although  CDMA,  DDA,  and  SDA  are  SA-1  CPU  registers,  they  are  set  by  the  Su- 
per NES  CPU  when  using  character  conversion  1 . The  user  should  not  access 
BW-RAM  from  the  Super  NES  CPU  during  these  operations.  SA-1  l-RAM  can  be 
accessed  by  the  user  through  the  Super  NES  CPU,  so  flags  can  be  changed  with- 
in the  SA-1  CPU. 


1-6-9 


SNES  DEVELOPMENT  MANUAL 


6.6  CHARACTER  CONVERSION  2,  DETAILED  DESCRIPTION 

Character  conversion  2 performs  character  conversion  by  writing  bitmap  data  to 
the  SA-1  registers  according  to  the  SA-1  CPU’s  program.  Because  the  transmis- 
sion is  controlled  by  the  SA-1  CPU’s  program,  the  memory  for  bitmap  data  expan- 
sion can  be  set  up  more  freely  than  when  using  character  conversion  1 . Also, 
when  the  game  pak  configuration  does  not  include  BW-RAM,  character  conver- 
sion 2 is  the  only  means  of  character  conversion. 

The  bitmap  data  when  using  character  conversion  2 is  one  pixel/byte  (unpacked). 
As  previously  described,  packed  data  cannot  be  converted.  Therefore,  bits  b7  ~ 
b2  of  the  data  are  invalid  in  the  4 color  mode.  Similarly,  b7  ~ b4  are  invalid  in  the 
16  color  mode.  All  bits  are  valid  in  the  256  color  mode. 

The  table  below  shows  the  actual  data  in  memory.  When  the  bitmap  access  func- 
tion is  used  with  character  conversion  1 , one  pixel/byte  access  is  possible. 


Bitmap  Data  Format 

4 Color  Mode 

16  Color  Mode 

Character  Conversion  1 

4 Pixel/Byte 

2 Pixel/Byte 

Character  Conversion  2 

1 Pixel/Byte 

1 Pixel/Byte 

Table  1-6-3  Character  Conversion  and  Data  Format 

Character  conversion  2 also  requires  buffers  for  two  characters  in  SA-1  l-RAM, 
similar  to  character  conversion  1 . The  bitmap  data  written  to  the  SA-1  registers  by 
the  SA-1  CPU  is  converted  as  written  and  generated  as  character  data  in  the  buff- 
er area  in  SA-1  l-RAM.  Character  conversion  is  performed  using  the  two  SA-1 
buffers  alternately.  When  the  conversion  of  data  contained  in  buffer  1 is  complet- 
ed, conversion  begins  on  the  data  contained  in  buffer  2.  When  this  conversion  is 
completed,  new  data  contained  in  buffer  1 is  converted.  The  Super  NES  CPU 
reads  the  data  from  the  buffer  in  the  SA-1  l-RAM  at  the  end  of  each  conversion 
using  its  general  purpose  DMA. 


1-6-10 


CHARACTER  CONVERSION 


6.7  CHARACTER  CONVERSION  2 PROGRAMMING  PROCEDURE 

The  following  procedure  is  provided  to  aid  the  user  in  executing  character  conver- 
sion 2. 

STEP  1 . Set  DCNT  (2230H)  using  the  SA-1  CPU. 

DMAEN  = 1 (DMA  enable) 

CDEN  = 1 (character  conversion  DMA) 

CDSEL  = 0 (SA-1  CPU  to  SA-1  l-RAM  write) 

No  other  bits  need  to  be  set. 

STEP  2.  Store  the  color  mode  in  CDMA  (2231 H)  using  the  SA-1  CPU. 

The  color  mode  is  set  using  bits  CBO  and  CB1  (4,  16,  or  256 
color  modes).  Bits  SIZEO-2  need  not  be  set. 

STEP  3.  Specify  the  SA-1  l-RAM  transmission  destination  address  using  the 
SA-1  CPU. 

Store  the  l-RAM  buffer  address  in  DDA  (2235H  and  2236H). 

The  lowest  5 bits  of  the  l-RAM  address  must  be  set  to  all  zeros 
for  4 color  mode.  The  lowest  6 bits  must  be  zero  for  16  color 
mode.  The  lowest  7 bits  must  be  zero  for  256  color  mode. 

STEP  4.  Write  the  bitmap  data  in  the  conversion  register  using  the  SA-1  CPU. 

The  data  must  be  written  4 times  in  succession  (64  pixels  = 1 
character  of  data)  to  BRF  (2240H-224FH). 

The  4 write  operations  should  be  performed  in  the  following  or- 
der. 

BRFO— »1— >2— »...  F— »0— >1— »...  — >F 

Character  conversion  DMA  will  begin  automatically,  following 
each  8 pixel  write  operation  and  generate  the  characters  in  I- 
RAM. 

STEP  5.  Notify  the  Super  NES  CPU  that  character  conversion  is  complete. 

Notify  the  Super  NES  CPU  using  an  interrupt  or  SA-1  l-RAM 
when  a character  has  been  completed. 

The  Super  NES  CPU  transmits  the  character  data  to  VRAM  or 
WRAM  using  general  purpose  DMA  or  a program. 

STEP  6.  Repeat  STEP  4 and  5 to  continue  character  conversion. 

To  continue  to  convert  characters,  write  64  pixels  in  succes- 
sion. The  character  data  is  created  using  DMA  transmission  in 
the  other  SA-1  l-RAM  buffer. 


1-6-11 


SNES  DEVELOPMENT  MANUAL 


STEP  7.  Indicate  when  character  conversion  is  over. 

Reset  bit  DMAEN  of  the  DCNT  register  (2230H)  to  “0”.  This 
ends  one  cycle  of  character  conversion  2. 

During  these  operations,  other  SA-1  DMA  functions  cannot  be  performed.  The 
Super  NES  general  purpose  DMA  may  be  used  for  other  functions. 


1-6-12 


ARITHMETIC  FUNCTION 


Chapter  7 Arithmetic  Function 

7.1  TYPES  OF  ARITHMETIC  OPERATIONS 

The  SA-1  has  an  arithmetic  circuit  for  high  speed  processing  of  arithmetic  opera- 
tions. This  is  in  addition  to  the  arithmentc  circuit  installed  in  the  Super  NES  PPU. 
The  SA-1  arithmentc  circuit  runs  faster  and  can  run  concurrently  with  the  Super 
NES  CPU.  The  SA-1  arithmetic  circuit  performs  the  following  three  types  of  arith- 
metic functions. 

1.  MULTIPLICATION 

Multiplicand  Multiplier  Result 

16  bits  (S)  X 16  bits  (S)  = 32  bits  (S) 

2.  DIVISION 

Dividend  Divisor  Result 

16  bits  (S)  + 16  bits  (U)  = 16  bits  (S) 

16  bits  (U)  Remainder 

3.  CUMULATIVE  SUM 

Multiplicand  Multiplier  Result 

1(16  bits  (S)  X 16  bits  (S))  = 40  bits  (S) 

Note:  (S)  indicates  signed  data  and  (U)  indicates  unsigned  data. 

The  type  of  arithmetic  operation  is  specified  in  the  arithmetic  operation  control 
register  (**2250H)  using  the  SA-1  CPU.  The  user  should  choose  between  ACM 
(dl)  for  cumulative  sum  operations  and  M/D  (dO)  for  multiplication  or  division  op- 
erations. The  required  number  of  cycles  for  each  operation  are  shown  below. 


Arithmetic 

Operation 

ACM 

M/D 

Number  of  Cycles 

Multiplication 

0 

0 

5 

Division 

0 

1 

5 

Accumulative 

1 

- 

6 

Table  1-7-1  Arithmetic  Operations  Settings  and  Cycles 
The  number  of  cycles  is  calculated  based  upon  10.74  MHz  per  cycle. 


1-7-1 


SNES  DEVELOPMENT  MANUAL 

I 

7.2  MULTIPLICATION 

Multiplication  operations  are  carried  out  as  follows. 

1 . Set  MCNT  (2250H) 

ACM=0,  M/D=0 

2.  Set  the  arithmetic  parameters. 

Store  the  multiplicand  in  MA  (2251 H and  2252H). 

Store  the  multiplier  in  MB  (2253H  and  2254H). 

3.  Read  the  result  after  5 cycles. 

The  arithmetic  result  is  stored  in  W0-W3  of  MR  (2306H-2309H). 

WO  is  the  lowest  byte  and  W3  the  highest. 

The  multiplicand  is  saved  in  memory  following  the  operation,  while  the  multiplier  is 
not. 

7.3  DIVISION 

Division  operations  are  carried  out  as  follows. 

1 . Set  MCNT  (2250H) 

ACM=0,  M/D=1 

2.  Set  the  arithmetic  parameters. 

Store  the  dividend  in  MA  (2251 H and  2252H). 

Store  the  divisor  in  MB  (2253H  and  2254H). 

3.  Read  the  result  after  5 cycles. 

The  arithmetic  result  is  stored  in  WO  and  W1  of  MR  (2306H  and  2307H). 
The  remainder  is  stored  in  W2  and  W3  of  MR  (2306H  and  2307H). 

WO  and  W2  are  the  low  bytes,  while  W1  and  W3  are  the  high  bytes. 

Neither  the  dividend  nor  the  divisor  is  saved  in  memory. 

The  SA-1  does  not  detect  “divide  by  zero”  errors.  The  product  and  remainder  for 
division  by  zero  will  be  “0”.  Special  attention  is  required  to  the  sign  of  the  remain- 
der in  division  when  using  negative  numbers. 


1-7-2 


ARITHMETIC  FUNCTION 


7.4  CUMULATIVE  SUM 

Cumulative  sum  operations  are  carried  out  as  follows. 

1 . Set  MCNT  (2250H) 

ACM=1 

When  the  ACM  bit  is  set  (1)  the  cumulative  result  is  cleared  to  “0”. 

2.  Set  the  arithmetic  parameters. 

Store  the  multiplicand  in  MA  (2251 H and  2252H). 

Store  the  multiplier  in  MB  (2253H  and  2254H). 

3.  Reset  the  parameters  after  6 cycles. 

Repeat  this  step  until  the  operation  is  completed. 

4.  Read  the  cumulative  result. 

The  arithmetic  result  is  stored  in  W0-W3  of  MR  (2306H-2309H). 

WO  is  the  lowest  byte  and  W3  the  highest. 

The  multiplicand  is  saved  in  memory  following  the  operation,  while  the  multiplier  is 
not. 

The  OF  bit  in  the  OF  register  (230BH)  is  set  to  “1”  when  the  cumulative  result  ex- 
ceeds 40  bits. 


1-7-3 


SNES  DEVELOPMENT  MANUAL 


Chapter  8 Variable-Length  Bit  Processing 

8.1  READING  VARIABLE-LENGTH  DATA 

The  SA-1  variable-length  bit  processing  function  consists  of  a barrel  shift  circuit 
which  treats  the  entire  game  pak  ROM  as  a stream  (string)  of  bits  which  are  se- 
quentially read  in  1 ~ 16  bit  lengths.  This  allows  the  SA-1  to  process  data  of  vari- 
able lengths  without  having  to  shift  the  data  to  byte  boundaries,  resulting  in  higher 
processing  speed. 

The  SA-1  variable-length  bit  processing  function  consists  only  of  a barrel  shift 
function.  The  function  supports,  but  does  not  perform  data  compression  or  expan- 
sion. These  processes  must  be  performed  as  a part  of  each  program. 

The  function  is  configured  in  this  way  to  allow  the  programmer  to  select  the  best 
compression  algorithm  for  each  piece  of  software,  in  order  to  achieve  the  optimal 
processing  speed-compression  rate  combination. 

The  SA-1  variable-length  bit  processing  function  includes  two  data  read  modes, 
the  Fixed  Mode  and  the  Auto-increment  Mode. 

The  data  read  mode  is  specified  in  the  HL  bit  of  the  VBD  register  (2258H). 

HL=0:  Fixed  Mode 

HL=1 : Auto-increment  Mode 


1-8-1 


8.2  FIXED  MODE 


VARIABLE-LENGTH  BIT  PROCESSING 

1 


In  the  Fixed  Mode,  the  data  stored  in  the  variable-length  data  port  will  be  read 
over  and  over  until  the  number  of  bits  to  be  barrel  shifted  is  reached.  The  shift  is 
carried  out  when  the  amount  of  the  shift  is  written  to  the  VBD  register  (2258H). 
The  Fixed  Mode  is  used  to  read  data  which  is  formatted  so  that  the  valid  bit  length 
is  known  only  after  the  data  is  read.  Variable-length  data  is  processed  as  follows 
in  the  Fixed  Mode. 


Figure  1-8-1  Fixed  Mode  Process  Flow  Diagram 


1-8-2 


SNES  DEVELOPMENT  MANUAL 


□ 


8.3  AUTO-INCREMENT  MODE 

In  the  Auto-increment  Mode,  the  amount  of  the  barrel  shift  is  specified  in  advance. 
Data  is  shifted  automatically  following  the  data  read  and  the  next  data  is  placed 
on  standby. 

The  Auto-increment  Mode  is  used  when  the  valid  bit  length  of  data  is  known  in  ad- 
vance or  when  data  of  the  same  length  is  to  be  repeated.  Variable-length  data  is 
processed  as  follows  in  the  Auto-increment  Mode. 


Figure  1-8-2  Auto-increment  Mode  Process  Flow  Diagram 


1-8-3 


VARIABLE-LENGTH  BIT  PROCESSING 


8.4  VARIABLE-LENGTH  DATA  PROCESSING  SETTINGS 

Specify  the  number  of  bits  to  be  shifted  and  parameters  for  the  SA-1  variable- 
length  data  read  in  the  following  registers. 

STEP  1 . Set  variable-length  data  start  address. 

Store  the  start  address  of  the  variable-length  bit  stream  in  the 
VDA  register  (2259H-225BH). 

STEP  2.  Perform  variable-length  data  read. 

Read  variable-length  data  from  the  VDP  register  (230CH  and 
230DH). 

An  LSB-justified  1 6 bit  block  of  data  is  read  from  the  start  of  the 
remaining  bit  stream. 

STEP  3.  Set  the  amount  of  the  barrel  shift. 

Store  the  amount  of  the  barrel  shift  in  bits  VB0-VB3  of  the  VBD 
register  (2258H). 


VB3 

VB2 

VB1 

VBO 

Significant  Bit  Length 

0 

0 

0 

0 

16 

0 

0 

0 

1 

1 

0 

0 

1 

0 

2 

0 

0 

1 

1 

3 

0 

1 

0 

0 

4 

0 

1 

0 

1 

5 

0 

1 

1 

0 

6 

0 

1 

1 

1 

7 

1 

0 

0 

0 

8 

1 

0 

0 

1 

9 

1 

0 

1 

0 

10 

1 

0 

1 

1 

11 

1 

1 

0 

0 

12 

1 

1 

0 

1 

13 

1 

1 

1 

0 

14 

1 

1 

1 

1 

15 

Table  1-8-1  Amount  of  Barrel  Shift 


1-8-4 


SNES  DEVELOPMENT  MANUAL 


The  barrel  shift  is  carried  out  from  MSB  to  LSB  and  the  next  data  is  read  into  the 
vacant  MSB.  This  flow  is  demonstrated  in  the  following  illustration. 


MSB 


LSB 


Read  data  from 
the  VDP. 


I 

ie 

t 


Set  the  VBD 
to  4. 


Read  data  from 
the  VDP. 


Figure  1-8-3  Barrel  Shift  Process 

When  specifying  the  amount  of  barrel  shift,  the  number  of  bits  from  the  word 
boundary  is  specified.  For  example,  when  2-bit  blocks  of  data  are  used; 

set  VB3-0  to  0010  (2)  for  the  first  shift, 

set  VB3-0  to  0100  (4)  for  the  second  shift,  and 

set  VB3-0  to  01 1 0 (6)  for  the  third  shift. 

Note  that  the  data  set  in  the  VB  bits  is  not  the  number  of  bits  to  be  discarded,  but 
rather  the  number  of  unnecessary  bits  counting  from  the  word  boundary. 


1-8-5 


DMA 


Chapter  9 DMA 

9.1  TYPES  OF  DMA 

The  SA-1  internal  DMA  function  transfers  data  between  game  pak  ROM,  BW- 
RAM,  and  SA-1  l-RAM.  SA-1  internal  DMA  can  be  operated  independent  of  the 
Super  NES  CPU’s  general  purpose  DMA  and  H-DMA.  Even  when  both  DMAs  ac- 
cess the  same  memory  at  the  same  time,  no  problems  arise  because  memory  ac- 
cess is  exclusive. 

SA-1  internal  DMA  has  two  basic  operation  modes.  The  Normal  DMA  Mode  is 
used  to  transfer  data  between  memories,  while  the  Character  Conversion  DMA 
Mode  is  used  to  transmit  data  while  converting  from  bitmap  format  to  character 
format.  This  chapter  describes  the  Normal  DMA  Mode.  Refer  to  the  previous 
chapter,  “Character  Conversion”,  for  details  concerning  the  Character  Conversion 
DMA  Mode. 


Figure  1-9-1  Normal  DMA 


SA-1  CPU 


Instruction 


BW-RAM 


DMA 


CHR 

DMA  ... 

Conversion 

Character 

Conversion 

CHR 

General  ^ 

SA-1  l-RAM 


Character 

Conversion 


Conversion 


iff™  -[SATFRAj 
DMA  (Super  NES  CPU) 


Figure  1-9-2  Character  Conversion  DMA 


1-9-1 


SNES  DEVELOPMENT  MANUAL 


9.2  NORMAL  DMA  OPERATION 

All  Normal  DMA  is  started  from  the  SA-1  CPU.  The  DMA-related  registers 
(2230H-2239H)  are  used  to  start  DMA,  as  described  in  the  following  procedure. 

STEP  1 . Set  the  DCNT  register  (**2230H). 

Store  the  transmission  source  device  in  bits  SDO  and  SD1 . 
Store  the  transmission  destination  device  in  bit  DD. 

NOTE:  The  same  device  cannot  be  used  for  source  and  destination. 

Spurge  Device  Destination  Device 


Store  the  transmission  mode  in  bit  CDEN. 

CDEN=0:  Normal  DMA 

CDEN=1:  Character  Conversion  DMA 

Set  DPRIO  (d6)  to  assign  priority  between  SA-1  CPU  and 
DMA. 

DPrio=0:  SA-1  CPU  priority  (Instructions  can  be  exe- 

cuted during  transmission) 

DPrio=1 : DMA  priority  (SA-1  CPU  waits  during  DMA) 

NOTE:  The  DPrio  setting  is  only  valid  during  Normal  DMA  between  BW- 

RAM  and  SA-1  l-RAM. 

Set  DMAEN  to  enable  or  disable  DMA. 

DMAEN=0:  DMA  disable  (DMA  is  not  used) 

DMAEN=1 : DMA  enable  (Use  DMA,  clear  parameters) 

When  setting  the  DMA  parameters,  first  set  DMAEN=1  from 
the  SA-1  CPU  and  then  set  the  other  parameters.  Set 
DMAEN=0  after  the  DMA  has  been  completed. 


DD 

Device 

0 

SA-1  l-RAM 

1 

BW-RAM 

SD1 

SDO 

Device 

0 

0 

Game  Pak  ROM 

0 

1 

BW-RAM 

1 

0 

SA-1  l-RAM 

1-9-2 


DMA 


[ 


STEP  2.  Specify  the  start  address  of  the  transmission  source. 

Store  the  transmission  source  start  address  in  the  SDA  register 
(2232H-2234H).  The  bit  length  varies  according  to  the  source 
device. 


Source 

Device 

Bit  Number  Setting 

Register 

Game  Pak 
ROM 

24  bits 

**2232H,  2233H,  2234H 

BW-RAM 

18  bits 

**2232H,  2233H,  2234H 

SA-1  l-RAM 

11  bits 

**2232H,  2233H 

Table  1-9-1  Source  Device  Settings 

When  transmitting  from  game  pak  ROM,  start  from  the  even 
address.  When  transmitting  from  BW-RAM,  transmit  from  bank 
40H-43H.  No  transmissions  can  be  sent  from  a bitmap  access 
area. 

STEP  3.  Set  the  number  of  bytes  for  transmission. 

Store  the  number  of  bytes  for  transmission  in  the  DTC  register 
(2238H  and  2239H).  The  value  set  in  DTC  is  transferred  to  the 
internal  counter  in  the  DMA  circuit  (terminal  counter).  The  DTC 
range  is  from  1 -65535  bytes. 

STEP  4.  Specify  the  transmission  destination  start  address. 

Store  the  transmission  destination  start  address  in  the  DDA 
register  (2235H-2237H).  The  bit  length  varies  according  to  the 
destination  device. 


Destination 

Device 

Bit  Number 
Setting 

Register 

Start 

Trigger 

**2235H,  2236H,  2237H 

**2237H 

SA-1  l-RAM 

11  bits 

**2235H,  2236H 

**2236H 

Table  1-9-2  Destination  Device  Settings 

When  transferring  data  to  BW-RAM,  send  the  data  to  banks 
40H-43H.  Data  cannot  be  sent  to  the  bitmap  access  area.  The 
DMA  circuit  begins  the  transmission  after  the  trigger  address 
has  been  written. 


1-9-3 


SNES  DEVELOPMENT  MANUAL 


3 


Normal  DMA  transmission  ends  when  the  internal  terminal  counter  reaches  0.  Af- 
ter normal  DMA  ends,  an  IRQ  is  generated  from  the  DMA  circuit  to  the  SA-1  CPU 
to  set  the  DMAIRQ  flag  in  the  CFR  register  (2301 H)  to  “1”. 

9.3  DMA  TRANSMISSION  SPEED 

The  transmission  speeds  for  Normal  DMA  are  as  follows.: 


Type  of  DMA 

Frequency 

Game  Pak  ROM  to  SA-1  l-RAM 

10.74  MHz 

Game  Pak  ROM  to  BW-RAM 

5.37  MHz 

BW-RAM  to  SA-1  l-RAM 

5.37  MHz 

SA-1  l-RAM  to  BW-RAM 

5.37  MHz 

Table  1-9-3  DMA  Transmission  Speed 

When  the  Super  NES  CPU’s  general  purpose  DMA  or  H-DMA  generates  an  ac- 
cess during  the  SA-Ts  internal  DMA  transmission,  the  SA-1  internal  DMA  is  put  in 
the  “wait”  state.  Hence,  the  Super  NES  CPU’s  DMA  has  priority. 


1-9-4 


INTRODUCTION  TO  SUPER  FX 


Chapter  1 Introduction  to  Super  FX™ 

The  Super  FX  is  a Graphic  Support  processing  Unit  (GSU)  designed  to  greatly  improve 
the  Super  NES  graphics  and  mathematical  functions  through  the  use  of  the  following 
special  features. 

1.1  FEATURES 

1 .1 .1  RISC-LIKE  INSTRUCTIONS 

Instructions  which  are  utilized  often  consist  of  only  one  byte  and  are  exe- 
cuted in  one  cycle  in  an  instruction  cache. 

1 .1 .2  HIGH  SPEED  CLOCK  OPERATION 

The  current  version  of  the  Super  FX  operates  at  a clock  speed  of 
10.74MHz.  This  is  six  times  as  fast  as  the  Super  NES  CPU. 

1 .1 .3  BUILT-IN  INSTRUCTION  CACHE 

A 512-byte  cache  RAM  is  installed  in  order  to  perform  the  instructions  at 
high  speed.  (Refer  to  “Cache  RAM”.) 

1.1.4  SUPER  NES  CPU’S  MEMORY  MAY  BE  USED 

The  Super  FX  uses  game  pak  ROM  and  RAM  which  is  currently  used  by 
the  Super  NES  CPU.  (Refer  to  “Memory  Mapping”.) 

1 .1 .5  INDEPENDENT  ROM  AND  RAM  BUSES 

The  Super  FX  can  access  game  pak  ROM  and  RAM  in  parallel.  Program 
processing  speed  is  maximized,  as  buffers  are  provided  to  read  from 
ROM  and  write  to  RAM.  (Refer  to  “Program  Execution”.) 

1 .1 .6  PARALLEL  OPERATIONS  WITH  SUPER  NES  CPU 

The  Super  NES  CPU  and  Super  FX  may  execute  processing  in  parallel. 
Thus,  high  speed  operations  can  be  performed. 

1.1.7  GRAPHICS  FUNCTION 

A fast  plot  process  can  be  performed  by  specifying  a coordinate  corre- 
sponding with  the  Super  NES  PPU  format.  (Refer  to  “Bitmap  Emulation”, 
under  “Super  FX  Special  Functions”.) 

1.1.8  PIPELINE  PROCESSING 

Pipeline  processing  reduces  the  number  of  processing  cycles  and  en- 
ables high  speed  operation.  (Refer  to  “Pipeline  Processing”,  under  “In- 
struction Set  General  Description”.) 


SNES  DEVELOPMENT  MANUAL 


1 .2  SPECIAL  CONVENTIONS 

Unless  otherwise  specified,  addresses  will  be  written  with  a 2 digit  hexadecimal 
bank  number  and  a 4 digit  hexadecimal  address  separated  by  a colon  (:).  The  fol- 
lowing example  demonstrates  this  convention. 

3F:0000H 

In  this  example  “3F”  represents  the  bank  number,  while  “0000”  represents  the 
hexadecimal  address. 


2-1-2 


1.3  SYSTEM  CONFIGURATION 


The  GSU  is  installed  on  each  game  pak  with  ROM  and  RAM  as  demonstrated  be- 
low. The  Super  NES  CPU  and  the  GSU  share  game  pak  ROM  and  RAM.  Addi- 
tional ROM  for  the  Super  NES  CPU  and  back-up  RAM  may  also  be  installed. 


Figure  2-1-1  Super  FX  System  Configuration 


2-1-3 


SNES  DEVELOPMENT  MANUAL 

r 


1.4  SYSTEM  OPERATION 

Although  the  Super  NES  CPU  and  GSU  share  game  pak  ROM  and  RAM,  the  pro- 
cessors can  not  access  either  simultaneously.  The  GSU  has  a flag,  controlled  by 
the  Super  NES  CPU  program,  which  determines  whether  the  CPU  or  GSU  have 
access  to  game  pak  ROM  and/or  RAM.  This  is  demonstrated  in  the  following  fig- 
ure. 


Figure  2-1-2  Game  Pak  ROM/RAM  Bus  Diagram 

When  using  the  GSU,  the  program  must  be  written  and  executed  with  these 
points  in  mind.  The  following  example  demonstrates  recommended  usage  of  the 
GSU. 

1.5  EXAMPLE  OF  USAGE 

1.5.1  RESET  SUPER  NES 

When  the  Super  NES  is  reset,  the  GSU  is  also  reset.  In  this  condition  the 
game  pak  ROM  and  RAM  busses  are  connected  to  the  Super  NES  CPU. 
The  program  stored  in  game  pak  ROM  is  processed  by  the  Super  NES 
CPU.  The  GSU  is  idle  during  this  period. 


2-1-4 


INTRODUCTION  TO  SUPER  FX 


3 


1.5.2  WRAM 

The  Super  NES  CPU  is  used  to  move  the  program  from  game  pak  ROM 
to  the  work  RAM  (WRAM)  mounted  within  the  Super  NES  Control  Deck. 
The  Super  NES  CPU  may  then  be  operated  by  this  WRAM  program. 

1 .5.3  ACTIVATION  OF  GSU 

The  GSU  flag  is  set  by  the  Super  NES  CPU.  This  allows  the  GSU  to  pro- 
cess instructions  stored  in  game  pak  ROM  and  store  results  in  game  pak 
RAM. 

1 .5.4  GSU  STOP  COMMAND 

When  the  GSU  completes  the  desired  processing,  a stop  command  is  ex- 
ecuted. The  GSU  stops  processing  and  generates  an  interrupt  to  the  Su- 
per NES  CPU.  This  notifies  the  Super  NES  CPU  that  the  GSU  has 
completed  its  processing. 

1.5.5  GSU  DISCONNECT 

When  the  GSU  stops,  game  pak  ROM  and  RAM  busses  are  again  con- 
nected to  the  Super  NES  CPU.  This  permits  the  Super  NES  CPU  to  pro- 
cess the  results  of  the  GSU’s  computations. 

1.5.6  EXAMPLE  SUMMARY 

This  process  may  have  been  used,  for  example,  to  produce  game  video 
data.  These  programming  steps  are  then  repeated,  as  necessary,  to  ac- 
complish the  programmer’s  desired  result. 

1.5.7  CURRENT  CONSUMPTION 

A game  pak  which  contains  the  Super  FX  is  required  to  have  a built-in 
safety  program  to  prevent  it  from  operating  in  excess  of  the  maximum 
current  rating  of  the  AC  Adapter.  For  example,  a game  pak  which  con- 
tains the  Super  FX  can  not  be  used  with  Multi  Player  5 because  this 
would  exceed  the  maximum  current  rating.  A program  must  be  included 
within  the  game  pak  which  will  check  accessory  IDs  and  activate  the  Su- 
per FX  only  if  an  acceptable  accessory  is  connected.  If  an  accessory  ID 
other  than  those  acceptable  is  detected,  a warning  message  must  be  dis- 
played and  the  Super  FX  must  halt. 

Some  accessories  may  be  used,  depending  upon  the  size  of  ROM  and 
RAM  included  in  the  game  pak  and  the  Super  FX  operating  frequency. 
The  user  should  contact  Nintendo’s  Licensee  Support  Group  for  assis- 
tance, in  advance,  if  use  of  an  accessory  other  than  the  standard  control- 
ler is  desired. 


2-1-5 


SNES  DEVELOPMENT  MANUAL 


Chapter  2 GSU  FUNCTIONAL  OPERATION 

2.1  GSU  FUNCTIONAL  BLOCK  DIAGRAM 

The  GSU  is  comprised  of  the  following  6 functional  blocks.  These  are  demonstrat- 
ed in  the  figure  below. 


Figure  2-2-1  GSU  Functional  Block  Diagram 


2-2-1 


GSU  FUNCTIONAL  OPERATION 


2.1 .1  SUPER  NES  CPU  INTERFACE 

The  Super  NES  CPU  Interface  performs  the  following  functions: 

1 . Controls  data  transfer  between  the  Super  NES  CPU,  game 
pak  ROM/RAM,  and  the  general  registers. 

2.  Controls  instruction  data  transfer  between  Super  NES  CPU 
and  the  cache. 

3.  Controls  activation  of  GSU. 

4.  Controls  interrupt  to  Super  NES  CPU. 

2.1.2  INSTRUCTION  CONTROLLER 

This  controls  fetch  instructions,  decode  instructions,  and  various  other 
blocks  based  upon  these  instructions;  loaded  from  game  pak  ROM, 
game  pak  RAM,  or  the  cache. 

Note:  Pipeline  and  cache  circuits  enable  high  speed  execution  of  instruc- 
tions. 

2.1 .3  GAME  PAK  ROM  CONTROLLER 

The  game  pak  ROM  controller  performs  the  following  functions: 

1 . Controls  data  transfer  between  the  Super  NES  CPU  and 
game  pak  ROM. 

2.  Loads  instructions  from  game  pak  ROM  to  the  GSU. 

3.  Transfers  data  from  the  game  pak  ROM  to  the  GSU  internal 
registers. 

Note:  Data  transfer  from  the  game  pak  ROM  to  the  GSU  is  accom- 
plished using  a ROM  buffering  system.  This  enables  instructions 
from  the  game  pak  RAM  and  cache  to  be  executed  and  operated 
in  an  array. 

2.1 .4  GAME  PAK  RAM  CONTROLLER 

The  game  pak  RAM  controller  functions  as  follows: 

1 . Controls  data  transfer  between  the  Super  NES  CPU  and 
game  pak  RAM. 

2.  Loads  instructions  from  game  pak  RAM  to  the  GSU. 

3.  Transfers  data  between  game  pak  RAM  and  GSU  internal 
registers. 

4.  Bitmap  emulation. 

Note:  Data  transfer  from  the  game  pak  RAM  to  the  GSU  is  accomplished 
using  a RAM  buffering  system.  This  enables  instructions  from  the 
game  pak  ROM  and  cache  to  be  executed  and  operated  in  an  ar- 
ray. 


2-2-2 


SNES  DEVELOPMENT  MANUAL 


2.1.5  GENERAL  REGISTERS 

These  registers  are  used  for  general  operations  and  data  transfer. 

Note:  The  GSU  is  equipped  with  sixteen,  16-bit  registers.  All  GSU  opera- 
tions are  performed  using  the  general  registers. 

2.1.6  OPERATOR 

The  Operator  executes  1 6-bit  arithmetic  operations  and  logical  opera- 
tions. 

2.2  REGISTERS 

A list  of  GSU  internal  registers  is  provided  in  the  table  below. 


FUNCTIONAL  GROUP 

REGISTER  NAME 

General  Registers 
Group 

General  Register  RO  ~ R13 

ROM  Address  Pointer  R14 

Program  Counter  R15 

Status/Flag  Register  SFR 

Registers  Related  to 
Memory  Operations 

Program  Bank  Register  PBR 
Game  Pak  ROM 

Bank  Register  ROMBR 

Game  Pak  RAM 

Bank  Register  RAMBR 

Cache  Base  Register  CBR 

Plot  Related  Registers 

Screen  Base  Register  SCBR 

Screen  Mode  Register  SCMR 

Color  Register  COLR 

Plot  Option  Register  POR 

Other  Registers 

Back-up  RAM  Register  BRAMR 
Version  Code  Register  VCR 
CONFIG  Register  CFGR 

Clock  Select  Register  CLSR 

Table  2-2-1  Registers  Listed  by  Functional  Group 

2.2.1  GENERAL  REGISTERS 

2.2.1. 1 R0-R13 

These  registers  are  used  to  execute  various  instructions  as  GSU 
General  Registers  during  GSU  operation.  There  are  special 
functions  available  for  some  instructions  (refer  to  “GSU  Internal 
Register  Configuration”).  These  can  also  be  accessed  by  the  Su- 
per NES  CPU  when  the  GSU  is  in  the  idle  state. 


2-2-3 


GSU  FUNCTIONAL  OPERATION 


2.2.1 .2  R14 

This  register  functions  as  a data  pointer  for  game  pak  ROM  dur- 
ing GSU  operation.  Data  addressed  in  this  register  is  automati- 
cally stored  in  the  ROM  buffer.  As  with  RO  ~ R13,  this  register 
may  be  used  as  a GSU  general  register.  It  can  also  be  accessed 
by  the  Super  NES  CPU  when  the  GSU  is  in  the  idle  state. 

2.2. 1.3  R15 

This  register  is  the  GSU  Program  Counter.  If  an  address  is  writ- 
ten to  this  register  from  the  Super  NES  CPU,  while  the  GSU  is 
idle,  the  GSU  will  be  activated. 

2.2.1. 4 STATUS/FLAG  REGISTER  (SFR) 

The  “flags”  in  this  register  indicate  GSU  status  and  operation  re- 
sults. This  register  can  be  referenced  by  the  Super  NES  CPU 
even  while  the  GSU  is  operating. 

2.2.2  REGISTERS  RELATED  TO  MEMORY  OPERATIONS 

2.2.2. 1 PROGRAM  BANK  REGISTER  (PBR) 

This  register  specifies  the  memory  bank  when  an  instruction  is 
read.  Its  value  must  be  assigned  from  the  Super  NES  CPU  be- 
fore the  GSU  is  activated.  This  is  changed  during  GSU  operation 
using  the  LJMP  instruction. 

2. 2. 2. 2 GAME  PAK  ROM  BANK  REGISTER  (ROMBR) 

This  register  specifies  the  game  pak  ROM  bank  when  data  are 
read  from  the  game  pak  ROM  using  the  ROM  buffering  system. 
Its  value  is  changed  during  GSU  operation  using  the  ROMB  in- 
struction. 

2. 2. 2. 3 GAME  PAK  RAM  BANK  REGISTER  (RAMBR) 

This  register  specifies  the  game  pak  RAM  bank  when  data  are 
read/written  from/to  the  game  pak  RAM.  Its  value  is  changed 
during  GSU  operation  using  the  RAMB  instruction. 

2.2.2.4  CACHE  BASE  REGISTER  (CBR) 

This  register  specifies  the  starting  address  when  loading  data 
from  the  game  pak  ROM  or  RAM  to  the  cache  RAM.  The  value 
for  CBR  is  updated  during  GSU  operation  whenever  the  CACHE 
instruction  or  LJMP  instruction  is  executed. 

2.2.3  PLOT  RELATED  REGISTERS 

2.2.3. 1 SCREEN  BASE  REGISTER  (SCBR) 

This  register  is  used  to  specify  the  start  address  in  the  character 
data  storage  area.  Its  value  must  be  assigned  from  the  Super 
NES  CPU  prior  to  activating  the  GSU. 


2-2-4 


SNES  DEVELOPMENT  MANUAL 


2. 2.3. 2 SCREEN  MODE  REGISTER  (SCMR) 

This  register  assigns  the  color  and  screen  mode  when  PLOT 
processing  is  performed.  Its  value  must  be  assigned  from  the 
Super  NES  CPU  prior  to  activating  the  GSU. 

2.2.3. 3 COLOR  REGISTER  (COLR) 

This  register  specifies  the  color  when  PLOT  processing  is  per- 
formed. Its  value  is  changed  during  GSU  operation  using  the 
COLOR  instruction  or  GETC  instruction.  It  cannot  be  accessed 
from  the  Super  NES  CPU. 

2.2.3.4  PLOT  OPTION  REGISTER  (POR) 

This  register  assigns  the  mode  when  executing  the  COLOR, 
GETC,  or  PLOT  instructions.  When  these  instructions  are  used, 
the  value  of  the  plot  option  register  must  be  assigned  before  exe- 
cution, using  the  CMODE  instruction. 

2.2.4  OTHER  REGISTERS 

2.2.4. 1 B-RAM  REGISTER  (BRAMR) 

Back-up  RAM  enable/disable  can  be  controlled  by  this  register. 
The  register’s  value  must  be  assigned  from  the  Super  NES  CPU. 

2.2.4. 2 VERSION  CODE  REGISTER  (VCR) 

This  assigns  the  GSU  version  code.  Its  value  can  be  read  only 
from  the  Super  NES  CPU. 

2. 2.4.3  CONFIG  REGISTER  (CFGR) 

This  register  assigns  the  execution  speed  for  GSU  multiplication 
instructions  and  enables/disables  the  interrupt  signal  to  the  Su- 
per NES  CPU.  Its  value  must  be  assigned  from  the  Super  NES 
CPU  prior  to  GSU  activation. 

2. 2.4.4  CLOCK  SELECT  REGISTER  (CLSR) 

This  register  is  used  to  assign  the  operating  frequency  for  the 
Super  FX.  Its  value  must  be  assigned  from  the  Super  NES  CPU 
prior  to  activation  of  the  Super  FX. 


2-2-5 


GSU  FUNCTIONAL  OPERATION 


INSTRUCTION  SET 


There  are  98  instructions  available  in  the  GSU.  These  instructions  and  their  func- 
tions are  given  in  the  following  table. 


CLASSIFICATION 


From  game  pak 
ROM  (ROM 


Y ^ From  game  pak 
a if  RAM  to  register 


N T From  register  to 
S I game  pak  RAM 
F O (RAM  buffer) 

E N 

R S 

From  register 
to  register 

Immediate  data 
to  register 


Arithmetic 

Operation 

Instructions 


INSTRUCTION 

FUNCTION 

GETB 

Get  byte  from  ROM  buffer 

GETBH 

Get  high  byte  from  ROM  buffer 

GETBL 

Get  low  byte  from  ROM  buffer 

GETBS 

Get  signed  byte  from  ROM  buffer 

GETC 

Get  byte  from  ROM  to  color  register 

LDW 

(Rm) 

Load  word  data  from  RAM 

LDB 

(Rm) 

Load  byte  data  from  RAM 

LM 

Load  word  data  from  RAM  using  16  bits 

LMS 

laaiKi] 

Load  word  data  from  RAM,  short  address 

Store  word  data  to  RAM 

STB 

(Rm) 

Store  byte  data  to  RAM 

SM 

(xx),  Rn 

Store  word  data  to  RAM  using  16  bits 

SMS 

(yy),  Rn 

Store  word  data  to  RAM,  short  address 

SBK 

Store  word  data,  last  RAM  address  used 

MOVE 

Rn,  Rn’ 

Move  word  data 

MOVES 

Rn,  Rn’ 

Move  word  data  and  set  flags 

IWT 

Rn,  #xx 

Load  immediate  word  data 

IBT 

Rn,  #pp 

Load  immediate  byte  data 

ADD  Rn 
ADD  #n 
ADC  Rn 
ADC  #n 
SUB  Rn 
SUB  #n 
SBC  Rn 
CMP  Rn 
MULT  Rn 
MULT  #n 
UMULT  Rn 
UMULT  #n 
FMULT 
LMULT 
DIV2 

INC  Rn 
DEC  Rn 


Instruction  Set  (Sheet  1) 


Add  with  carry 
Subtract 

Subtract  with  carry 

Compare 

Signed  multiply 

Unsigned  multiply 

Fractional  signed  multiply 
16x16  signed  multiply 
Divide  by  2 

Increment 

Decrement 


2-2-6 


CLASSIFICATION 


INSTRUCTION 


FUNCTION 


Logical 

Operation 

Instructions 


Shift 

Instructions 


Byte 

Transfer 

Instructions 


Jump,  Branch, 
Loop  Instructions 


Bank  Set-up 
Instructions 


Plot-related 

Instructions 


AND  Rn 
AND  #n 


OR  Rn 

OR  #n 


NOT 


XOR  Rn 
XOR  #n 


BIC  Rn 

BIC  #n 


ASR 


LSR 


ROL 


ROR 


HIB 


LOB 


MERGE 


SEX 


SWAP 


P R 


LJMP  Rn 


BRA  e 


BGE  e 


BLT  e 


BNE  e 


BEQ  e 


BPL 


BMI 


BCC 


BCS 


BVC  e 


BVS  e 


LOOP 


LINK  #n 


ROMB 


RAMB 


CMODE 


COLOR 


PLOT 


RPIX 


Logical  AND 


Logical  OR 


Invert  all  bits 


Logical  exclusive  OR 


Bit  clear  mask 


Arithmetic  shift  right 


Logical  shift  right 


Rotate  left  through  carry 


Rotate  right  through  carry 


Value  of  high  byte  of  register 


Value  of  low  byte  of  register 


Merge  high  byte  of  R8  and  R7 


Sign  extend  register 


Swap  low  and  high  byte 


P 


Long  jump 


Branch  always 


Branch  on  greater  than  or  equal  to  zero 


Branch  on  less  than  zero 


Branch  on  not  equal 


Branch  on  equal 


Branch  on  plus 


Branch  on  minus 


Branch  on  carry  clear 


Branch  on  carry  set 


Branch  on  overflow  clear 


Branch  on  overflow  set 


Loop 


Link  return  address 


Set  ROM  data  bank 


Set  RAM  data  bank 


Set  plot  mode 


Set  plot  color 


Plot  pixel 


Read  pixel  color 


2-2-7 


GSU  FUNCTIONAL  OPERATION 


CLASSIFICATION 

INSTRUCTION 

FUNCTION 

Prefix  Flag 
Instructions 

ALT1 

SetALTI  mode 

ALT2 

Set  ALT2  mode 

ALT3 

Set  ALT3  mode 

Prefix  Register 
Instructions 

FROM  Rn 

Set  Sreg 

TO  Rn 

Set  Dreg 

WITH  Rn 

Set  Sreg  and  Dreg 

GSU  Control 
Instructions 

CACHE 

Set  cache  base  register 

NOP 

No  operation  i 

STOP 

Stop  processor 

Macro 

Instructions 

MOVEW  Rn,  (Rn’) 

Load  word  data  from  RAM 

MOVEB  Rn,  (Rn’) 

Load  byte  data  from  RAM 

MOVE  Rn,  (xx) 

Load  word  data  from  RAM  using  1 6 bits 

MOVEW  (Rn’),  Rn 

Store  word  data  to  RAM 

MOVEB  (Rn’),  Rn 

Store  byte  data  to  RAM 

MOVE  (xx),  Rn 

Store  word  data  to  RAM  using  1 6 bits 

MOVE  Rn,  #xx 

Load  immediate  word  data 

LEA  Rn,  xx 

Load  effective  address 

Table  2-2-2  Instruction  Set  (Sheet  3) 


2-2-8 


Chapter  3 Memory  Mapping 


3.1  SUPER  NES  CPU  MEMORY  MAP 

The  figure  on  the  following  page  depicts  the  memory  map  for  the  Super  NES 
CPU.  Refer  to  this  figure  while  reading  the  sub-paragraphs  below. 

3.1.1  GSU  INTERFACE 

This  area  (A)  is  mapped  to  address  3000H  ~ 32FFH  in  banks  00H  ~ 3FH 
and  80H  ~ BFH.  (Refer  to  “GSU  Internal  Register  Configuration”.) 

3.1.2  GAME  PAK  ROM 

Game  pak  ROM  (B)  is  mapped  to  2 Mbytes  starting  from  00:8000H.  Two 
Mbytes  from  40:0000H  (B’)  are  used  for  the  ROM  image.  This  image  is 
stored  in  blocks  of  32  Kbytes,  as  indicated  on  the  memory  map  by  circled 
numbers  (i.e.,  area;  ©’  is  the  image  of  area  ©,  ©’  is  the  image  of  area  <D, 
and  so  forth). 

3.1.3  GAME  PAK  RAM 

Game  pak  RAM  (C)  is  mapped  to128  Kbytes  starting  from  70:0000H. 
Eight  Kbytes  from  address  6000H  (C’)  in  each  of  banks  00-3F  and 
80-BF  are  used  for  RAM  image. 

3.1.4  BACK-UP  RAM 

Back-up  RAM  (D)  is  mapped  to  128  Kbytes  from  78:0000H. 

3.1 .5  SUPER  NES  CPU  ROM 

Six  Mbyte  of  ROM  (E)  is  mapped  from  80:8000H. 


2-3-1 


SUPER  NES  CPU  MEMORY  MAP 


MEMORY  MAPPING 


X 

X 

XX 

X 

X 

o 

o 

oo 

o 

o 

o 

o 

oo 

o 

o 

o 

o 

00  o 

o 

o 

00 

CO 

0000 

CM 

o 

< 

Figure  2-3-1  Super  NES  CPU  Memory  Map 


2-3-2 


SNES  DEVELOPMENT  MANUAL 


3.2  GSU  MEMORY  MAPPING 

The  GSU  memory  map  is  depicted  on  the  following  page. 

3.2.1  GAME  PAK  ROM 

The  game  pak  ROM  (A)  is  mapped  to  2 Mbytes  starting  from  00:8000H. 
Two  Mbytes  from  40:0000H  (A’)  are  used  for  the  ROM  image.  This  image 
is  stored  in  blocks  of  32  Kbytes,  as  indicated  on  the  memory  map  by  cir- 
cled numbers  (i.e.,  area;  ©’  is  the  image  of  area  ©,  ©’  is  the  image  of 
area  (D,  and  so  forth).  Other  areas  should  not  be  used  for  this  purpose. 

3.2.2  GAME  PAK  RAM 

Game  pak  RAM  (B)  is  mapped  to128  Kbytes  starting  from  70:0000H. 
When  the  GSU  accesses  memory,  it  specifies  bank  addresses  using 
three  bank  registers.  These  are;  Program  Bank  Register  (PBR),  ROM 
Bank  Register  (ROMBR),  and  RAM  Bank  Register  (RAMBR). 


2-3-3 


SUPER  FX  MEMORY  MAP 


Figure  2-3-2  Super  FX  Memory  Map 


2-3-4 


Note:  The  PBR  can  be  used  to  specify  any  bank  address  that  is  mapped. 
The  ROMBR  can  only  be  used  to  specify  banks  00H  to  5FH. 


SNES  DEVELOPMENT  MANUAL 


Chapter  4 GSU  Internal  Register  Configuration 

The  GSU  internal  registers  will  be  described  in  detail  in  this  chapter.  Although  many  of 
these  registers  may  be  accessed  from  the  Super  NES  CPU,  none  can  be  accessed  in 
this  way  during  operation  of  the  GSU,  with  the  exception  of  the  Status/Flag  Register 
(SFR)  and  Version  Code  Register  (VCR).  In  addition,  when  addressing  the  16-bit  regis- 
ters from  the  Super  NES  CPU,  the  low  byte  must  be  accessed  first. 

All  addresses  denoted  with  (**)  can  be  accessed  in  banks  00H  ~ 3FH  and 
80H  - BFH. 

4.1  GENERAL  REGISTERS  (RO  ~ R1 3) 

Access  from  Super  NES  CPU:  R/W 

Register  Size:  16  bits 

GSU  Access  Method:  Various  transfer  instructions  (LDW  (Rn)) 

Various  Operation  Instructions  (ADD  Rn) 

Other  Instructions 


Register 

Name 

Super  NES 
CPU  Address 

Special  Functions 

Initial  Value 

RO 

**  :3000H,  3001 H 

Default  source/destination  register 

Invalid 

R1 

**  :3002H,  3003H 

PLOT  instruction,  X coordinate 

0000H 

R2 

**  :3004H,  3005H 

PLOT  instruction,  Y coordinate 

0000H 

R3 

**  :3006H,  3007H 

Invalid 

R4 

**  :3008H,  3009H 

LMULT  instruction,  lower  16  bits 

Invalid 

R5 

**  :300AH,  300BH 

Invalid 

R6 

**  :300CH,  300DH 

FMULT  and  LMULT  instructions, 
multiplication 

Invalid 

R7 

**  :300EH,  300FH 

MERGE  instruction,  source  1 

Invalid 

R8 

** : 301  OH,  301 1H 

MERGE  instruction,  source  2 

Invalid 

R9 

**  :3012H,  301 3H 

Invalid 

RIO 

**  :3014H,  301 5H 

Invalid 

R11 

**  :3016H,  301 7H 

LINK  instruction  destination  register 

Invalid 

R12 

**  :3018H,  301 9H 

LOOP  instruction  counter 

Invalid 

R13 

** : 301  AH,  301 BH 

LOOP  instruction  branch 

Invalid 

Table  2-4-1  GSU  General  Registers 


2-4-1 


GSU  INTERNAL  REGISTER  CONFIGURATION 


For  LINK  and  LOOP  special  functions  refer  to  “Instruction  Execution”,  for  other 
special  functions  refer  to  the  instruction  name  in  the  chapter  titled  “Description  of 
Instructions”. 

RO 


D15 

D14 

D13 

D12 

Dll 

D10 

D9 

D8 

D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

3001 H 
3000H 


Figure  2-4-1  Example  of  General  Register 

4.2  GAME  PAK  ROM  ADDRESS  POINTER  (R14) 

Access  from  Super  NES  CPU:  R/W 

Super  NES  CPU  Addresses:  **  :301  CH,  301 1 DH 

Register  Size:  16  bits 

GSU  Access  Method:  Various  transfer  instructions  (LDW  (Rn)) 

Various  operation  instructions  (ADD  Rn) 
Other  instructions 

D7  D6  D5  D4  D3  D2  D1  DO 


301  DH 


301  CH 


GAME  PAK  ROM  ' 

A15 

A14 

A13 

A12  All  A10 

A9 

A8 

GAME  PAK  ROM  ' 

A7 

A6 

A5 

A4  A3  A2 

A1 

A0 

R14  is  a pointer  that  specifies  the  game  pak  ROM  address  when  data  are  loaded 
from  the  game  pak  ROM  to  an  internal  register.  Typically,  the  ROM  buffering  sys- 
tem will  be  used  for  this  process. 


2-4-2 


SNES  DEVELOPMENT  MANUAL 


4.3  PROGRAM  COUNTER  (R1 5) 

Access  from  Super  NES  CPU:  R/W 

Super  NES  CPU  Addresses:  **  :301  EH,  301 1 FH 

Register  Size:  1 6 bits 

Default  Address:  0000H 

GSU  Access  Method:  Various  branching  instructions  (JMP  Rn) 

Other  instruction 

D7  D6  D5  D4  D3  D2  D1  DO 


301  FH 


301  EH 


PC15 

PC14 

Program  Counter 
PC13  | PCI 2 | PC11 

PC10 

PC9 

PC8 

PC7 

PC6 

Program  Counter 
PC5  | PC4  PC3 

PC2 

PCI 

PCO 

R15  is  the  GSU  program  counter.  If  its  value  is  changed  by  a transfer  instruction 
or  operation  instruction,  the  program  jumps  to  the  address  of  the  new  value. 


2-4-3 


GSU  INTERNAL  REGISTER  CONFIGURATION 


4.4  STATUS/FLAG  REGISTER  (SFR) 

Access  from  Super  NES  CPU:  R/W 

Super  NES  CPU  Addresses:  **  :3030H,  3031 FH 

Register  Size:  1 6 bits 

Default  Address:  0000H 

D7  D6  D5  D4  D3  D2  D1  DO 


Flag 

Description 

Z 

Zero  flag 

CY 

Carry  flag 

S 

Sign  flag 

ov 

Overflow  flag 

G 

Go  flag  (set  to  1 when  the  GSU  is  running) 

R 

Set  to  1 when  reading  ROM  using  R14  address. 

ALT1 

Mode  set-up  flag  for  the  next  instruction 

ALT2 

Mode  set-up  flag  for  the  next  instruction 

IL 

Immediate  lower  8-bit  flag 

IH 

Immediate  higher  8-bit  flag 

B 

Set  to  1 when  the  WITH  instruction  is  executed. 

IRQ 

Interrupt  flag 

Table  2-4-2 

GSU  Status  Register  Flags 

The  Status/Flag  register  indicates  the  status  of  the  GSU.  It  may  be  accessed  from 
the  Super  NES  CPU  during  GSU  operation  to  determine  GSU  status. 


2-4-4 


SNES  DEVELOPMENT  MANUAL 


4.5  PROGRAM  BANK  REGISTER  (PBR) 


Access  from  Super  NES  CPU: 
Super  NES  CPU  Addresses: 
Register  Size: 

Default  Address: 

GSU  Access  Method: 


R/W 

**  :3034H 
8 bits 
Undefined 
LJMP  instruction 


D7 

D6 

D5 

D4  D3 

D2 

D1 

DO 

A23 

A22 

A21 

Program  Bank 
A20  | A19 

A18 

AM 

A16 

3034H 


The  program  bank  register  specifies  the  memory  bank  register  to  be  accessed 
when  the  GSU  is  loading  the  program  code. 

4.6  GAME  PAK  ROM  BANK  REGISTER  (ROMBR) 

Access  from  Super  NES  CPU:  R 

Super  NES  CPU  Addresses:  **  :3036H 

Register  Size:  8 bits 

Default  Address:  Undefined 

GSU  Access  Method:  ROMB  instruction 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

ROM  Data  Bank 

A23 

A22 

A21 

A20 

A19 

A18 

AM 

A16 

3036H 


The  game  pak  ROM  bank  register  specifies  the  game  pak  ROM  bank  when  load- 
ing data  from  game  pak  ROM  using  the  ROM  buffering  system. 


2-4-5 


GSU  INTERNAL  REGISTER  CONFIGURATION 


3 


4.7  GAME  PAK  RAM  BANK  REGISTER  (RAMBR) 


Access  from  Super  NES  CPU: 
Super  NES  CPU  Addresses: 
Register  Size: 

Default  Address: 

GSU  Access  Method: 


R 

**  :303CH 
1 bit 

Undefined 
RAMB  instruction 


D7 

D6 

D5  D4  D3 

D2 

D1 

DO 

RAM  Data  Bank 

* 

* 

★ | * | * 

★ 

★ 

A16 

303CH 


Bank  = 70H  when  DO  = 0 

Bank  = 71 H when  DO  = 1 * This  bit  is  0 when  this  register  is  read. 


The  game  pak  RAM  bank  register  specifies  the  game  pak  RAM  bank  when  data 
are  read/written  between  game  pak  RAM  and  the  GSU  internal  registers.  The 
RAMB  instruction  specifies  bank  70H  or  71 H for  game  pak  RAM  access. 


4.8  CACHE  BASE  REGISTER  (CBR) 


Access  from  Super  NES  CPU: 
Super  NES  CPU  Addresses: 
Register  Size: 

Default  Address: 

GSU  Access  Method: 


R 

**  :303EH,  303FH 
1 2 bits 
0000H 

LJMP,  CACHE  instructions 


D7 

D6 

D5  D4  D3  D2 

D1 

DO 

Cache  Base  Address 

A15 

A14 

A13  | A12  | All  | A10 

A9 

A8 

Cache  Base  Address 

A7 

A6 

A5 

A4 

★ 

* 

* 

303FH 

303EH 


* This  bit  is  0 when  this  register  is  read. 

The  cache  base  register  specifies  the  starting  address  when  data  are  loaded  from 
game  pak  ROM  or  RAM  to  the  cache  RAM. 


2-4-6 


SNES  DEVELOPMENT  MANUAL 


4.9  SCREEN  BASE  REGISTER  (SCBR) 


Access  from  Super  NES  CPU: 
Super  NES  CPU  Addresses: 
Register  Size: 

Default  Address: 

GSU  Access  Method: 


W 

**  :3038H 
8 bits 
Undefined 
None 


D7 

D6 

D5  D4  D3  D2 

D1 

DO 

Screen  Base  Address 

A17 

A16 

A15  | A14  | A13  | A12 

All 

A10 

3038 H 


The  screen  base  register  is  used  to  specify  the  start  address  in  the  character  data 
storage  area. 


2-4-7 


GSU  INTERNAL  REGISTER  CONFIGURATION 


4.10  SCREEN  MODE  REGISTER  (SCMR) 


Access  from  Super  NES  CPU:  W 


Super  NES  CPU  Addresses:  **  :303AH 

Register  Size:  6 bits 

Default  Address:  00H 

GSU  Access  Method:  None 


D7 

D6 

D5  D4  D3  D2 

D1 

DO 

Screen  Hefght  Select 

Color  Gradient 

- 

- 

HT1  | RON  | RAN  | HT0 

MD1 

MD0 

303AH 


The  screen  mode  register  specifies  the  color  gradient  and  screen  height  during 
PLOT  processing  and  controls  game  pak  ROM  and  RAM  bus  assignments. 

4.10.1  SCREEN  HEIGHT 


Ht  1 

Ht  0 

Mode 

0 

0 

128  (pixels) 

0 

1 

160  (pixels) 

1 

0 

192  (pixels) 

1 

1 

OBJ  mode 

Table  2-4-3  Screen  Height 

4.10.2  COLOR  GRADIENT 


Mod  1 

ModO 

Mode 

0 

0 

4-color  mode 

0 

1 

16-color  mode 

1 

0 

Not  used 

1 

1 

256-color  mode 

Table  2-4-4  Color  Gradient 

4.10.3  ROM/RAM  ENABLE  FLAGS 

When: 

RON  = 0,  the  Super  NES  CPU  has  game  pak  ROM  bus  access. 
1 , the  GSU  has  game  pak  ROM  bus  access. 

RAN  = 0,  the  Super  NES  CPU  has  game  pak  RAM  bus  access. 
1 , the  GSU  has  game  pak  RAM  bus  access. 


2-4-8 


SNES  DEVELOPMENT  MANUAL 

r 


3 


4.11  COLOR  REGISTER  (COLR) 


Access  from  Super  NES  CPU: 
Super  NES  CPU  Addresses: 
Register  Size: 

Default  Address: 

GSU  Access  Method: 


Disabled 

8 bits 
Undefined 

COLOR,  GETC  instructions 


D7  D6  D5  D4  D3  D2  D1  DO 


Color 

Data 

CD7 

CD6 

CD5 

CD4 

CD3 

CD2 

CD1 

CDO 

The  color  register  contains  data  which  specifies  the  colors  to  be  plotted  when 
PLOT  processing  is  performed. 

4.12  PLOT  OPTION  REGISTER  (POR) 

Access  from  Super  NES  CPU:  Disabled 

Super  NES  CPU  Addresses: 

Register  Size:  5 bits 

Default  Address:  Undefined 

GSU  Access  Method:  CMODE  instruction 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

- 

- 

OBJ 

Flag 

Freeze 

High 

Flag 

High 

Nibble 

Flag 

Dither 

Flag 

T rans- 
parent 

Flag 

The  plot  option  register  contains  flags  which  specify  the  mode  to  be  used  when  a 
COLOR,  GETC,  or  PLOT  instruction  is  executed. 


2-4-9 


GSU  INTERNAL  REGISTER  CONFIGURATION 


4.13  BACK-UP  RAM  REGISTER  (BRAMR) 

Access  from  Super  NES  CPU:  W 


Super  NES  CPU  Addresses:  **  :3033H 

Register  Size:  1 bit 

Default  Address:  00H 

GSU  Access  Method:  None 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

- 

- 

- 

- 

- 

- 

- 

BRAM 

Flag 

3033 H 


When: 

BRAM  Flag  = 0,  BRAM  is  disabled. 

1 , BRAM  is  enabled. 

Data  becomes  “protected”  when  the  BRAM  flag  is  reset  (“0”)  after  saving  data  to 
the  Back-up  RAM. 

4.14  VERSION  CODE  REGISTER  (VCR) 

Access  from  Super  NES  CPU:  R 

Super  NES  CPU  Addresses:  **  :303BH 

Register  Size:  8 bit 

Default  Address:  Undefined 

GSU  Access  Method:  None 


D7 

D6 

D5  D4  D3 

D2 

D1 

DO 

Version  Code 

VC7 

VC6 

VC5  | VC4  | VC3  | 

VC2 

VC1 

VCO 

303BH 


The  version  code  register  permits  the  user  to  read  the  GSU  version  code. 


2-4-10 


SNES  DEVELOPMENT  MANUAL 


4.15  CONFIG  REGISTER  (CFGR) 

Access  from  Super  NES  CPU:  W 


Super  NES  CPU  Addresses:  **  :3037H 

Register  Size:  8 bit 

Default  Address:  00H 

GSU  Access  Method:  None 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

IRQ 

- 

MSO 

- 

- 

- 

- 

- 

I ► Multiplier  Speed  Selection 

0 : Standard  Speed  Mode 

1 : High  Speed  Mode 


3037H 


► IRQ  Mask  Flag 

This  is  equal  to  1 when  the  GSU  interrupt  request  is  masked. 


The  CONFIG  register  selects  the  operating  speed  of  the  multiplier  in  the  GSU  and  ~ 
sets  up  a mask  for  the  interrupt  signal. 

Note:  When  the  Super  FX  operates  at  21  MHz  (when  the  CLSR  flag  of  the 
Clock  Select  Register  is  “1”),  MSO  flag  should  be  fixed  at  “0”. 


4.16  CLOCK  SELECT  REGISTER  (CLSR) 

Access  from  Super  NES  CPU:  W 


Super  NES  CPU  Addresses:  **:3039H 

Register  Size:  1 bit 

Default  Address:  00H 

GSU  Access  Method:  None 


D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

- 

- 

- 

- 

- 

- 

CLSR 

Flag 

3039H 


When: 

CLSR  Flag  = 0,  Super  FX  operates  at  10.7  MHz 
= 1 , Super  FX  operates  at  21 .4  MHz 

This  register  assigns  the  Super  FX  operating  frequency. 


2-4-11 


GSU  PROGRAM  EXECUTION 


) 


Chapter  5 GSU  Program  Execution 

5.1  STARTING  THE  GSU 

The  GSU  is  placed  in  the  idle  state  when  the  Super  NES  control  deck  is  reset.  The 
GSU  is  started  by  writing  to  its  internal  program  counter  (R15)  from  the  Super 
NES.  The  GSU  programs  operate  on  the  game  pak  ROM,  RAM,  or  cache  RAM, 
but  the  GSU  activation  method  differs  depending  upon  which  memory  is  access- 
ed. The  various  methods  are  described  below. 

5.1 .1  STARTING  GSU  PROGRAM  IN  GAME  PAK  ROM 

The  GSU  is  started  by  the  following  method  when  the  GSU  program  is  to 
operate  in  the  game  pak  ROM. 

5.1. 1.1  BUS  CONTROL 

In  order  for  the  Super  NES  CPU  to  pass  game  pak  ROM  bus 
access  to  the  GSU,  the  Super  NES  CPU  program  used  to  start 
the  GSU  in  an  area  other  than  the  game  pak  ROM  (such  as 
WRAM)  is  transferred  to  the  GSU  and  the  GSU  jumps  to  that 
program. 

However,  if  the  optional  ROM  for  the  Super  NES  is  being  used, 
the  GSU  can  be  started  by  running  the  start  program  in  Super 
NES  ROM,  making  the  above  transfer  unnecessary. 

5.1. 1.2  REGISTER  ADDRESSING 

In  the  Super  NES  CPU  program  for  starting  the  GSU,  first  as- 
sign the  following  registers. 

• PBR  (Super  NES  CPU  Address,  **:3034H) 

• SCBR  (Super  NES  CPU  Address,  **:3038H) 

• SCMR  (Super  NES  CPU  Address,  **:303AH) 

Note:  RON  absolutely  must  be  set  to  “1”. 

• CFGR  (Super  NES  CPU  Address,  **:3037H) 

• CLSR  (Super  NES  CPU  Address,  **:3039H 

Subsequently,  when  the  lead  address  of  the  GSU  program  is 
written  from  the  Super  NES  CPU  to  R15  (Super  NES  CPU  ad- 
dress, **:301EH),  the  GSU  can  be  started  from  that  address. 

An  example  of  the  program  required  for  starting  the  GSU  from 
the  Super  NES  is  demonstrated  on  the  following  page. 


2-5-1 


SNES  DEVELOPMENT  MANUAL 


1 


mem8 

Ida 

#clock  data 

sta 

3039H 

;Sets  operating  frequency 

sta 

3037H 

;Sets  CONFIG  register 

Ida 

#screen  base 

' 

sta 

3038H 

;Sets  screen  base 

Ida 

#program  bank 

sta 

3034H 

; Sets  program  code  bank 

Ida 

#screen  size  mode 

ora 

18H 

; Sets  RON,  RAN  flag,  screen  s 

sta 

303aH 

mem  16 
rep 

#00100000B 

Ida 

#program  address 

sta 

301  EH 

; Sets  program  counter 

5.1.2  STARTING  GSU  PROGRAM  IN  GAME  PAK  RAM 

The  following  procedure  is  used  to  start  the  GSU  when  its  program  is  to 
operate  in  game  pak  RAM. 

5.1 .2.1  TRANSFER  GSU  PROGRAM 

The  Super  NES  CPU  first  transfers  the  GSU  program  from  the 
game  pak  ROM  to  game  pak  RAM.  If  the  GSU  will  not  be  using 
game  pak  ROM,  the  Super  NES  CPU  does  not  need  to  pass 
the  game  pak  ROM  bus  access  to  the  GSU. 

5.1 .2.2  REGISTER  ADDRESSING 

In  the  Super  NES  CPU  program  for  starting  the  GSU,  first  as- 
sign the  following  registers. 

• PBR  (Super  NES  CPU  Address,  **:3034H) 

• SCBR  (Super  NES  CPU  Address,  **:3038H) 

• SCMR  (Super  NES  CPU  Address,  **:303AH) 

Note:  RAN  absolutely  must  be  set  to  “1”. 

• CFGR  (Super  NES  CPU  Address,  **:3037H) 

• CLSR  (Super  NES  CPU  Address,  **:3039H) 

Subsequently,  when  the  lead  address  of  the  GSU  program  is 
written  from  the  Super  NES  CPU  to  R15  (Super  NES  CPU  ad- 
dress, **:301EH),  the  GSU  can  be  started  from  that  address. 


2-5-2 


5.1.3  STARTING  GSU  PROGRAM  IN  CACHE  RAM 

The  following  procedure  is  used  to  start  the  GSU  when  its  program  is  to 
operate  in  cache  RAM. 

5.1 .3.1  TRANSFER  GSU  PROGRAM 

The  Super  NES  CPU  first  transfers  the  GSU  program  from  the 
game  pak  ROM  to  cache  RAM.  If  the  GSU  will  not  be  using 
game  pak  ROM  or  RAM,  the  Super  NES  CPU  does  not  need  to 
pass  the  game  pak  ROM  or  RAM  bus  access  to  the  GSU. 

5.1. 3.2  REGISTER  ADDRESSING 

In  the  Super  NES  CPU  program  for  starting  the  GSU,  first  as- 
sign the  following  registers. 

• PBR  (Super  NES  CPU  Address,  **:3034H) 

• SCBR  (Super  NES  CPU  Address,  **:3038H) 

• SCMR  (Super  NES  CPU  Address,  **:303AH) 

• CFGR  (Super  NES  CPU  Address,  **:3037H) 

• CLSR  (Super  NES  CPU  Address,  **:3039H) 

Subsequently,  when  the  lead  address  of  the  GSU  program  is 
written  from  the  Super  NES  CPU  to  R15  (Super  NES  CPU  ad- 
dress, **:301EH),  the  GSU  can  be  started  from  that  address. 

5.2  STOPPING  THE  GSU 

The  following  two  methods  may  be  used  to  stop  the  GSU. 

• GSU  auto-stop  using  the  STOP  instruction 

• Forced  stop  from  the  Super  NES  CPU  using  the  GO  flag 

5.2.1  GSU  AUTO-STOP  USING  STOP  INSTRUCTION 

The  STOP  instruction  is  one  of  the  instructions  in  the  GSU  instruction  set. 
When  the  GSU  reads  the  STOP  instruction,  it  resets  the  GO  flag,  sends 
an  interrupt  (IRQ)  to  the  Super  NES  CPU  (to  inform  the  CPU  that  pro- 
cessing is  complete),  and  goes  into  the  idle  state. 

The  value  in  R15  after  the  GSU  has  executed  a STOP  instruction  varies 
depending  upon  the  instruction  that  was  executed  immediately  prior  to 
the  STOP  instruction. 


Instruction  Type 

Value  of  R15 

Transfer  Data  to  R15 

R15  Data  + 1 

Jump  or  Branch 

Jump  or  branch  destination 
address  + 1 

CACHE  Instruction 

Address  of  STOP  instruction  + 1 

Other  Instruction 

Address  of  STOP  instruction  + 1 

2-5-3 


SNES  DEVELOPMENT  MANUAL 


3 


5.2.2  FORCED  STOP  FROM  SUPER  NES  CPU  USING  GO  FLAG 

The  GSU  can  be  forceably  stopped  by  writing  a “0”  from  the  Super  NES 
CPU  to  the  GO  flag  in  the  status/flag  register  (Super  NES  CPU  address, 
**  :3030H).  This  clears  the  data  in  the  cache  and  resets  the  cache  base 
register  to  0000H. 

5.3  MEMORY  ACCESS  FROM  SUPER  NES  CPU  DURING  GSU 
OPERATION 

If  a “0”  is  written  from  the  Super  NES  CPU  to  the  RON  flag  in  the  status/flag  regis- 
ter (Super  NES  CPU  address,  **  :303AH)  during  GSU  operation,  the  GSU  will 
shift  to  WAIT  status  when  it  requires  game  pak  ROM  access.  This  makes  it  tem- 
porarily possible  to  access  game  pak  ROM  from  the  Super  NES  CPU. 

The  WAIT  status  is  subsequently  canceled  by  writing  a “1”  to  RON  from  the  Super 
NES  CPU.  This  causes  the  GSU  to  resume  processing.  In  a similar  manner, 
game  pak  RAM  can  be  temporarily  accessed  by  the  Super  NES  CPU,  using  the 
RAN  flag  in  the  screen  mode  register. 

5.4  INTERRUPTS 

5.4.1  SUPER  NES  CPU  INTERRUPT  VECTOR 

Game  pak  ROM  access  from  the  Super  NES  CPU  is  inhibited  during 
GSU  operation  and  when  the  RON  flag  is  “1”.  If  an  interrupt  (NMI)  is  gen- 
erated to  the  Super  NES  CPU  under  these  conditions,  an  interrupt  vector 
from  the  game  pak  ROM  will  not  be  available  for  the  Super  NES  CPU. 
This  will  cause  an  error.  In  order  to  avoid  this  problem,  when  a Super 
NES  CPU  interrupt  vector  is  read,  the  GSU  outputs  a dummy  vector  on 
the  data  bus.The  table  below  expresses  the  relationship  between  the  Su- 
per NES  CPU  interrupt  vector  addresses  and  the  dummy  vectors.  By 
placing  interrupt  routines  in  all  the  memories  except  the  game  pak  ROM 
and  encoding  a jump  instruction  to  each  of  the  interrupt  routines  at 
WRAM  addresses  00:01 04H,  00:01 00H,  00:01 08H,  and  00:01 0CH,  inter- 
rupt processing  can  be  executed  without  accessing  the  game  pak  ROM. 


Interrupt  Vector  Address 

Dummy  Vector 

00:FFE4 

00:0104 

00:FFE6 

00:0100 

00:FFE8 

00:0100 

00:FFEA 

00:0108 

00:FFEE 

00:0 10C 

Table  2-5-1  Dummy  Interrupt  Vector  Addresses 


2-5-4 


GSU  PROGRAM  EXECUTION 


Note:  If  the  game  pak  ROM  is  accessed  from  the  Super  NES  CPU  dur- 
ing GSU  operation  when  GO  and  RON  are  “1”,  the  dummy  data 
can  be  read  using  the  value  of  the  lower  4 bits  of  that  address. 
This  will  generate  the  dummy  addresses  described  above.  The  ta- 
ble below  demonstrates  this. 


Lower  4 Bits  of  Address 

Dummy  Data 

OH,  2H,  6H,  8H,  CH 

00H 

4H 

04H 

AH 

08H 

EH 

OCH 

Other 

01H 

Table  2-5-2  Dummy  Data 


5.4.2  INTERRUPT  FROM  GSU  TO  SUPER  NES  CPU 

The  STOP  instruction  generates  an  IRQ  from  the  GSU  to  the  Super  NES 
CPU.  Therefore,  the  Super  NES  CPU  can  continue  its  own  processing 
without  having  to  periodically  monitor  the  GSU  for  the  end  of  its  routine. 
Since  there  are  instances  in  which  an  IRQ  is  generated  for  some  other 
reason,  the  Super  NES  CPU  must  determine  if  the  GSU  was  the  source 
of  the  IRQ.  There  is  an  IRQ  flag  at  bit  15  of  the  GSU  status  register.  If  this 
flag  is  “1”,  the  IRQ  was  generated  by  the  completion  of  GSU  processing. 
When  bit  15  of  this  status  register  is  read,  the  bit  is  reset  to  “0”.  The  IRQ 
output  by  the  GSU  can  be  disabled  by  setting  bit  7 in  the  CONFIG  regis- 
ter to  “1”. 


2-5-5 


SNES  DEVELOPMENT  MANUAL 


Chapter  6 Instruction  Execution 

6.1  READING  INSTRUCTION  CODE 

6.1 .1  EXECUTION  IN  GAME  PAK  ROM/RAM 

The  GSU  executes  a program  by  reading  the  instruction  codes  from  the 
game  pak  ROM  or  RAM  at  the  addresses  specified  by  the  PBR  and  pro- 
gram counter  (R15).  The  contents  of  the  PBR  determines  whether  the  in- 
struction code  is  to  be  read  from  game  pak  ROM  or  RAM  (refer  to 
“Memory  Mapping”). 

The  RON  flag  must  be  set  (1)  when  an  instruction  code  is  read  from 
game  pak  ROM.  If  the  RON  flag  is  reset  (0),  the  GSU  will  be  placed  in  the 
WAIT  state  when  a game  pak  ROM  instruction  code  is  loaded.  Likewise, 
the  RAN  flag  must  be  set  (1)  when  an  instruction  code  is  read  from  game 
pak  RAM.  If  the  RAN  flag  is  reset  (0),  the  GSU  will  be  placed  in  the  WAIT 
state  when  a game  pak  RAM  instruction  code  is  loaded. 

6.1 .2  EXECUTION  IN  CACHE  RAM 

If  the  GSU's  program  counter  (R1 5)  is  in  a cache  area  determined  by  the 
cache  base  register  and  the  data  in  the  cache  are  valid,  the  GSU  will  read 
the  instruction  code  from  the  cache  RAM  and  execute  it.  When  a program 
is  being  executed  in  the  cache,  even  if  RON  or  RAN  is  reset  (0),  the  GSU 
will  not  stop  when  an  instruction  code  is  loaded.  Consequently,  it  be- 
comes possible  to  access  the  game  pak  ROM  or  RAM  from  the  Super 
NES  CPU. 

6.2  PIPELINE  PROCESSING 

The  GSU  employs  a “pipeline”  for  high-speed  operation.  This  “pipeline”  is  a mech- 
anism that,  in  parallel  with  the  execution  of  an  instruction,  loads  the  next  step  and 
prepares  it  as  the  next  instruction.  The  program  counter  (R15)  indicates  the  next 
address  following  the  instruction  currently  being  executed. 

Normally,  it  is  not  particularly  necessary  to  be  aware  of  this  processing,  but  it  must 
be  considered  when  using  instructions  that  change  the  program  counter  (R15), 
such  as  branch  or  jump  instructions.  When  a branching  process  is  executed,  the 
instruction  code  at  the  next  address  is  loaded  into  the  pipeline.  This  instruction 
code  is  then  executed  in  parallel  with  a load  of  the  instruction  code  at  the  branch 
destination  address  into  the  pipeline.  This  is  demonstrated  in  example  1 on  the 
following  page. 


2-6-1 


INSTRUCTION  EXECUTION 


(Example  1) 


BNE  FROG 
INC  R1 


FROG:  ADD  R2 

When  the  program  in  Example  1 is  executed,  the  INC  instruction  will  be  executed 
regardless  of  the  presence  of  a branch  instruction,  since  it  is  loaded  into  the  pipe- 
line while  processing  the  BNE  instruction. 

Note:  Be  especially  careful  when  placing  an  instruction  of  2 bytes  or  more  after 
an  instruction  that  changes  the  program  counter. 

(Example  2) 

BNE  LOP1 
BRA  LOP2 


LOP1 : TO  R1 

When  the  program  in  Example  2 is  executed,  the  program  jumps  to  LOP1  when 
the  Z flag  is  0,  but  the  first  byte  of  the  code  “BRA  LOP2”  has  already  been  loaded 
into  the  pipeline.  Therefore,  the  code  1 1 H at  the  jump  destination  “TO  R1”  will  be 
processed  as  the  offset  value  of  the  BRA  instruction,  causing  “BRA  ****’’  to  be  ex- 
ecuted instead  of  “TO  R1”. 

Note:  The  value  for  ****  = LOP1  +1  +1 1 H. 

In  this  situation,  a NOP  instruction  should  be  inserted  after  the  BNE  instruction,  as 
shown  below. 

(Example  3) 


BNE  LOP1 
NOP 

BRA  LOP2 


LOP1:  TO  R1 


2-6-2 


6.3  PROGRAM  COUNTER 


The  GSU  program  counter  is  assigned  to  R15.  When  the  value  for  R15  is 
changed  by  an  instruction,  the  program  jumps  to  the  address  indicated  by  that  val- 
ue. 

(Example  4) 

IWT  R0,#0010H 

IWT  R4,#0020H 

IWT  R15,#Address 

NOP 


Address:  ADD  R4 

INC  R3 

In  example  4,  the  program  jumps  to  the  specified  address  at  the  IWT  instruction 
on  the  third  line.  Due  to  pipeline  processing,  the  ADD  instruction  in  the  7th  line  will 
be  executed  after  the  NOP  instruction  in  the  4th  line  is  executed.  In  addition,  the 
address  following  the  instruction  currently  being  executed  can  be  identified  by 
moving  the  contents  of  R15  to  another  register. 

6.4  FLAG  PREFIXES 

In  the  GSU,  the  action  of  the  next  instruction  code  to  be  executed  varies  depend- 
ing upon  the  values  of  the  status  flags  (ALT1 , ALT2,  B),  set  by  instructions  such 
as  the  ALT  1 instruction. 

(Example  5) 

The  instruction  code  53H  will  perform  the  processing  shown  below  depending 
upon  the  values  for  ALT  1 and  ALT2. 


When  ALT1=0,  ALT2=0 

Sreg+R3— >Dreg 

(ADD  R3) 

When  ALT1=1,  ALT2=0 

Sreg+R3+CY-»Dreg 

(ADC  R3) 

When  ALT  1 =0,  ALT2=1 

Sreg+3— >Dreg 

(ADD  #3) 

When  ALT1=1 , ALT2=1 

Sreg+3+CY— >Dreg 

(ADC  #3) 

2-6-3 


INSTRUCTION  EXECUTION 


(Example  6) 

The  instruction  code  1 1 H will  perform  the  processing  shown  below  depending  on 
the  value  of  the  B flag. 

When  B=0  Set  Dreg  to  R1  (TO  R1) 

When  B=1  Sreg— >R1  (MOVERI.Rn  n=value for  Sreg) 

The  ALT  1 instruction  is  used  to  set  the  ALT  1 flag  to  1 . Likewise,  the  ALT  2 instruc- 
tion is  used  to  set  the  ALT2  flag  to  1 . The  ALT3  instruction  sets  both  the  ALT  1 flag 
and  ALT2  flag.  The  WITH  instruction  is  used  to  set  the  B flag. 

Normally,  the  flags  which  were  set  by  these  instructions  are  cleared  after  the  next 
instruction  is  executed.  The  flags  are  not  cleared  when  the  next  instruction  is  a 
FROM,  TO,  WITH,  ALT1,  ALT2,  ALT3,  or  a branch  instruction. 

For  instance,  since  the  TO  and  FROM  instructions  become  MOVE  and  MOVES 
instructions,  respectively;  when  the  B flag  is  set,  these  flags  will  be  cleared  after 
the  instructions  are  executed.  They  will  also  be  cleared  after  the  execution  of  a 
NOP  instruction. 

Since  ALT1 , ALT2,  and  ALT3  instructions  are  used  in  combination  with  the  next 
instruction,  they  do  not  need  to  be  thought  of  as  independent  instructions.  For  in- 
stance, there  is  no  need  to  be  specifically  aware  that  “if  ADD  R3  is  executed  after 
setting  the  ALT1  flag  with  an  ALT1  instruction,  the  instruction  becomes  ADC  R3”. 
The  process  can  simply  be  seen  as  the  two-byte  instruction  “ADC  R3”.  In  the  as- 
sembler, as  well,  it  is  normally  unnecessary  to  specifically  code  an  ALT  1 instruc- 
tion or  to  write  a MOVE  instruction  as  a WITH  instruction  and  a TO  instruction. 

However,  as  demonstrated  in  the  following  examples,  these  things  need  to  be 
kept  in  mind  when  accelerating  program  processing  by  effectively  using  the  pipe- 
line. 

(Example  7) 

IWT  R3,#100H 

LOP1:  ADC  RO  ; ALT1+ADD  RO 

PLOT 

DEC  R3 

BNE  LOP1 

NOP 


2-6-4 


SNES  DEVELOPMENT  MANUAL 


Due  to  pipeline  processing,  the  code  following  a branching  instruction  will  be  exe- 
cuted regardless  of  the  presence  of  a branch.  In  Example  7,  the  NOP  instruction 
after  the  BNE  instruction  will  always  be  executed,  but  this  program  can  be  substi- 
tuted as  demonstrated  below. 


(Example  8) 


NEWLOP1 : 


IWT 

R3,#100H 

ALT1 

ADD 

RO 

PLOT 

DEC 

R3 

BNE 

NEWLOP1 

ALT1 

In  this  example,  the  branch  destination  “ADC  RO”  is  divided  into  “ALT1”  and  “ADD 
RO”.  ALT  1 is  placed  after  BNE,  changing  the  address  of  the  branch  destination. 
Thus,  the  pipeline  code  at  the  time  of  the  branch  becomes  useful. 


2-6-5 


INSTRUCTION  EXECUTION 
1 


A different  situation  is  demonstrated  below. 

(Example  9) 

IWT  R3,#100H 

LOP2:  PLOT 

MOVE  R4,R5  ; WITH  R5+TO  R4 

DEC  R3 

BNE  LOP2 

NOP 

This  program  can  be  substituted  as  shown  in  Example  10. 

(Example  10) 

IWT  R3,#100H 

LOP2:  PLOT 

DEC  R3 

WITH  R5 

BNE  LOP2 

TO  R4 

In  example  10,  “MOVE  R4,R5”  is  split  into  “WITH  R5”  and  “TO  R4”.  This  kind  of 
rewrite  is  possible  because  the  B flag  is  not  changed  by  the  branch  instruction. 

6.5  REGISTER  PREFIXES 

Most  of  the  GSU  instructions  use  a source  register  (Sreg)  and  destination  register 
(Dreg).  The  Sreg  indicates  the  general  register  used  for  the  source  of  the  instruc- 
tion, while  the  Dreg  indicates  the  general  register  used  to  store  the  result.  The 
Sreg  and  Dreg  can  be  assigned  in  the  GSU  using  the  TO,  FROM  and  WITH  regis- 
ter prefix  instructions.  The  Sreg  is  assigned  using  the  FROM  instruction  and  the 
Dreg  using  the  TO  instruction.  The  Sreg  and  Dreg  can  both  be  assigned  using  the 
WITH  instruction.  The  Sreg  and  Dreg  return  to  the  default  R0  when  any  instruction 
other  than  TO,  FROM,  WITH,  ALT,  or  a branch  is  executed. 


2-6-6 


If  a TO  instruction  or  FROM  instruction  follows  a WITH  instruction,  as  demonstrat- 
ed below,  they  will  be  executed  as  MOVE  or  MOVES  instructions,  causing  Sreg 
and  Dreg  to  return  to  the  defaults  after  the  instructions  are  executed.  These  regis- 
ters also  return  to  the  defaults  after  a NOP  instruction  is  executed. 

(Example  11) 

The  program  used  to  execute  R3=R4-R5  is  as  follows. 

TO  R3 

FROM  R4 

SUB  R5 

The  operation  R0=R4-R5  can  be  performed  by  executing  the  following  program, 
omitting  the  TO  instruction. 

FROM  R4 

SUB  R5 

The  operation  R0=R0-R5  can  be  performed  using  the  following  program.  The 
FROM  instruction  is  omitted. 

SUB  R5 

After  a normal  instruction  has  been  executed,  with  the  exception  of  TO,  FROM, 
WITH,  ALT,  or  a branch,  Sreg  and  Dreg  are  both  assigned  the  default  register 
(RO).  Consequently,  in  the  following  program,  the  initial  SUB  instruction  will  exe- 
cute R3=R4-R5,  but  the  second  SUB  instruction  will  execute  R0=R0-R5. 

TO  R3 

FROM  R4 

SUB  R5 

SUB  R5 

The  WITH  instruction  not  only  assigns  Sreg  and  Dreg,  but  also  sets  the  B flag 
within  the  status/flag  register.  The  TO  and  FROM  instructions  act  as  different  in- 
structions when  the  B flag  is  set. 

• When  a TO  instruction  is  next,  it  performs  a MOVE  instruction  (instruction  to 
move  between  registers). 

• When  a FROM  instruction  is  next,  it  performs  a MOVES  instruction  (instruction 
to  move  between  registers  and  set  flags  according  to  the  data  loaded). 


2-6-7 


INSTRUCTION  EXECUTION 


6.6  LOOP 

The  LOOP  instruction  is  provided  for  efficient  loop  processing  in  the  GSU.  The 
LOOP  instruction  decrements  the  value  in  R12  by  1 and,  when  the  result  is  not  0, 
loads  the  address  in  R13  into  the  program  counter.  When  the  result  is  0,  the  next 
instruction  is  executed  without  branching. 

Consequently,  when  performing  loop  processing  using  the  LOOP  instruction,  it  is 
necessary  to  store  the  loop  count  number  in  R12  and  the  loop  return  destination 
address  in  R13. 

(Example  12) 

IWT 
IWT 
MOVE 

REPEAT: 

GETB 
INC 
LOOP 
PLOT 

6.7  SUBROUTINES 

The  GSU  does  not  have  any  instructions  for  making  subroutine  calls.  Therefore, 
when  using  a subroutine,  it  will  be  necessary  to  specify  the  return  destination  ad- 
dress in  the  program. 

(Example  13) 


A000 

FB  07  AO 

IWT 

R11,#RETURN 

A003 

FF  03  A1 

IWT 

R15,#SUB1 

;Jump  to  SUB1 

A006 

01 

NOP 

; Dummy 

A007 

DO  RETURN: 

INC 

R0 

; Return  Address 

A103 

96 

SUB1: 

ASR 

A104 

96 

ASR 

A105 

2B  IF 

MOVE  R15.R11 

; Return  to  Main  Routine 

A107 

01 

NOP 

;Dummy 

R14,#DATA  ;R14=ROM  Address  for  Read  Data 
R12,#0100H  ;R12=Loop  Count  Number 
R13.R15  ;R13=REPEAT  (Loop  Back  Address) 


R14 

;R12=R12-1 . IF  (R12<>0)  THEN  PC=R13 


2-6-8 


SNES  DEVELOPMENT  MANUAL 


In  Example  13,  the  program  jumps  to  the  subroutine  after  the  return  address  in 
R1 1 has  been  specified.  In  the  subroutine,  the  program  finally  returns  to  the  main 
program  by  loading  the  value  for  R1 1 to  the  program  counter  (R15). 

The  LINK  instruction  is  used  in  the  GSU  for  specifying  the  return  address.  LINK 
adds  a value  from  1 to  4,  depending  upon  the  operand,  to  the  address  of  the  in- 
struction following  LINK.  The  result  is  stored  in  R11. 

(Example  14) 

The  call  side  of  the  routine  in  Example  13  can  be  rewritten  as  follows  using  the 
LINK  instruction. 


A000 

94 

LINK 

#4 

;R1 1=A005 

A001 

FF  03  A1 

IWT 

R15,#SUB1 

;Jump  to  SUB1 

A004 

01 

NOP 

A005 

DO  RETURN: 

INC 

R0 

;Return  Address 

6.8  CACHE  RAM 

A 512-byte  instruction  cache  is  built  into  the  Super  FX.  Because  instruction  code 
is  read  six  times  as  fast  as  reading  from  game  pak  ROM  or  RAM,  a program  in 
cache  RAM  runs  at  high  speed.  If  a program  is  run  in  cache  memory,  access  to 
the  game  pak  ROM  or  RAM  can  be  performed  at  the  same  time  the  instruction  is 
executed.  Therefore,  a program  can  be  executed  at  a higher  speed. 

6.8.1  USING  CACHE  INSTRUCTIONS 

The  CACHE  instruction  is  used  to  control  the  cache.  If  the  CACHE  in- 
struction is  executed,  any  subsequent  instruction  codes  will  be  sequen- 
tially loaded  into  the  cache  RAM  whether  they  are  loaded  from  game  pak 
ROM  or  game  pak  RAM. 

For  instance,  if  the  CACHE  instruction  is  executed  immediately  prior  to 
loop  processing,  the  program  can  be  made  to  operate  in  the  cache  RAM 
beginning  with  the  second  repetition. 

Program  loops  exceeding  512  bytes  in  size  will  not  perform  efficiently 
since  the  portion  not  handled  in  cache  RAM  will  always  be  executed  in 
game  pak  ROM  or  game  pak  RAM.  Dividing  the  program  into  several 
loops  so  that  the  loops  fit  within  the  512  byte  limit  will  enable  higher 
speed  operation  when  the  CACHE  instruction  is  executed  immediately 
prior  to  these  loops. 


2-6-9 


INSTRUCTION  EXECUTION 


6.8.2  CACHE  OPERATION 

When  the  CACHE  instruction  is  executed,  the  beginning  address  for  data 
to  be  loaded  from  game  pak  ROM  or  RAM  to  cache  RAM  is  stored  in  the 
CBR  (cache  base  register).  The  cache  area  will  be  512  bytes  beginning 
with  the  address  stored  in  the  CBR.  The  512-byte  cache  area  is  further 
divided  into  32  blocks  of  16  bytes  each.  A “cache  flag”  is  assigned  to 
each  of  these  32  blocks. 

When  the  program  counter  indicates  the  cache  area,  the  cache  flag  that 
corresponds  with  that  address  is  read.  If  the  cache  flag  is  not  set,  the  in- 
structions are  loaded  to  cache  RAM  while  the  program  executes  in  game 
pak  ROM  or  RAM.  The  cache  flag  is  set  when  the  1 6-byte  block  has  been 
entirely  loaded  with  instruction  code.  If  the  cache  flag  has  already  been 
set,  the  program  is  executed  in  cache  RAM.  The  cache  flags  are  all  reset 
when  the  CACHE  instruction  is  executed. 

Since  the  low  4 bits  of  the  CBR  are  fixed  at  0,  the  beginning  address 
stored  in  the  CBR  after  execution  of  a CACHE  instruction  will  be  the  val- 
ue of  the  address  following  the  CACHE  instruction  with  its  low  4 bits  set 
to  0 (XXXOH).  If  the  low  4 bits  of  the  address  following  the  CACHE  in- 
struction are  other  than  0,  the  program  jumps  to  the  address  in  the  CBR 
and  loads  the  code  from  the  game  pak  ROM  or  RAM  into  the  cache  RAM, 
after  the  CACHE  instruction  is  executed. 

If  a branch  occurs  before  all  1 6 bytes  of  instruction  code  in  a block  can  be 
loaded  (before  the  cache  flag  is  set),  the  program  will  branch  after  the  re- 
maining instruction  code  in  that  block  has  been  entirely  loaded.  This  op- 
eration is  the  same  within  the  same  block.  If  the  program  has  branched  to 
an  address  other  than  the  block  header  address  (XXXOH),  the  code  be- 
tween the  block  header  address  and  the  branch  address  will  be  loaded 
before  the  instruction  at  the  branch  address  is  executed.  Refer  to  the  il- 
lustration on  the  following  page. 


2-6-10 


SNES  DEVELOPMENT  MANUAL 


Figure  2-6-1  Load  to  Cache  RAM  While  Branching 

Since  the  CBR  does  not  have  any  bank  information,  when  an  LJMP  in- 
struction is  executed,  all  cache  flags  are  cleared  and  the  CBR  is  reset  to 
a value  with  the  low  4 bits  of  the  jump  destination  address  at  0 (XXXOH). 
This  operation  is  the  equivalent  of  executing  another  CACHE  instruction. 

In  addition,  when  the  Super  NES  CPU  writes  a 0 to  the  GO  flag  of  the 
GSU's  status/flag  register  (a  forced  end  if  the  GSU  is  operating),  all  of  the 
cache  flags  are  cleared  and  the  CBR  value  is  set  to  0000H.  If  the  GSU  is 
stopped  by  a STOP  instruction,  the  contents  of  the  CBR,  cache  flags  and 
cache  RAM  are  all  saved.  Consequently,  when  the  GSU  is  restarted,  a 0 
must  be  written  to  the  GO  flag  to  reset  the  CBR  and  cache  flags. 


2-6-11 


INSTRUCTION  EXECUTION 
~1 


6.8.3  CACHE  RAM  ACCESS  FROM  THE  SUPER  NES 

It  is  possible  for  the  Super  NES  CPU  to  read  and  write  to  the  GSU's 
cache  RAM.  The  cache  RAM  is  divided  into  512-byte  addresses  from 
3100H  in  any  of  banks  00H-3FH  or  80H-BFH  in  the  Super  NES  memory 
map.  When  the  GSU  is  not  operating,  data  can  be  freely  read  and  written 
from/to  the  Super  NES  CPU. 

However,  the  CBR  does  not  necessarily  comply  with  address  3100H  in 
the  Super  NES  memory  map.  Caution  should  be  observed  when  reading 
cache  memory  contents  after  the  CACHE  instruction  has  been  executed. 
The  address  in  the  CBR  cache  RAM  complies  with  the  address  indicated 
by  the  value  of  the  low  9 bits  of  the  CBR.  Therefore,  the  CBR  address  on 
the  Super  NES  is  calculated  as  follows. 

CBR  address  on  Super  NES  = 3100H  + (CBR  AND  01FFH) 

When  cache  data  is  loaded  from  the  CBR  complied  address  to  32FFH, 
continuous  data  is  loaded  from  3100H  to  the  CBR  complied  address  mi- 
nus 1. 

For  example;  when  the  CBR  is  C3A0H, 

Instruction  Memory  Address  Super  NES  Complied  Address 

C3A0H-C3FFH  32A0H-32FFH 

C400H-C59FH  3100H-329FH 

When  writing  data  from  Super  NES  CPU  to  cache  RAM,  instructions 
must  be  written  in  16-byte  blocks.  If  data  are  written  only  part  way 
through  the  16  bytes,  the  flag  will  not  be  set  for  that  block.  In  this  case, 
the  GSU  will  process  as  though  cache  data  did  not  exist  in  that  block.  To 
set  the  cache  flag,  write  any  data  to  the  XXXFH  address  of  that  block. 

6.8.4  GSU  EXCLUSIVE  OPERATION  IN  CACHE  RAM 

By  activating  the  GSU  after  code  has  been  written  from  the  Super  NES 
CPU  to  the  cache  RAM,  it  is  possible  to  operate  the  program  exclusively 
in  cache  RAM.  The  CBR  value  is  stored  from  the  Super  NES  CPU  by  re- 
setting the  GO  flag.  This  causes  the  CBR  value  to  become  0000H.  The 
program  addresses  in  cache  are  normally  0000H  through  01FFH,  so  the 
GSU  is  activated  with  addresses  in  this  range  stored  in  the  program 
counter. 

Please  be  aware  that,  even  when  a STOP  instruction  is  executed,  the 
next  code  has  been  loaded  into  the  pipeline.  If  the  address  of  the  STOP 
instruction  is  XXXFH,  the  GSU  will  try  to  read  code  from  external  RAM 
unless  the  cache  flag  for  the  block  containing  the  next  address  (XXXOH) 
has  been  set. 


2-6-12 


SNES  DEVELOPMENT  MANUAL 


Chapter  7 Data  Access 

7.1  GAME  PAK  ROM  DATA 

The  GSU  uses  a function  called  the  “ROM  buffering  system”  as  a method  of  load- 
ing data  from  game  pak  ROM  during  program  execution.  Using  the  ROM  buffering 
system,  register  R14  is  assigned  as  the  address  pointer  to  game  pak  ROM.  When 
a value  is  set  in  register  R14,  the  game  pak  ROM  data  at  the  address  specified  by 
ROMBR  and  register  R14  are  loaded  to  an  internal  buffer  called  the  “ROM  buffer”. 

7.1 .1  GSU  PROGRAM  RUNNING  IN  CACHE  RAM  OR  GAME  PAK  RAM 

When  the  program  is  running  in  cache  RAM  or  game  pak  RAM,  game 
pak  ROM  data  can  be  loaded  in  parallel  with  the  execution  of  instructions. 
Therefore,  it  is  most  efficient  to  sandwich  several  instructions  between  an 
instruction  that  changes  R14  and  a GETB  instruction. 

Care  is  required  when  performing  the  following  operations  while  data  are 
being  loaded  into  the  ROM  buffer. 

• If  the  value  for  R14  is  updated,  the  initial  loading  process  is  interrupt- 
ed and  a new  loading  process  is  started. 

• If  a ROMB  instruction  is  fetched,  the  program  will  wait  until  the  data 
are  loaded  into  the  ROM  buffer.  The  ROMBR  value  will  be  changed 
after  data  is  loaded  and  program  execution  will  resume. 

• If  a GETB  or  similar  instruction  is  fetched,  the  program  will  pause 
while  the  data  is  loaded  into  the  ROM  buffer. 

In  the  following  examples,  it  is  presumed  that  the  program  is  being  exe- 
cuted in  cache  RAM  and  bit  0 of  the  CLSR  is  “1”  (Super  FX  operating  fre- 
quency is  21.4  MHz). 

CAUTIONS 

If  cache  instructions  are  executed  immediately  after  the  value  is  set  at 
R14,  while  the  program  is  running  on  cache  RAM,  the  proper  value  is  not 
read  to  the  ROM  buffer.  Please  use  caution  when  reading  data  from 
ROM. 

• During  21 .7  MHz  operation,  do  not  insert  a CACHE  instruction  during 
the  first  7 machine  cycles  after  an  instruction  that  changes  the  content 
of  R14. 

• During  10.7  MHz  operation,  do  not  insert  a CACHE  instruction  during 
the  first  4 machine  cycles  after  an  instruction  that  changes  the  content 
of  R14. 


2-7-1 


DATA  ACCESS 

zn 


(Example  1) 


Cycle 

Instruction 

Comment 

2 

MOVE 

R14,R1 

;Start  Fetching 

5 

GETB 

;Get  The  Byte  Into  RO 

1 

TO 

R1 

1 

FROM 

R2 

1 

ADD 

R3 

;Perform  R1=R2+R3 

1 

TO 

R4 

1 

FROM 

R5 

1 

ADD 

R6 

;Perform  R4=R5+R6 

1 

ADD 

R8 

;R0=R0+R8 

Fourteen  cycles  are  required  to  execute  the  program  in  the  previous  ex- 
ample. Since  RO  is  not  used  until  the  last  instruction,  the  GETB  instruc- 
tion can  be  moved  to  the  line  before  “ADD  R8”,  as  demonstrated  below. 

(Example  2) 


Cycle 

Instruction 

Comment 

2 

MOVE 

R14.R1 

;Start  Fetching 

1 

TO 

R1 

1 

FROM 

R2 

1 

ADD 

R3 

;Perform  R1=R2+R3 

1 

TO 

R4 

1 

FROM 

R5 

1 

ADD 

R6 

;Perform  R4=R5+R6 

1 

GETB 

;Get  The  Byte  Into  RO 

1 

ADD 

R8 

;R0=R0+R8 

Only  10  cycles  are  required  to  execute  this  program.  Read  timing  for 
game  pak  ROM  access  is  as  follows. 

• Operating  frequency  21 .4  MHz:  5 cycles 

• Operating  frequency  10.7  MHz:  3 cycles 

7.1 .2  GSU  PROGRAM  RUNNING  IN  GAME  PAK  ROM 

When  the  GSU  program  is  running  in  game  pak  ROM,  it  is  necessary  to 
use  the  ROM  buffering  system  even  when  loading  game  pak  ROM  data. 
The  instruction  following  a change  in  register  R14  will  not  begin  execution 
until  the  ROM  buffer  is  loaded. 


2-7-2 


SNES  DEVELOPMENT  MANUAL 


7.2  GAME  PAK  RAM  DATA 

The  GSU  uses  a function  called  the  “RAM  buffering  system”  as  a method  of  load- 
ing data  from  game  pak  RAM  during  program  execution.  Using  the  RAM  buffering 
system,  the  game  pak  RAM  address  and  data  to  be  written  are  moved  to  an  inter- 
nal buffer.  The  operation  of  writing  to  RAM  is  started  by  executing  a STB,  STW, 
SM,  SMS,  or  SBK  instruction. 

7.2.1  GSU  PROGRAM  RUNNING  IN  CACHE  RAM  OR  GAME  PAK  ROM 

When  the  program  is  running  in  cache  RAM  or  game  pak  ROM,  its  write 
data  will  be  written  to  game  pak  RAM  while  the  subsequent  program  is 
being  executed.  Therefore,  it  is  most  efficient  to  sandwich  several  instruc- 
tions between  STW  instructions. 

Care  is  required  when  performing  the  following  operations  while  writing  to 
game  pak  RAM. 

• Execution  of  a command  that  updates  the  register  which  was  used  as 
the  address  in  a STB  or  STW  instruction  will  have  absolutely  no  effect 
on  the  write  operation  to  game  pak  RAM  and  will  not  wait. 

• If  a RAMB  instruction  is  fetched,  the  program  will  wait  until  the  data 
are  written  to  game  pak  RAM.  The  RAMBR  value  will  be  changed  af- 
ter the  write  is  completed  and  execution  of  the  program  will  resume. 

• If  a STW  instruction  is  fetched,  the  program  will  wait  until  the  data  are 
written  to  game  pak  RAM. 

In  the  following  examples,  it  is  presumed  that  the  program  is  being  exe- 
cuted in  cache  RAM  and  bit  0 of  the  CLSR  is  “1  ” (Super  FX  operating  fre- 
quency is  21.4  MHz). 

(Example  3) 


Cycle 

Instruction 

Comment 

1 

FROM 

R8 

;Store  R8  Into  (RIO) 

1 

STW 

(RIO) 

10 

STW 

(R11) 

;Store  R0  Into  (R1 1) 

1 

TO 

R1 

1 

FROM 

R2 

1 

ADD 

R3 

;Perform  R1=R2+R3 

1 

FROM 

R5 

1 

ADD 

R6 

; Perform  R0=R5+R6 

2-7-3 


DATA  ACCESS 


Seventeen  cycles  are  required  to  execute  the  program  in  the  previous  ex- 
ample. Since  the  value  for  RO  is  not  changed  until  the  last  instruction,  the 
second  STW  instruction  can  be  moved  to  the  line  immediately  before  that 
instruction.  This  is  demonstrated  on  the  following  page. 

(Example  4) 


Cycle 

Instruction 

Comment 

1 

FROM 

R8 

1 

STW 

(RIO) 

;Store  R8  Into  (RIO) 

1 

TO 

R1 

1 

FROM 

R2 

1 

ADD 

R3 

;Perform  R1=R2+R3 

7 

STW 

(R11) 

;Store  RO  Into  (R1 1) 

1 

FROM 

R5 

1 

ADD 

R6 

;Perform  R0=R5+R6 

Only  14  cycles  are  required  to  execute  the  program  in  Example  4.  This  is 
more  efficient  that  Example  3,  a wait  period  of  2 cycles  is  still  required  to 
write  to  game  pak  RAM. 

7.2.2  GSU  PROGRAM  RUNNING  IN  GAME  PAK  RAM 

When  the  GSU  program  is  running  in  game  pak  RAM,  it  is  necessary  to 
use  the  RAM  buffering  system  described  above  even  when  writing  game 
pak  RAM  data.  The  instruction  following  a STB  or  similar  instruction  is  ex- 
ecuted after  completion  of  the  write  operation  to  game  pak  RAM. 

7.3  BULK  PROCESSING 

Normally  during  bulk  processing,  data  are  loaded  from  game  pak  RAM,  some  pro- 
cessing is  performed,  and  a process  is  executed  to  return  the  data  to  the  same 
address.  Waste  can  be  avoided  if  the  process  can  be  completed  without  having  to 
specify  the  address  in  RAM  a second  time. 

When  an  instruction  that  performs  a data  transfer  between  the  game  pak  RAM 
and  an  internal  register  is  executed  in  the  GSU,  the  game  pak  RAM  address  used 
in  that  instruction  will  be  stored  in  memory.  The  SBK  instruction  stores  the  RAM 
address  in  which  the  register  contents  are  stored.  Since  it  does  not  require  an  op- 
erand, it  can  be  executed  more  quickly  than  the  SM  or  SMS  instructions.  The  dif- 
ference is  demonstrated  in  the  following  two  examples. 


2-7-4 


SNES  DEVELOPMENT  MANUAL 


(Example  5) 

In  the  following  example  the  SBK  instruction  is  not  used.  In  this  case,  word  data 
have  been  read  from  game  pak  RAM  address  1234H,  the  register  contents  are  in- 


cremented,  and  again  written  to  1234H. 

Cycle 

Instruction 

Comment 

14 

LM  R0,(1234H) 

R0<— (1234H) 

1 

INC  RO 

R0<— RO+1 

4 

SM  (1234H),R0 

(1234H)<— RO 

Nineteen  cycles  are  required  to  execute  the  above  program.  If  the  SBK  instruction 
is  used,  the  following  occurs. 

(Example  6) 

Cycle 

Instruction  Comment 

14 

LM  R0,(1234H) 

RO*— (1234H) 

1 

INC  RO 

R0«— RO+1 

1 

SBK 

(1234H)«-R0 

In  this  example,  only  16  cycles  are  required, 
program  is  also  decreased. 

The  memory  required  to  handle  the 

2-7-5 


GSU  SPECIAL  FUNCTIONS 


Chapter  8 GSU  Special  Functions 

The  GSU  performs  various  special  functions  to  realize  high-speed  operations.  These 
functions  are  described  below. 

8.1  BITMAP  EMULATION 

Since  a character  mapping  system  is  used  with  the  Super  NES  PPU,  its  CPU  can 
not  efficiently  perform  processing  such  as;  placing  a point,  drawing  a line  or  paint- 
ing a plane  (bitmap  graphics).  Prior  to  display  on  the  screen,  this  data  must  be 
converted  to  character  data.  Thereby,  emulating  the  bitmap  data. 

The  GSU  is  equipped  with  functions  that  support  “Plot  Processing”.  These  func- 
tions, “place  a point  of  a specified  color  at  a specified  coordinate  position.”  Conse- 
quently; after  setting  the  screen  mode  (CMODE  instruction),  the  color  data 
(COLOR,  GETC  instructions),  and  the  X,Y  coordinates;  the  PLOT  instruction  is 
performed. 

In  this  manner,  the  GSU  converts  plotted  (bitmapped)  data  to  character  data 
which  can  be  utilized  by  the  Super  NES  PPU  and  writes  them  to  game  pak  RAM. 
In  order  to  be  displayed  on  screen,  character  data  produced  in  the  game  pak  RAM 
must  be  transferred  by  the  Super  NES  CPU  to  the  V-RAM  of  the  Super  NES. 

8.1.1  SET  SCREEN  MODE 

To  begin  GSU  plot  processing,  screen  mode  assignments  must  be  made. 
This  is  performed  using  the  screen  mode  register  (SCMR)  and  the  screen 
base  register  (SCBR).  The  plot  options  are  assigned  using  the  CMODE 
instruction. 

8.1 .1 .1  SCREEN  MODE  REGISTER  (SCMR) 

The  GSU  conversion  process  from  bitmapped  data  to  charac- 
ter data  requires  a screen  mode  selection.  This  determines 
how  the  characters  will  be  aligned  and  the  bit  mode  to  be  used. 
This  is  performed  by  assigning  a mode  to  the  SCMR  using  the 
Super  NES  CPU. 

The  GSU  has  4 modes.  A BG  character  array  may  be  selected 
with  screen  heights  of  128  dot,  160  dot  and  192  dot.  The  fourth 
mode  is  an  OBJ  character  array. 

The  character  data  conversion  processing  by  the  GSU  is  per- 
formed assuming  that  the  character  array  is  aligned  as  demon- 
strated in  the  following  figures  for  BG  128  dot,  BG  160  dot,  BG 
192  dot,  or  OBJ;  respectively.  Consequently,  when  the  con- 
verted data  are  used  as  BG  or  OBJ  character  data  for  the  Su- 
per NES,  it  is  necessary  to  assign  the  screen  mode  and  store 
the  screen  data  in  the  VRAM. 


2-8-1 


SNES  DEVELOPMENT  MANUAL 


256  DOT 


Figure  2-8-1  128  Dot  High  BG  Character  Array  (numbers  are  hexadecimal) 


256  DOT 


Figure  2-8-2  160  Dot  High  BG  Character  Array  (numbers  are  hexadecimal) 


256  DOT 


Figure  2-8-3  192  Dot  High  BG  Character  Array  (numbers  are  hexadecimal) 


2-8-2 


GSU  SPECIAL  FUNCTIONS 


Figure  2-8-4  OBJ  Character  Array  (numbers  are  hexadecimal) 


To  calculate  the  total  number  of  bytes  of  character  data  re- 
quired, the  following  formula  is  derived  from  the  bit  mode  and 
the  screen  height  and  width. 

Total  number  of  bytes  of  character  data  = 

(Number  of  dots  high/8)  X (Number  of  dots  wide/8)  X (8n) 


Number  of  vertical 

Number  of  horizontal 

r~Number  of 

characters 

characters 

|_bytes/char 

Where  n equals  the  number  of  bits  per  dot  (2,4,  or  8). 

8.1 .1 .2  SCREEN  BASE  REGISTER  (SCBR) 

The  start  address  of  the  area  in  game  pak  RAM  where  charac- 
ter data  will  be  handled  must  be  assigned  in  advance  from  the 
Super  NES  CPU.  This  information  is  stored  in  the  SCBR. 

The  start  address  is  calculated  using  the  following  formula. 
(Start  Address)  = 70:0000H+SCBRx400H 


2-8-3 


SNES  DEVELOPMENT  MANUAL 


For  example,  when  the  value  1 1 H is  stored  in  the  SCBR,  in  4- 
bit  mode,  with  a height  of  1 28  dots,  width  of  1 92  dots; 

(Start  Address)  = 70:0000H+1 1 Hx400H  = 70:4400H 

(Total  number  of  bytes  of  character  data) 

= (1 28/8)x(1 92/8)x(8x4)  = 3000H 

game  pak  RAM  addresses  70:4400H  through  70:73FFH  are 
used  for  the  character  data  area. 

8.1. 1.3  CMODE  INSTRUCTION 

The  CMODE  instruction  must  be  stored  in  the  plot  option  regis- 
ter (POR)  to  enable  the  PLOT  instruction  and  COLOR  or 
GETC  instructions  to  be  selected.  The  relationship  between 
plot  processing  and  the  CMODE  instruction  is  covered  in  more 
detail  under  “Plot  Function  and  CMODE”,  later  in  this  chapter. 

8.1 .2  SET  COLOR  (COLOR,  GETC) 

The  color  data  used  in  plot  processing  must  be  stored  in  the  GSU’s  color 
register  (COLR)  using  the  COLOR  instruction  or  the  GETC  instruction.  If 
the  COLOR  instruction  is  used,  the  value  for  the  source  register  is  stored, 
while  the  GETC  instruction  stores  the  value  for  the  ROM  buffer. 

8.1 .3  PLOT  PROCESSING  (PLOT) 

The  PLOT  instruction  plots  the  color  data,  stored  by  the  COLOR  or  GETC 
instruction,  to  the  X and  Y coordinates  stored  in  general  registers  Ri  and 
R2.  The  X coordinate  value  must  be  in  R-|  and  the  Y coordinate  value  in 
R2.  Color  data  plotted  by  the  PLOT  instruction  are  converted  to  character 
data  and  written  to  the  game  pak  RAM. 

Since  it  would  be  inefficient  to  perform  a direct  write  to  game  pak  RAM  for 
each  PLOT  instruction,  caching  is  performed  in  an  8-bit  (1  pixel)  x 8-bit 
memory  inside  the  GSU.  This  corresponds  with  the  1 vertical  pixel  x 8 
horizontal  pixel  blocks  into  which  the  screen  is  divided.  This  memory  is 
called  the  “pixel  cache”  and  the  blocks  that  are  cached  are  called  “char- 
acter blocks”. 

There  are  two  pixel  cache  memories  in  the  GSU.  The  color  data  pro- 
duced by  the  PLOT  instruction  is  cached  in  the  “primary  pixel  cache.” 
These  data  are  copied  to  the  “secondary  pixel  cache,”  then  written  from 
the  “secondary  pixel  cache”  to  game  pak  RAM.  Each  pixel  cache  has  an 
8-bit  flag  called  the  primary  and  secondary  bit-pend  flags.  These  indicate 
whether  or  not  the  color  data  in  each  pixel  cache  is  valid. 


2-8-4 


GSU  SPECIAL  FUNCTIONS 


When  the  PLOT  instruction  is  executed,  the  offset  address  of  game  pak 
RAM  where  color  data  are  written  is  calculated  from  the  value  in  bit  7 
through  bit  3 of  the  X coordinate  (Ri)  and  the  value  in  bit  7 through  bit  0 
of  the  Y coordinate  (R2).  These  values  are  held  in  the  GSU.  When  anoth- 
er PLOT  instruction  is  executed,  the  GSU  compares  the  new  coordinate 
values  to  those  stored.  If  the  coordinates  have  not  changed,  plotting  is 
performed  to  the  same  character  block  (stored  in  secondary  cache)  is 
written  to  game  pak  RAM. 

The  flow  of  GSU  plot  processing  will  be  demonstrated  below  using  two 
cases.  In  the  first  description,  the  character  block  which  was  stored  by 
the  previous  PLOT  instruction  is  to  be  written.  The  second  case  demon- 
strates plotting  to  a different  block. 

8.1. 3.1  PLOTTING  TO  SAME  CHARACTER  BLOCK 

Color  data  are  written  to  the  pixel  cache  and  the  corresponding 
bit-pend  flag  is  set.  When  all  of  the  bit-pend  flags  are  set  (all  8 
pixels  of  the  cache  block  have  been  written),  write  processing 
to  game  pak  RAM  is  performed  in  the  following  manner. 

First,  the  contents  of  the  primary  pixel  cache  and  the  primary 
bit-pend  flag  are  transferred  to  the  secondary  pixel  cache  and 
secondary  bit-pend  flag.  If  the  contents  of  the  secondary  pixel 
cache  are  in  the  process  of  being  written  to  the  game  pak 
RAM,  this  process  is  placed  in  WAIT  status  until  the  secondary 
pixel  cache  is  empty. 

After  transfer  processing,  all  of  the  primary  bit-pend  flags  are 
cleared.  Then  the  GSU  executes  the  instruction  following  the 
PLOT  instruction.  Since  the  primary  pixel  cache  can  be  used, 
the  next  instruction  could  be  a PLOT  instruction  without  requir- 
ing a WAIT  status.  Parallel  with  the  execution  of  the  next  in- 
struction, the  GSU  converts  the  color  data  in  the  secondary 
pixel  cache  into  character  data  and  writes  them  to  the  game 
pak  RAM. 

8.1 .3.2  PLOTTING  TO  A DIFFERENT  CHARACTER  BLOCK 

The  contents  of  the  primary  pixel  cache  and  the  primary  bit- 
pend  flag  are  transferred  to  the  secondary  pixel  cache  and  sec- 
ondary bit-pend  flag.  If  the  contents  of  the  secondary  pixel 
cache  are  in  the  process  of  being  written  to  the  game  pak 
RAM,  this  process  is  placed  in  WAIT  status  until  the  secondary 
pixel  cache  is  empty.  Thereafter,  color  data  are  written  to  the 
primary  pixel  cache  and  the  corresponding  bit-pend  flag  is  set. 

The  GSU  then  executes  the  instruction  following  the  PLOT  in- 
struction. Parallel  with  the  execution  of  this  instruction,  the 
GSU  converts  the  color  data  in  the  secondary  pixel  cache  to 
character  data  and  writes  it  to  game  pak  RAM. 


2-8-5 


SNES  DEVELOPMENT  MANUAL 


The  data  in  the  corresponding  character  block  are  read  from 
the  game  pak  RAM  and  converted  back,  while  the  color  data 
correspond  with  the  flags  which  are  not  set  in  the  secondary 
bit-pend  flag  are  set  in  the  secondary  pixel  cache.  The  GSU 
then  converts  the  color  data  in  the  secondary  pixel  cache  into 
character  data  and  writes  them  to  the  game  pak  RAM. 

Thus,  the  operation  of  writing  to  game  pak  RAM  using  two  pixel 
caches  can  be  performed  in  parallel  with  the  execution  of  in- 
structions, making  PLOT  processing  very  efficient.  In  addition, 
since  the  PLOT  instruction  increments  the  value  for  R1  after 
processing,  there  is  no  need  to  specify  coordinates  when  writ- 
ing the  pixels  continuously  toward  the  right. 

CAUTION 

Do  not  change  the  setting  of  the  screen  mode,  described  under 
“Set  Screen  Mode,”  during  plot  operations.  Also,  when  screen 
plot  processing  is  completed,  execute  the  RPIX  instruction  to 
write  all  of  the  data  contained  in  the  pixel  caches  to  the  game 
pak  RAM. 

(Example  1) 

The  following  program  is  executed  under  the  following  condi- 
tions. 

SCBR=00H,  Color  Mode=256,  and  Screen  Mode=BG  128 
dot  high 


IBT 

R1,#0 

IBT 

R2,#0 

;Set  the  plot  starting  coordinate  to  (0,0) 

IBT 

R0,#0 

CMODE 

; Reset  POR 

IBT 

R0,#15H 

COLOR 

PLOT 

PLOT 

;Load  15H  to  the  color  register 

PLOT 

;Plot  (0,0)  through  (2,0) 

IBT 

R0,#36H 

COLOR 

PLOT 

PLOT 

PLOT 

PLOT 

;Load  36H  to  the  color  register 

PLOT 

;Plot  (3,0)  through  (7,0) 

2-8-6 


GSU  SPECIAL  FUNCTIONS 


[ 


The  primary  pixel  cache  becomes  the  cache  RAM  for  the  char- 
acter block  from  coordinates  (0,0)  through  (7,0).  When  the  pro- 
gram is  executed,  the  following  values  are  stored  in  the  primary 
pixel  cache  and  the  primary  bit-pend  flag. 


Primary  Bit-pend  Flag 


LAl  i/i/i 

7JZT7T7T7\ 

□ 

□ 

□ 

□ 

□ 

□ 

□ 

u 

/ 1 5/15/1 5/36/  36/  36/  36/36/ 


GAME  PAK 
RAM  ADDRESS 


(70:0031) 
(70:0030) 
(70:0021) 
. (70:0020) 
(70:0011) 
(70:0010) 
(70:0001) 
(70:0000) 


Since  all  8 pixels  in  a character  block  are  set  with  the  final 
PLOT  instruction,  they  are  transferred  from  the  primary  pixel 
cache  to  the  secondary  pixel  cache  and  the  game  pak  RAM 
write  begins.  This  process  clears  the  primary  bit-pend  flags  and 
the  primary  pixel  cache  is  released. 

(Example  2) 

Continuing  from  Example  1,  the  following  program  is  executed. 


IBT  R0,#4AH 

COLOR 

;Load  4AH  to  the  color  register 

PLOT 

PLOT 

PLOT 

PLOT 

;Plot  (8,0)  through  (1 1 ,0) 

IBT  R1,#10H 

;Change  X coordinate  to  16 

PLOT 

;Plot  (16,0) 

2-8-7 


SNES  DEVELOPMENT  MANUAL 


The  primary  pixel  cache  becomes  the  cache  for  the  character 
data  from  coordinates  (8,0)  through  (15,0).  Immediately  after 
the  4th  PLOT  instruction  is  executed,  the  primary  pixel  cache 
and  primary  bit-pend  flags  are  as  shown  below. 


Primary  Bit-pend  Flag 


/1/1/1/1/o/o/o/Q/l 

□ 

□ 

□ 

□ 

□ 

□ 

□ 

u 

Primary 

Pixel 

Cache 


/wwWwTT// 


Since  the  last  PLOT  instruction  writes  to  a different  character  block,  RAM 
write  processing  is  performed.  First,  a transfer  is  performed  from  the  pri- 
mary pixel  cache  and  primary  bit-pend  flag  to  the  secondary  pixel  cache 
and  secondary  bit-pend  flag.  Then,  game  pak  RAM  write  processing  is 
performed,  but  the  pixels  in  the  secondary  pixel  cache  which  have  not 
been  plotted  are  written  after  a game  pak  RAM  read  operation  has  been 
executed. 


GAME  PAK 
RAM  ADDRESS 


/1/1/1/1/1/1/1/ 1 /I 

□ 

□ 

□ 

□ 

□ 

□ 

□ 

u 

(70:00B1) 

(70:00B0) 

(70:00A1) 

(70:00A0) 

(70:0091) 

(70:0090) 

(70:0081) 

(70:0080) 


F0 


E6 


E0 


/( 

T/i 

571 

57^ 

TZsTn 

0 

0 

> 

- 

Fn 

/ 1 

/ i 

/ 1 

/ 1 

A 

A 

/ 0 

/ 0/, 

fin  L 

07 

07 

07 

07 

0/ 

0/ 

0/ 

07/ 

fin 

ZJ 

5/1 

T/i 

Tp 

UJZTTTTrAfr, 

FF  , 

A 

j 1 

/ 1 

j 1 

A 

/O 

A 

/0 

7/of 

wi 

0/ 

o7 

o7 

o~7 

07 

0/ 

0/ 

07 

/F0 

r\r\ 

L9_ 

ZO 

m 

Zo 

70 

UU 

□ 

M 

/no 

/0Q~ 

F0 


/WOT 4A/1 0/ 1 2/ 1 2/ 1 0/ 


(70:00B1) 

(70:00B0) 

(70:00A1) 

(70:00A0) 

(70:0091) 

(70:0090) 

(70:0081) 

(70:0080) 


2-8-8 


GSU  SPECIAL  FUNCTIONS 


8.1. 3.3  RPIX  INSTRUCTION 

The  RPIX  instruction  reads  the  character  block  containing  the 
specified  coordinates  from  game  pak  RAM  into  the  pixel  cache 
and  performs  processing  to  calculate  the  pixel  values  after  the 
contents  of  the  pixel  cache  have  been  written  to  the  game  pak 
RAM.  When  the  screen  drawing  routine  is  complete,  it  is  advis- 
able to  execute  the  RPIX  instruction  to  insure  that  all  of  the 
PLOT  data  have  been  written. 

If  consecutive  RPIX  instructions  are  executed,  game  pak  RAM 
read  data  processing  will  always  be  performed  because  the  in- 
struction does  not  discern  whether  or  not  there  are  color  data 
at  the  specified  coordinates  in  the  pixel  cache. 

CAUTION 

Even  when  consecutive  RPIX  instructions  read  color  data  from 
the  same  character  block,  data  will  always  be  read  from  the 
game  pak  RAM. 

8.1 .4  PLOT  FUNCTION  AND  CMODE 


The  CMODE  instruction  is  used  to  determine  how  the  color  register  value 
will  be  handled  by  the  PLOT  instruction.  The  modes  which  can  be  speci- 
fied with  CMODE  are  shown  in  the  table  below. 


BIT 

Flag  Name 

Operation 
when  0 

Operation 
when  1 

Related 

Instructions 

0 

T ransparent 
Flag 

Do  not  PLOT 
color  0 

PLOT  color  0 

PLOT 

1 

Dither  Flag 

PLOT  value 
of  low  4 
bits  of  color 
register 

Alternately 
PLOT  hign  4 
bits  and  Tow 
4 bits  of 
color 
register 

PLOT 

2 

High  Nibble 
Flag 

Set  value  of 
low  4 bits 
in  color 
register 

Set  value  of 
high  4 bits 
in  color 
register 

COLOR, 

GETC 

3 

Freeze  High 
Nibble  Flag 

Set  all  8 
bits  in 
color 
register 

Set  only  low 
4 bits  in 
color 

register  with 
high  4 bits 
fixed 

COLOR, GETC, 
PLOT 

4 

OBJ  Mode 
Flag 

Set  mode 
with  SCMR 
(ht0,ht1) 

OBJ  mode 

PLOT,  RPIX 

Table  2-8-1  Functions  of  CMODE 


2-8-9 


SNES  DEVELOPMENT  MANUAL 


The  PLOT  instruction  is  related  to  bit  3,  but  it  is  also  used  during  PLOT 
processing  for  selecting  the  number  of  bits  to  be  used  (0=8  Bit,  1 =4  Bit) 
for  transparent  processing. 

8.1. 4.1  BITO 

The  Super  NES  has  multiple  hardware  BG  screens.  When  one 
BG  screen  is  laid  over  another  BG  screen,  the  0 portions  of  the 
color  in  the  top  BG  screen  become  “transparent”  and  the  colors 
of  the  bottom  BG  are  displayed.  The  GSU  uses  color  mode  0 to 
perform  this  function. 

When  Bit  0=0  and  all  of  the  effective  COLR  bits  are  0,  the 
PLOT  circuit  refreshes  only  the  X coordinate  and  no  PLOT  op- 
eration is  performed.  Normal  PLOT  operation  is  performed  for 
anything  other  than  0. 

8.1. 4.2  BIT  1 

When  the  number  of  colors  that  can  be  displayed  at  once  is  low 
(16  color  mode),  techniques  can  be  used  to  apparently  in- 
crease the  number  of  colors  through  dither  processing.  The 
GSU  is  able  to  process  this  with  extreme  ease.  The  example 
below  demonstrates  the  difficulties  encountered  when  this 
function  is  not  used. 

(Example  3) 

Routine  for  drawing  a horizontal  line  of  a specified  length  from 
a specified  coordinate  using  two  alternating  specified  colors. 

R1:Start  X position 
R2:Start  Y position 
R3:Color  1 
R4:Color  0 
R12:Line  length 


MOVE 

R13.R15 

;Set  LOOP  return  address. 

;LOOP  return  address 

FROM 

R1 

XOR 

R2 

AND 

#1 

;Execute  [R0=(R1  XOR  R2)And  1]. 

BNE 

DOPLOT 

FROM 

R3 

;When  not  zero,  set  R3  (color  1)  to  Sreg. 

FROM 

R4 

;When  zero,  set  R4  (color  0)  to  Sreg. 

DOPLOT:  COLOR 
PLOT 
LOOP 
NOP 

;Set  value  of  Sreg  in  COLR. 

2-8-10 


GSU  SPECIAL  FUNCTIONS 


Thus,  if  only  the  plotting  functions  are  used,  it  takes  time  to  de- 
termine which  of  the  two  colors  to  PLOT  at  a specified  time. 
The  bit  1 dither  flag  may  be  used  to  efficiently  perform  this  type 
of  drawing  process.  The  dither  mode  is  only  functional  in  4 col- 
or mode  and  16  color  mode. 

When  dither  mode  is  set,  the  PLOT  circuit  checks  the  bit  0 val- 
ue of  the  result  when  an  XOR  operation  is  performed  on  R1  (X 
coordinate)  and  R2  (Y  coordinate).  If  the  resultant  bit  0=0,  the 
low  4 bits  of  the  COLR  register  are  used  as  the  color  data  for 
the  PLOT  instruction.  However,  if  the  resultant  bit  0=1 , the  high 
4 bits  of  the  COLR  register  are  used. 

When  the  program  in  the  previous  example  is  written  using  the 
CMODE  instruction,  only  the  PLOT  instruction  is  looped,  as 
demonstrated  below. 


(Example  4) 

IBT 

CMODE 

R0,#2 

;Set  to  transparent  and  dither  mode. 

FROM 

R3 

ADD 

R3 

ADD 

R0 

ADD 

R0 

ADD 

RO 

;Shift  low  4 bits  of  COLOR1  to  high  4 bits 

ADD 

R4 

;Add  value  of  R4  (COLORO)  to  RO. 

COLOR 

MOVE 

R13,R15 

;Set  COLR. 

;LOOP  return  address 
LOOP 

PLOT  ;Plot  pixel. 

Since  the  processing  to  determine  whether  or  not  a color  is 
transparent  is  performed  in  parallel  with  the  generation  of  plot 
data,  dithering  cannot  be  performed  between  a transparent  col- 
or and  a normal  color.  This  mode  can  also  be  used  in  the  4 col- 
or mode. 

8.1. 4.3  BIT  2 

To  efficiently  perform  rotation/enlargement/reduction  of  OBJ 
data,  a system  is  used  in  which  each  pixel  of  color  data  is 
stored  at  one  address.  When  displaying  a 16  color  OBJ,  half  of 
the  memory  is  wasted  using  this  method.  Memory  may  be  con- 
served by  storing  two  pixels  of  color  data  together  in  one  byte. 
However,  this  requires  a method  for  extracting  two  pixels  of 
color  data  from  one  byte  of  data.  Bit  2 of  CMODE  is  used  by 
the  GSU  to  perform  this  function. 


2-8-11 


SNES  DEVELOPMENT  MANUAL 


When  the  COLOR  or  GETC  instruction  is  executed  with  bit  2 of 
CMODE  set,  the  high  4 bits  of  the  source  register  are  written  to 
the  color  register.  If  different  OBJ  data  are  stored  in  the  high  4 
bits  and  low  4 bits  of  the  same  memory  area,  this  function  per- 
mits the  packed  8-bit  data  to  be  used  without  shift  processing. 
This  mode  can  also  be  used  in  4 color  mode. 

8.1. 4.4  BIT  3 

If  the  COLOR  or  GETC  instruction  is  executed  in  256  color 
mode  with  bit  3 of  CMODE  set,  only  the  low  4 bits  of  the  COLR 
register  can  be  written  to  the  color  register.  The  high  4 bits  are 
fixed.  This  function  enables  the  high  4 bits  of  the  color  register 
to  be  used  in  place  of  a palette  in  256  color  mode.  In  other 
words,  characters  of  different  colors  can  be  drawn  by  plotting 
16  color  mode  data  while  changing  the  value  of  the  high  4 bits 
of  the  color  register. 

8.1. 4.5  BIT  4 

When  bit  4 of  CMODE  is  set,  the  mode  which  enables  charac- 
ter data  to  be  produced  for  OBJ.  When  this  bit  is  0,  the  mode  is 
specified  by  HT0,HT  1 of  the  SCMR.  When  switching  the  OBJ 
mode  by  changing  this  bit,  it  will  be  necessary  to  use  the  RPIX 
instruction  to  write  the  data  to  the  game  pak  RAM  which  have 
already  been  written  to  the  pixel  caches. 


2-8-12 


GSU  SPECIAL  FUNCTIONS 


COLOR  Instruction  Bit  3 
GETC  Instruction  i 


Write  inhibited 
by  Bit  3 


COLOR 

REGISTER 


PLOT  instruction  processing: 
Generates  plot  data 


Z is  the  source  register 
for  the  COLOR  instruction, 
ROM  buffer  value  for  GETC 
instruction. 


COLR[7:4} 


1 

i 

i 

i ^ 

1 

0 

i 

n 

\J 

SELECT 

1 — ► 

i 

i 

i 

SELECT 

4/1 6 Color 
Mode 


Bit  0 of  R1 

"h-ff 

Bit  0 of  R2 

El 

Z[7:4]  is  a symbol  that 
shows  the  data  in  bit  7 
through  bit  4 of  Z. 


PLOT  Instruction  Processing 
Transparent  Mode  Processing 


Figure  2-8-5  Plot  Operations  Assigned  by  CMODE 


2-8-13 


SNES  DEVELOPMENT  MANUAL 


8.1 .5  PLOT  DATA  ADDRESS  CALCULATION  METHODS 

The  addresses  to  which  plot  data  are  written  are  determined  using  the 
following  data. 

• X and  Y coordinates  are  specified  by  the  low  bytes  of  Ri  and  R2. 

• The  screen  color  mode  and  height  mode  are  specified  by  the  SCMR. 

• SCBR 

The  following  examples  demonstrate  the  method  of  calculating  this  ad- 
dress. In  the  calculations  below,  “X[7:3]”  indicates  the  value  of  bit  7 
through  3 for  the  value  of  X.  The  expression  “X4,”  indicates  the  value  of 
bit  4 for  X. 

1 . Calculate  the  character  number  (CN)  containing  the  specified  co- 
ordinates. CN  is  the  value  of  SC  data  in  the  character  arrays  previ- 
ously described. 


(a)  Height,  128  Dot  Mode 

CN  [9:0]  = (X[7:3]  x 10H)  + Y[7:3] 


X7 

X6 

X5 

X4 

X3 

+ 

Y7 

Y6 

Y5 

Y4 

Y3 

CN9 

CN8 

CN7 

CN6 

CN5 

CN4 

CN3 

CN2 

CN1 

CNO 

(b) 

Height,  1 64  Dol 

t Mode 

CN  [9:0] 

= (X[7:3]  x 14H)  + Y[7 

:3] 

X7 

X6 

X5 

X4 

X3 

X7 

X6 

X5 

X4 

X3 

+ 

Y7 

Y6 

Y5 

Y4 

Y3 

CN9 

CN8 

CN7 

CN6 

CN5 

CN4 

CN3 

CN2 

CN1 

CNO 

(c) 

Height,  192  Dot 

Mode 

CN  [9:0] 

= (X[7:3]  x 18H)  + Y[7:3] 

X7 

X6 

X5 

X4 

X3 

X7 

X6 

X5 

X4 

X3 

+ 

Y7 

Y6 

Y5 

Y4 

Y3 

CN9 

CN8 

CN7 

CN6 

CN5 

CN4 

CN3 

CN2 

CN1 

CNO 

2-8-14 


GSU  SPECIAL  FUNCTIONS 


(d)  OBJ  Mode 

CN  [9:0]  = (Y[7]  x 200H)  + (X[7]  xIOOH)  + (Y[6:3]  x 10H)  + Y[6:3] 

X7  X6  X5  X4  X3 

+ Y7  Y6  Y5  Y4  Y3 

CN9  CN8  CN7  CN6  CN5  CN4  CN3  CN2  CN1  CNO 

2.  The  addresses  to  be  written  to  are  then  calculated  as  follows. 

A[19:0]  = (CN[9:0]  x CHAR_SIZE) 

+ (SB[7:0]  x 4000H) 

+ (Y[2:0j  x 2) 

+ (PL[2]  x 200H)  + (PL[1  ] x 100H)  + PL[0] 

Where  CHAR_SIZE  is  the  number  of  bytes  used  for  one  character. 
This  is  16  bytes  for  4 color  mode,  32  bytes  for  16  color  mode,  and 
64  bytes  for  256  color  mode.  The  expression  “PL[2:0]  indicates  a 
plane  number.  The  expression  “SB[7:0]”  indicates  the  value  stored 
at  the  SCBR.  The  following  examples  demonstrate  this  calcula- 
tion. 

(a)  4 Color  Mode 

SB7  SB6  SB5  SB4  SB3  SB2  SB1  SBO 

CN9  CN8  CN7  CN6  CN5  CN4  CN3  CN2  CN1  CNO 

Y2  Y1  Y0 

PLO 


A19 

A18 

A17 

A16 

A15 

A14 

A13 

A12 

All 

A10 

A9 

A8 

A7 

A6 

A5 

A4 

A3 

A2 

A1 

AO 

(b)  16  Color  Mode 

SB7 

SB6 

SB5 

SB4 

SB3 

SB2 

SB1 

SBO 

+ 

CN9 

CN8 

CN7 

CN6 

CN5  CN4  CN3  CN2  CN1  CNO 

PL1 

Y2 

Y1 

Y0 

PLO 

A19 

A18 

A17 

A16 

A15 

A14 

A13 

A12 

All 

A10 

A9 

A8 

A7 

A6 

A5 

A4 

A3 

A2 

A1 

AO 

(c)  256  Color  Mode 

SB7 

SB6 

SB5 

SB4 

SB3 

SB2 

SB1 

SBO 

+ 

CN9 

CN8 

CN7 

CN6 

CN5 

CN4  CN3  CN2  CN1 

CNO 

PL2 

PL1 

Y2 

Y1 

Y0 

PLO 

A19 

A18 

A17 

A16 

A15 

A14 

A13 

A12 

All 

A10 

A9 

A8 

A7 

A6 

A5 

A4 

A3 

A2 

A1 

AO 

2-8-15 


SNES  DEVELOPMENT  MANUAL 


8.2  MULTIPLICATION  INSTRUCTIONS 

The  4 multiplication  instructions  shown  below  are  available  in  the  GSU. 


MULT 

Signed  8 bits 

X 

Signed  8 bits 

— > Signed  16  bits 

instruction 

Low  8 bits  of 

Low  8 bits  of 

Dreg 

Sreg 

operand 

UMULT 

Unsigned  8 bits 

X 

Unsigned  8 bits 

— > Unsigned  16  bits 

instruction 

Low  8 bits  of 

Low  8 bits  of 

Dreg 

Sreg 

operand 

LMULT 

Signed  16  bits 

X 

Signed  16  bits 

— > Signed  32  bits 

instruction 

Sreg 

R6 

High  Dreg  Low  R4 

FMULT 

Signed  1 6 bits 

X 

Signed  16  bits 

—¥  Signed  32  bits 

instruction 

Sreg 

R6 

High  Dreg 

There  is  an  8 bit  x 8 bit  multiplier  built  into  the  GSU.  Since  this  multiplier  is  used 
only  once  with  the  MULT  and  UMULT  instructions,  these  instructions  can  be  exe- 
cuted at  high  speed.  A 16  bit  x 16  bit  answer  is  calculated,  for  the  LMULT  and 
FMULT  instructions,  by  performing  an  8 bit  x 8 bit  multiplication  4 times. 

The  execution  speed  of  each  multiplication  instruction  can  be  changed  using  bit  5 
of  the  CFGR.  Normally,  the  standard  speed  mode  (bit  5=0)  is  used.  When  the  Su- 
per FX  operates  at  10.7  MHz  (when  bit  0 of  the  CLSR  is  “0”),  the  high  speed  mode 
(bit  5=1)  can  be  used. If  R4  is  specified  as  the  destination  register  with  the  LMULT 
instruction,  the  high  16  bits  of  the  operation  results  are  stored  in  R4. 

CAUTION 

If  R4  is  specified  as  the  destination  register  with  the  FMULT  instruction,  the  oper- 
ation results  will  not  be  stored  in  R4  and  the  results  will  be  lost.  Do  not  specify  R4 
as  the  destination  register  for  the  FMULT  instruction. 

8.2.1  INTERNAL  PROCESSING  OF  FMULT  AND  LMULT 

For  LMULT  and  FMULT  instructions,  16  bit  x 16  bit  multiplication  is  per- 
formed by  repeating  an  8 bit  x 8 bit  multiplication  circuit  whose  signed 
and  unsigned  numbers  could  both  be  present  4 times.  The  processing 
flow  for  the  FMULT  and  LMULT  instructions  is  explained  below.  The 
FMULT  and  LMULT  instructions  share  the  circuit,  but  notice  that  there 
are  processes  that  can  only  be  performed  by  the  LMULT  instruction. 

Initially,  an  18  bit  buffer  used  to  hold  the  partial  results  during  multiplica- 
tion, called  the  partial  product  buffer,  is  cleared. 

The  first  multiplication  is  performed. 

Low  8 bits  of  Sreg  (unsigned)  x Low  8 bits  of  R6  (unsigned) 

— > 16  bit  result  (unsigned) 


2-8-16 


GSU  SPECIAL  FUNCTIONS 


The  high  8 bits  of  the  result  are  stored  in  the  low  8 bits  of  the  partial  prod- 
uct buffer.  For  LMULT,  the  low  8 bits  of  the  result  are  stored  in  the  low  8 
bits  of  R4. 

The  second  multiplication  is  performed. 

High  8 bits  of  Sreg  (signed)  x Low  8 bits  of  R6  (unsigned) 

— > 16  bit  result  (signed) 

The  result  is  expanded  to  18  bits  with  the  sign  and  added  to  the  partial 
product  buffer. 

The  third  multiplication  is  performed. 

Low  8 bits  of  Sreg  (unsigned)  x High  8 bits  of  R6  (signed) 

— > 1 6 bit  result  (signed) 

The  result  is  expanded  to  18  bits  with  the  sign  and  added  to  the  partial 
product  buffer.  For  LMULT,  the  low  8 bits  of  the  partial  product  buffer  are 
further  stored  in  the  high  8 bits  of  R4. 

The  fourth  multiplication  is  performed. 

High  8 bits  of  Sreg  (signed)  x High  8 bits  of  R6  (signed) 

-4  16  bit  result  (signed) 

The  result  (16  bits)  is  added  to  the  high  10  bits  of  the  partial  product  buff- 
er. For  LMULT  if  the  Dreg  is  R4,  the  value  in  the  partial  product  buffer  is 
stored  in  R4.  If  the  Dreg  is  not  R4,  the  value  of  the  partial  product  buffer  is 
stored  in  the  Dreg. 

If  R4  is  specified  as  the  destination  register  for  the  LMULT  instruction 
when  performing  the  above  processing,  the  high  16  bits  of  the  operation 
result  will  be  stored  in  R4.  However,  if  R4  is  specified  as  the  destination 
register  for  the  FMULT  instruction,  the  operation  result  will  not  be  stored 
as  the  value  for  R4. 


2-8-17 


SNES  DEVELOPMENT  MANUAL 


Chapter  9 Description  of  Instructions 

This  chapter  provides  a detailed  description  of  each  instruction  and  its  function.  ROM 
and  RAM  execution  times  listed  for  each  instruction  refer  to  the  game  pak  ROM  and 
RAM.  Special  indicators  and  symbols  are  used  throughout  this  chapter.  These  are  de- 
fined in  the  following  3 tables. 

9.1  OPERAND  DESCRIPTIONS 


INDICATOR 

DESCRIPTION 

Ro 

Indicates  internal  register  R0. 

Rn 

A 1 6-bit  general  use  register. 

Rn 

A 1 6-bit  general  use  register. 

(Rm) 

Indicates  the  value  stored  in  the  memory  location  specified  by 
the  contents  of  register  Rm. 

(XX) 

Indicates  the  value  stored  in  the  memory  location  specified  by 
the  16-bit  value  xx. 

(yy) 

Indicates  the  value  stored  in  the  memory  location  specified  by 
the  9-bit  value  yy.  (0<yy<510) 

#n 

Indicates  4-bit  immediate  data. 

#xx 

Indicates  16-bit  immediate  data.  (0<xx<65535) 

#pp 

Indicates  8-bit  immediate  data.  (-128<pp<127) 

e 

1-byte  data  -128<e<127,  that  expresses  the  displacement  in 
the  relative  addressing  mode. 

9.2  FLAG  DESCRIPTIONS 


SYMBOL 

DESCRIPTION 

1 

Set 

0 

Reset 

★ 

Set  or  reset  according  to  results. 

- 

No  change 

2-9-1 


DESCRIPTION  OF  INSTRUCTIONS 


9.3  OPERATOR  FUNCTIONS 


INDICATOR 

DESCRIPTION 

Ro 

Indicates  internal  register  R0. 

Rn> 

A 16-bit  general  use  register  specified  by  n. 

(Rm) 

Indicates  a value  stored  in  a memory  location  specified  by  the 
contents  of  register  Rm. 

(XX) 

Indicates  a value  stored  in  a memory  location  specified  by  the 
1 6-bit  value  xx. 

(yy) 

Indicates  a value  stored  in  a memory  location  specified  by  the 
9-bit  value  yy. 

#n 

Indicates  4-bit  immediate  data. 

#xx 

Indicates  16-bit  immediate  data.  (0<xx<65535) 

#pp 

Indicates  8-bit  immediate  data.  (-128<pp<127) 

e 

1-bit  data  (-128<e<127),  that  expresses  displacement  in  the 
relative  addressing  mode. 

Sreg 

Source  register 

^reg 

Destination  register 

Hiah-Byte 

Upper  byte  of  16-bit  data 

Low-Bvte 

Lower  bvte  of  1 6-bit  data 

— > 

Indicates  direction  of  movement  of  data 

+ 

Add 

- 

Subtract 

★ 

Multiply 

Rn,  #n 

1’s  compliment 

ALT1 

ALT1  Flag 

ALT2 

ALT2  Flag 

CY 

Carry  Flag 

ON 

Overflow  Flag 

Z 

Zero  Flag 

s 

Sign  Flag 

B 

B Flag 

GO 

Go  Flag 

2-9-2 


SNES  DEVELOPMENT  MANUAL 


9.4  ADC  Rn 

Operation:  Sreg  + Rn  + CY  Flag  — > Dreg  (n=0~15) 

Description:  This  instruction  adds  the  source  register,  the  operand,  and  the 

carry  flag.  The  result  is  stored  in  the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  any  of  registers  Ro~Ri5- 


Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

* 

★ 

* 

★ 

Opcode: 


ADC  Rn 


B:  Reset 

ALT  1 : Reset 

ALT2:  Reset 

ON:  Set  on  signed  overflow. 

S:  Set  if  result  is  negative,  else  reset 

CY:  Set  on  unsigned  carry,  else  reset 

Z:  Set  if  result  is  zero. 


(MSB)  (LSB) 

(3DH) 
(5nH) 


0 

0 

1 

1 

1 

1 

0 

1 

0 

1 

0 

1 

n (OH-FH) 

Machine  Cycles: 

ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  ADC 

Ri 

I Rq+R-j+CY — >R0 

WITH 

r2 

; Set  the  source/destination  registers  to  R; 

ADC 

r3 

; R2+R3+CY — >R2 

ADC 

R2 

I R0+R2+CY — >R0 

2-9-3 


DESCRIPTION  OF  INSTRUCTIONS 


9.5  ADC  #n 

Operation:  Sreg  + #n  + CY  Flag  — > Dreg  (n=0~15) 

Description:  This  instruction  adds  the  source  register,  the  immediate  data 

specified  by  the  operand  #n,  and  the  carry  flag.  The  result  is 
stored  in  the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  immediate  data  from  0~15. 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

★ 

* 

★ 

★ 

B:  Reset 

ALT  1 : Reset 

ALT2:  Reset 

O/V:  Set  on  signed  overflow. 

S:  Set  if  result  is  negative,  else  reset 

CY:  Set  on  unsigned  carry,  else  reset 

Z:  Set  if  result  is  zero,  else  reset. 


Opcode: 

ADC  #n 


(MSB) 


(LSB) 


0 

0 

1 

1 

1 

1 

1 

1 

0 

1 

0 

1 

n (0H~ 

FH) 

(3FH) 

(5nH) 


Machine  Cycles: 

ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  ADC 

#9H 

; R0+0009H+CY->R0 

FROM 

r3 

; Set  the  source  register  to  R 

ADC 

#5H 

I R3+OOO5H+CY — »R0 

ADC 

#0AH 

; Rq+OOOAH+CY— >R0 

2-9-4 


SNES  DEVELOPMENT  MANUAL 


9.6  ADD  Rn 

Operation:  Sreg  + Rn  -> Dreg  (n=0~1 5) 

Description:  This  instruction  adds  the  source  register  and  the  register  speci- 

fied by  the  operand  Rn.  The  result  is  stored  in  the  destination 
register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  any  of  registers  R0~R-|5. 

Flags  affected: 


B 

ALT1 

ALT2  ON 

S 

CY 

Z 

0 

0 

0 

* 

★ 

★ 

B: 

ALT1 
ALT2 
ON: 

S: 

CY: 

Z: 

Opcode: 

(MSB)  (LSB) 

ADD  Rn  | 0 | 1 | 0 | 1 | n (OH-FH)  | (5nH) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycle 

Example:  Under  the  following  conditions: 

Sreg:  Ro-  Dreg:  R0,  R0=4283H,  R4=2438H 
R0=66BBH  when  ADD  R4  is  executed. 


ADD 

r4 

; R0+R4— >R0 

TO 

r5 

; Set  the  destination  register  to  Ri 

ADD 

r6 

; R0+R6—>R5 

ADD 

r3 

; R0+R3— >Rq 

Reset 

Reset 

Reset 

Set  on  signed  overflow. 

Set  if  result  is  negative,  else  reset 
Set  on  unsigned  carry,  else  reset 
Set  if  result  is  zero. 


2-9-5 


DESCRIPTION  OF  INSTRUCTIONS 


9.7  ADD  #n 

Operation:  Sreg  + #n— > Dreg  (n=0~15) 

Description:  This  instruction  adds  the  source  register  to  the  immediate  data 

specified  by  the  operand  #n.  The  result  is  stored  in  the  destina- 
tion register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  immediate  data  from  0-15. 


Flags  affected: 


B 

ALT1  ALT2 

ON  S CY  Z 

0 

0 0 

* * * * 

B: 

Reset 

ALT1 : 

Reset 

ALT2: 

Reset 

ON: 

Set  on  signed  overflow,  else  reset. 

S: 

Set  if  result  is  negative,  else  reset 

CY: 

Set  on  unsigned  carry,  else  reset. 

Z: 

Set  on  zero  result,  else  reset. 

Opcode: 

(MSB) 

(LSB) 

ADD  #n 

0 0 1 

11110  (3EH) 

0 1 0 

1 n (OH-FH)  (5nH) 

Machine  Cycles: 

ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions: 

Sreg:  Dreg;  R7,  R4=3682H 


R7  is  368AH  when  ADD  #8H  is  executed. 


ADD 

#8H 

; R4+OOO8H— >R7 

WITH 

Ry 

;Set  the  source  and  destination  registers  to  R7 

ADD 

#2H 

; R7+0002H— >R7 

ADD 

R7 

! Ro+Ry-^Ro 

2-9-6 


SNES  DEVELOPMENT  MANUAL 


9.8  ALT1 

FLAG  PREFIX  INSTRUCTION 

Operation:  1 — »ALT1  Flag 

Description:  ALT1  is  a prefix  instruction  used  in  combination  with  the  instruc- 

tion which  follows.  When  ALT1  is  executed,  the  Super  FX  sets 
the  ALT  1 flag  in  bit  8 of  the  status  flag  register  (3030,  3031 H). 

The  ALT1  flag  specifies  the  mode  for  the  next  instruction. 

Flags  affected: 


B 

ALT1 

ALT2 

OA/ 

S 

CY 

Z 

1 

- 

- 

- 

- 

ALT1:  Set 


Opcode: 

ALT1 


(MSB) 


(LSB) 


1 0 

0 

1 

1 

1 

1 

0 

1 

(3DH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Execution  of  the  ALT  1 instruction  sets  the  ALT  1 flag.  Various  in- 

structions can  be  executed,  depending  upon  the  instruction 
which  follows  the  ALT  1 prefix. 

(Refer  to,  “ALT1  ($3D)  +”,  in  the  Super  FX  Opcode  Matrix  at  the 
end  of  this  chapter.) 


2-9-7 


DESCRIPTION  OF  INSTRUCTIONS 


9.9  ALT2 

FLAG  PREFIX  INSTRUCTION 

Operation:  1 — > ALT2  Flag 

Description:  ALT2  is  a prefix  instruction  used  in  combination  with  the  instruc- 

tion which  follows.  When  ALT2  is  executed,  the  Super  FX  sets 
the  ALT2  flag  in  bit  9 of  the  status  flag  register  (3030,  3031 H). 

The  ALT2  flag  specifies  the  mode  for  the  next  instruction. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

- 

- 

1 

- 

- 

- 

- 

ALT2:  Set 


Opcode: 

(MSB)  (LSB) 

ALT2  |o|o[l|l|l[l|l|o|  (3EH) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Execution  of  the  ALT2  instruction  sets  the  ALT2  flag.  Various  in- 

structions can  be  executed,  depending  upon  the  instruction 
which  follows  the  ALT2  prefix. 

(Refer  to,  “ALT2  ($3E)  +”,  in  the  Super  FX  Opcode  Matrix  at  the 
end  of  this  chapter.) 


2-9-8 


SNES  DEVELOPMENT  MANUAL 


9.10  ALT3 

FLAG  PREFIX  INSTRUCTION 

Operation:  1 — »ALT1  Flag 

1 ->  ALT2  Flag 

Description:  ALT3  is  a prefix  instruction  used  in  combination  with  the  instruc- 

tion which  follows.  When  ALT3  is  executed,  the  Super  FX  sets 
the  ALT  1 and  ALT2  flags  in  bits  8 and  9 of  the  status  flag  register 
(3030,  3031 H). 

These  flags  specify  the  mode  for  the  next  instruction. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

- 

1 

1 

- 

- 

- 

- 

Opcode: 

ALT3 


ALT1:  Set 

ALT2:  Set 


(MSB)  (LSB) 


1 0 

0 

1 

1 

1 

1 

1 

1 

(3FH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Execution  of  the  ALT3  instruction  sets  the  ALT  1 and  ALT  2 

flags.  Various  instructions  can  be  executed,  depending  upon  the 
instruction  which  follows  the  ALT3  prefix. 

(Refer  to,  “ALT3  ($3F)  +”,  in  the  Super  FX  Opcode  Matrix  at  the 
end  of  this  chapter.) 


2-9-9 


DESCRIPTION  OF  INSTRUCTIONS 


9.11  AND  Rn 

Operation: 

Description: 


Flags  affected 


B 

ALT1 

ALT2 

OA/ 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

* 

B: 

ALT1: 

ALT2: 

S: 

Z: 

Opcode: 

(MSB)  (LSB) 

ADD  Rn  | 0 | 1 | 1 | 1 | n (1H-FH)  | (7nH) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example: 


AND 

r8 

! Rq  AND  Rq  — ^ Rq 

(163AH)  (00FFH)  ->  (003AH) 

FROM 

r9 

;Set  the  source  register  to  Rg 

TO 

Rio 

;Set  the  destination  register  to  R10 

AND 

r7 

! Rg  AND  R7  — ^ Rio 

(55AAH)  (FF00H)  ->  (5500H) 

Reset 

Reset 

Reset 

Set  if  result  is  negative,  else  reset 
Set  on  zero  result,  else  reset. 


Sreg  AND  Rn  > Dreg  (n— 1~15) 

This  instruction  performs  logical  AND  on  corresponding  bits  of 
the  source  register  and  the  operand  Rn.  The  result  is  stored  in 
the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  any  of  registers  R-|~Ri5. 


2-9-10 


SNES  DEVELOPMENT  MANUAL 


9.12  AND  #n 

Operation:  Sreg  AND  #n->  Dreg  (n=1~15) 

Description:  This  instruction  performs  logical  AND  on  corresponding  bits  of 

the  source  register  and  the  immediate  data  specified  by  the  op- 
erand #n.  The  result  is  stored  in  the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 

The  operand  can  be  immediate  data  from  1—15. 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

★ 

B:  Reset 

ALT  1 : Reset 

ALT2:  Reset 

S:  Set  if  result  is  negative,  else  reset 

Z:  Set  on  zero  result,  else  reset. 


Opcode: 

ADD  #n 


(MSB)  (LSB) 

(3EH) 
(7nH) 


0 

0 

1 

1 

1 

1 

1 

0 

0 

1 

1 

1 

n (1H-FH) 

Machine  Cycles:  ROM  execution  time 

RAM  execution  time 
Cache  RAM  execution  time 
Example:  When  register  R0  is,  “3E5DH  (001 


6 cycles 
6 cycles 
2 cycles 

1110  0101  1101B)”, 


AND  #6H 


will  result  in, 

R0  = “0004H  (0000  0000  0000  0100B)”. 


2-9-11 


DESCRIPTION  OF  INSTRUCTIONS 


9.13  ASR 


Operation: 


Sreg 


C 

3 

3 

► ... 

3 

- 

3 

3 

3 

► 

3 

► - 

>15  i.  DO 

Dreg 

L 

... 

E 

E 

E 

E 

D15  DO 


CY 

□ 


Description:  This  instruction  shifts  all  bits  in  the  source  register  one  bit  to  the 

right.  Bit  0 goes  into  the  carry  flag  and  bit  15  is  unaffected.  The 
result  is  stored  in  the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  these 
registers  default  to  R0. 


Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

★ 

★ 

* 

B: 

Reset 

ALT1: 

Reset 

ALT2: 

Reset 

S: 

Set  if  result  is  negative,  else  reset 

CY: 

Set  if  bit  0 in  the  source  register  is  “1 
else  reset 

Z: 

Set  on  zero  result,  else  reset. 

Opcode: 

(MSB) 

(LSB) 

ASR 

1 0 

0 10  110  (96H) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-12 


SNES  DEVELOPMENT  MANUAL 

r 


Example: 


Under  the  following  conditions, 
Sreg:  RlO.  ^reg-  Rl 
CY  bit  15 


|~Q~|  Rio 


bitO 


0 

1 

0 

0 

1 

1 

1 

1 

0 

1 

1 

1 

1 

0 

1 

1 

(4F7BH) 


When  ASR  is  executed,  the  carry  flag  and  R-|  are: 

CY  bit  15  bitO 


±\  Ri 


0 

0 

1 

0 

0 

1 

1 

1 

1 

0 

1 

1 

1 

1 

0 

1 

(27BDH) 


2-9-13 


DESCRIPTION  OF  INSTRUCTIONS 


9.14  BCCe 


(e=  -128  -+127) 

R15  identifies  the  next 
address  for  the  BCC 
instruction  (2  bytes) 

Description:  If  the  carry  flag  is  “0”,  add  “e”  to  the  contents  of  the  program 

counter  R15  and  JUMP  to  the  address  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  carry  flag  is  “1”,  do  not  jump. 

The  relative  offset  can  be  -128  to  +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Operation: 


If  CY  Flag=0 
then  R15+e— »R15 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


Note: 


BCCe 


(MSB)  (LSB) 


0 

0 

0 

0 

i 

i 

0 

0 

p (OOH-FFhh 

c (uun  rrn j 

(OCH) 

Relative  address 


The  number  “e”  (number,  label,  formula)  which  shows  the  jump 
destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-14 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  carry  flag  is  zero  and  the  program 
jumps  forward  5 bytes  from  the  execution  address  of  the  instruc- 
tion. 

BCC  $+5H 

The  relationship  between  the  program  and  the  program 
counter  is  as  follows: 


PC  ADDRESS  Object  Code 


51E 

51F 

520 

521 

522 

523 


0C — | (BCC  $+5H) 
03 — I 


i—  PC  before  jump- 
<r~ PC  after  jump  ^ 


Execute  instruction 
at  address  520  and 
jump. 


2-9-15 


9.15  BCSe 


Operation:  If  CY  Flag=1 

then  R15+e— »R15  (e=  -128-+127) 

R15  identifies  the  next 
address  for  the  BCS 
instruction  (2  bytes) 

Description:  If  the  carry  flag  is  “1”,  add  “e”  to  the  program  counter  R-|5  and 

JUMP  to  the  address  indicated  by  the  resulting  value  in  the  pro- 
gram counter. 

If  the  carry  flag  is  “0”,  do  not  jump. 

The  relative  offset  can  be  -128  to  +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


°Pcode:  (MSB)  (LSB) 

o|o|o|o|l|l|o|l|  (ODH) 

BCS  e ◄ e (00H-FFH)  ► Relative 

I 1 address 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-16 


SNES  DEVELOPMENT  MANUAL 


Example: 


— I 

In  the  following  example,  the  carry  flag  is  set  and  the  program 
jumps  backward  1 byte  from  the  execution  address  of  the  in- 
struction. 

BCS  $-1H 

The  relationship  between  the  program  and  the  program 
counter  is  as  follows: 


PC  ADDRESS  Object  Code 

42D 
42E 
42F 

430 

431 


<— PC  after  jump  ◄- 
0D — [ (BCS  $-1 H) 

4-PC  before  jump 


Execute  instruction 
at  address  430  and 
jump. 


2-9-17 


DESCRIPTION  OF  INSTRUCTIONS 


9.16  BEQe 

Operation:  If  Z Flag=1 

then  Ri5+e — ^Ri5  (e=-128 — 1-127) 

R15  identifies  the  next 
address  for  the  BEQ 
instruction  (2  bytes) 

Description:  If  the  zero  flag  is  “1”,  add  “e”  to  the  program  counter  R15  and 

JUMP  to  the  address  indicated  by  the  resulting  value  in  the  pro- 
gram counter. 

If  the  zero  flag  is  “0”,  do  not  jump. 

The  relative  offset  can  be  -128  to  +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


°Pcode:  (MSB)  (LSB) 

o|o|o|o|l|o|o|l|  (09H) 

BEQe  e (00H-FFH)  ► Relative 

I 1 address 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-18 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  zero  flag  is  set  and  the  program 
jumps  ahead  5 bytes  from  the  execution  address  of  the  instruc- 
tion. 


BEQ  $+5H 

The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

15FD 

15FE 

15FF 

1600 

1601 

1602 

1603 


Object  Code 


03  ZH  (BEQ  $+5H) 


PC  before  jump  - 
<r- PC  after  jump  ^ 


Execute  instruction 
at  address  1600 
and  jump. 


2-9-19 


DESCRIPTION  OF  INSTRUCTIONS 


9.17  BGEe 

Operation:  If  (S  XOR  O/V)=0 

then  R15+e — ^R-is  (e= -128—+127) 

Ri5  identifies  the  next 
address  for  the  BGE 
instruction  (2  bytes) 

Description:  If  the  sign  flag  and  the  overflow  flag  are  equal,  add  “e”  to  the  pro- 

gram counter  R15  and  JUMP  to  the  address  indicated  by  the  re- 
sulting value  in  the  program  counter. 

If  the  values  are  different,  do  not  jump. 

The  relative  offset  can  be  -128  to  +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


BGE  e 


(MSB)  (LSB) 

(07H) 

Relative 
address 


0 

0 

0 

0 

0 

i 

i 

i 

\uun~rrnj 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-20 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  sign  flag  and  over  flag  are  set  and 
the  program  jumps  backward  3 bytes  from  the  execution  address 
of  the  instruction. 

BGE  $-3H 

The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS  Object  Code 


22  FA 
22FB 
22FC 
22FD 
22FE 
22FF 
2300 


PC  after  jump  ^ 

PB  IZi  (BGE  $-3H) 
<—  PC  before  jump  - 


Execute 
instruction  at 
address  2300  and 
jump. 


2-9-21 


9.18  BIC  Rn 

Operation:  Sreg  AND  Rn— > Dreg  (n=1~15) 

Description:  This  instruction  performs  logical  AND  on  corresponding  bits  of 

the  source  register  and  the  1 's  complement  of  register  specified 
in  the  operand  Rn.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

The  operand  can  be  any  of  registers  R-i-R^. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

0 

0 

0 

- 

* 

- 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  if  result  is  negative,  else  reset 

Z : Set  on  zero  result,  else  reset. 

Opcode:  (MSB)  (LSB) 

(3DH) 
(7nH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions: 

Sreg-  ^reg-  ^0 

R2=75CEH  (01110101  1 1 00  1 1 1 0B), 

R1=3846H  (0011  1000  0100  01 1 0B) 

R0  is  4588H  (0100  0101  1000  1000B)  when 
BIC  R, 
is  executed. 


2-9-22 


9.19  BIC  #n 


Operation:  Sreg  AND  #n->  Dreg  (n=1-15) 

Description:  This  instruction  performs  logical  AND  on  corresponding  bits  of 

the  source  register  and  the  1 's  complement  of  the  immediate 
data  specified  in  the  operand  #n.  The  result  is  stored  in  the  desti- 
nation register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

The  operand  can  be  immediate  data  from  1~15. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

★ 

- 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  if  result  is  negative,  else  reset 

Z : Set  on  zero  result,  else  reset. 


Opcode: 

BIC  #n 


(MSB)  (LSB) 

(3FH) 
(7nH) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions: 

^reg-  ^4>  ^reg-  ^5 

R4=  364BH  (001 1 01 1 0 01 00  1 01 1 B) 

R5  is  3640H  (001 1 01 10  0100  0000B)  when 
BIC  #F 
is  executed. 


2-9-23 


DESCRIPTION  OF  INSTRUCTIONS 


9.20  BLTe 

Operation:  If  (S  XOR  0/V)=1 

then  Ris+e— >Ri5  (e=  -128-+127) 

Ris  identifies  the  next 
address  for  the  BLT 
instruction  (2  bytes) 

Description:  If  the  sign  flag  and  the  overflow  flag  are  different,  add  “e”  to  the 

program  counter  Ri5  and  read  the  next  instruction  at  the  location 
indicated  by  the  resulting  value  in  the  program  counter. 

If  the  values  are  the  same,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

* 

No  flags  affected 


°Pcode:  (MSB)  (LSB) 

o|o|o|o|o|l|l|o|  (06H) 

BLT  e e (00H-FFH)  ► Relative 

I 1 address 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-24 


SNES  DEVELOPMENT  MANUAL 


] 


Example:  In  the  following  example,  the  sign  flag  is  set  and  the  overflow  flag 

is  reset.  The  program  jumps  forward  4 bytes  from  the  execution 
address  of  the  instruction. 

BLT  $+4H 

The  relationship  between  the  program  and  program 
counter  is  as  follows: 

PC  ADDRESS  Object  Code 


BBD 

BBE 

BBF 

oilD  (BLT  $+4H) 

BCO 

BC1 

BC2 

<—  PC  before  jump 1 

Execute  instruction 

<r- PC  after  jump  

at  address  BCO 
and  jump. 

2-9-25 


DESCRIPTION  OF  INSTRUCTIONS 


9.21  BMIe 

Operation:  If  S Flag  = 1 

then  Ris+e— >R-|5  (e=  -128~+127) 

R15  identifies  the  next 
address  for  the  BMI 
instruction  (2  bytes) 

Description:  If  the  sign  flag  is  “1”,  add  “e”  to  the  program  counter  R15  and 

read  the  next  instruction  at  the  location  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  sign  flag  is  “0”,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

“ 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


BMI  e 


(MSB)  (LSB) 

(OBH) 

Relative 
address 


0 

0 

0 

0 

i 

0 

1 

1 

p fnm-UFFH'i 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-26 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  sign  flag  is  set  and  the  program 
jumps  forward  5 bytes  from  the  execution  address  of  the  instruc- 
tion. 


BMI  $+5H 


The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

57D 

57E 

57F 

580 

581 

582 

583 


Object  Code 


03  !□  (BMI$+5H) 
<— PC  before  jump  - 

<—  PC  after  jump 


Execute  instruction 
at  address  580 
and  jump. 


2-9-27 


DESCRIPTION  OF  INSTRUCTIONS 


9.22  BNEe 


Operation: 


Description: 


If  Z Flag  = 0 

then  R15+e->R15  (e=  -128-+127) 

R-15  identifies  the  next 
address  for  the  BNE 
instruction  (2  bytes) 

If  the  zero  flag  is  “0”,  add  “e”  to  the  program  counter  Ri5  and 
read  the  next  instruction  at  the  location  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  zero  flag  is  “1”,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


BNE  e 


(MSB) 


0 0 10 
e (00H-FFH) 


(LSB) 

(08H) 

Relative 
address 


0 


Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-28 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  zero  flag  is  reset  and  the  program 
jumps  backward  2 bytes  from  the  execution  address  of  the  in- 
struction. 

BNE  $-2H 


The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

35FB 

35FC 

35FD 

35FE 

35FF 

3600 

3601 


Object  Code 


PC  after  jump  - 

FC^I  (BNE$’2H) 

<— PC  before  jump 


Execute 
instruction  at 
address  3600  and 
jump. 


2-9-29 


DESCRIPTION  OF  INSTRUCTIONS 


9.23  BPLe 

Operation:  If  S Flag  = 0 

then  Ris+e — ^Ri5  (e=  -128~+127) 

R-15  identifies  the  next 
address  for  the  BPL 
instruction  (2  bytes) 

Description:  If  the  sign  flag  is  “0”,  add  “e”  to  the  program  counter  R15  and 

read  the  next  instruction  at  the  location  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  sign  flag  is  “1”,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


BPLe 


(MSB) 


(LSB) 


0 0 1 ( 
e (00H-FFH) 


(OAH) 

Relative 

address 


Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-30 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  sign  flag  is  reset  and  the  program 
jumps  forward  4 bytes  from  the  execution  address  of  the  instruc- 
tion. 


BPL  $+4H 


The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS  Object  Code 


95D 
95E 
95  F 

960 

961 

962 

963 


0A— ] (BPL  $+4H) 
<—  PC  before  jump  - 
4-PC  after  jump 


Execute  instruction 
at  address  960 
and  jump. 


2-9-31 


9.24  BRAe 

Operation:  R15+e->R15  (e=  -128~+127) 

R-15  identifies  the  next 
address  for  the  BRA 
instruction  (2  bytes) 

Description:  Regardless  of  the  status  of  the  flags,  add  “e”  to  the  program 

counter  R15  and  read  the  next  instruction  at  the  location  indicat- 
ed by  the  resulting  value  in  the  program  counter. 

The  relative  offset  can  -128  - +127  bytes  from  the  address  fol- 
lowing the  code  for  “e”. 

When  a JUMP  occurs,  the  next  instruction  to  be  executed  will  al- 
ready be  in  the  instruction  pipeline  of  the  processor.  For  this  rea- 
son one  byte  from  the  pipeline  will  be  executed  before  the 
instruction  at  the  branch  destination  is  executed.  (The  execution 
time  for  this  instruction  is  not  included  in  the  machine  cycles  list- 
ed below.) 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


°PC°de:  (MSB)  (LSB) 

o|o|o|o|o|l|o|l|  (05H) 

BRA  e e (OOH-FFH)  ► Relative 

I 1 address 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-32 


SNES  DEVELOPMENT  MANUAL 

r 


Example: 


In  the  following  example,  the  program  jumps  backward  to  the  ex- 
ecution address  of  the  instruction. 

BRA  $0H 


The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

BOFC 

BOFD 

BOFE 

BOFF 

B100 

B101 


Object  Code 


05  — | <— PC  after  jump 
FE — I (BRA  $0H) 

<— PC  before  jump 


a 


Execute 
instruction  at 
address  B100 
and  jump. 


2-9-33 


DESCRIPTION  OF  INSTRUCTIONS 


9.25  BVCe 

Operation:  If  ON  Flag=0 

then  R15+e-+R15  (e=  -128-+127) 

R15  identifies  the  next 
address  for  the  BVC 
instruction  (2  bytes) 

Description:  If  the  overflow  flag  is  “0”,  add  “e”  to  the  program  counter  R-|5  and 

read  the  next  instruction  at  the  location  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  overflow  flag  is  “1”,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 

BVCe 


(MSB)  (LSB) 

(OEH) 

Relative 
address 


Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-34 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  overflow  flag  is  reset  and  the  pro- 
gram jumps  forward  4 bytes  from  the  execution  address  of  the 
instruction. 

BVC  $+4H 

The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

288 D 
288E 
288F 

2890 

2891 

2892 

2893 


Object  Code 


Q2  Z2  (BVC  $+4H) 


<r- PC  before  jump 
<— PC  after  jump 


Execute  instruction 
at  address  2890 
and  jump. 


2-9-35 


DESCRIPTION  OF  INSTRUCTIONS 


9.26  BVSe 

Operation:  If  0/V  Flag=1 

then  Rl5+e— >Ri5  (e=  -128-+127) 

R15  identifies  the  next 
address  for  the  BVS 
instruction  (2  bytes) 

Description:  If  the  overflow  flag  is  “1”,  add  “e”  to  the  program  counter  R15  and 

read  the  next  instruction  at  the  location  indicated  by  the  resulting 
value  in  the  program  counter. 

If  the  overflow  flag  is  “0”,  do  not  jump. 

The  relative  offset  can  be  -128  ~ +127  bytes  from  the  address 
following  the  code  for  “e”. 

If  the  decision  results  in  a JUMP,  the  next  instruction  to  be  exe- 
cuted will  already  be  in  the  instruction  pipeline  of  the  processor. 
For  this  reason  one  byte  from  the  pipeline  will  be  executed  be- 
fore the  instruction  at  the  branch  destination  is  executed.  (The 
execution  time  for  this  instruction  is  not  included  in  the  machine 
cycles  listed  below.) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

s 

CY 

z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


BVSe 


(MSB)  (LSB) 

(OFH) 

Relative 
address 


0 

0 

0 

0 

1 

1 

1 

1 

(00H 

~FFH) 

Note:  The  number  “e”  (number,  label,  formula)  which  shows  the  jump 

destination  is  given  in  the  assembler  as  an  operand. 


Machine  Cycles: 

ROM  execution  time 

6 cycles 

RAM  execution  time 

6 cycles 

Cache  RAM  execution  time 

2 cycles 

2-9-36 


SNES  DEVELOPMENT  MANUAL 


Example: 


In  the  following  example,  the  overflow  flag  is  set  and  the  program 
jumps  backward  2 bytes  from  the  execution  address  of  the  in- 
struction. 

BVS  $-2H 

The  relationship  between  the  program  and  program 
counter  is  as  follows: 


PC  ADDRESS 

68B 

68C 

68D 

68E 

68F 

690 

691 


Object  Code 


<—  PC  after  jump  ^ — , 

p£^l  (BVS  $-2H) 

<— PC  before  jump  


Execute  instruction 
at  address  690 
and  jump. 


2-9-37 


DESCRIPTION  OF  INSTRUCTIONS 


9.27  CACHE 

Operation:  If  CACHE  BASE  REGISTERo(R15  & OFFFOH) 

then  (R15  & OFFFOH)— >CACHE  BASE  REGISTER 

Description:  When  the  cache  base  register  is  equal  to  the  address  with  the 

lower  4 bits  of  the  program  counter  at  0,  nothing  occurs.  When  it 
is  not  equal  to  this  address,  reset  all  cache  flags  and  set  the 
cache  base  register  to  that  value. 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 

CACHE 


(MSB) 


(LSB) 


0 

0 

0 

0 

0 

0 

1 

0 

(02  H) 


Machine  Cycles: 


ROM  execution  time 
RAM  execution  time 
Cache  RAM  execution  time 


3~4  cycles 
3~4  cycles 
1 cycle 


2-9-38 


SNES  DEVELOPMENT  MANUAL 


9.28  CMODE 

Operation:  Sreg  (b4~b0)  PLOT  OPTIONS  REGISTER 

Description:  This  instruction  loads  the  lower  5 bits  of  the  source  register  into 

the  plot  options  register.  The  instruction  is  used  to  specify  the 
PLOT,  COLOR,  and  GETC  execution  modes. 

Bit  0 - Transparency  Flag 

0 = Transparency  ON 

If  transparency  is  on  and  the  color  register  is  “0”,  the  plot  circuit 
only  changes  the  X coordinate.  When  transparency  is  on  and  the 
color  register  is  other  than  “0”,  the  normal  plotting  operation  is 
performed. 

1 = T ransparency  OFF 

The  normal  plotting  operation  is  performed  when  transparency  is 
off. 

Bit  1 - Dither  Flag 

Bit  1 is  only  valid  in  the  16-color  mode.  When  Bit  1 is  “1”  and  the 
values  of  bit  0 in  registers  R1  and  R2  are  the  same,  the  lower  4 
bits  in  the  color  register  are  plotted.  When  bit  0 of  registers  R1 
and  R2  are  different,  the  upper  4 bits  in  the  color  register  are 
plotted. 

Note:  When  transparency  is  on  and  the  4 bits  to  be  plotted  are 
“0”,  only  the  X coordinate  is  changed. 

Bit  2 - Upper  4 Bits  Color 

Bit  2 is  valid  in  the  16-color  and  256-color  modes.  In  the  256-col- 
or mode,  Bit  3 must  be  set  to  a logic  “1”. 

When  Bit  2 is  “1”,  the  upper  4 bits  in  the  source  register  are 
stored  in  the  lower  4 bits  of  the  color  register  while  processing 
the  COLOR  and  GETC  instructions.  This  allows  the  data  for  two 
pixels  to  be  stored  in  one  byte. 

Bit  3 - 256  Color  Mode  Only 

Set  Bit  3,  “1”,  in  the  256-color  mode  to  fix  the  upper  4 bits  of  the 
color  register  while  processing  the  COLOR  and  GETC  instruc- 
tions and  change  the  lower  4 bits  only. 

Bit  4 - Sprite  Mode 

Set  Bit  4,  “1”,  to  specify  the  bitmap  in  the  sprite  mode. 


2-9-39 


DESCRIPTION  OF  INSTRUCTIONS 


Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT  1 : Reset 

ALT2  : Reset 


Opcode: 

CMODE 


(MSB)  (LSB) 


0 

0 

1 

1 

1 

1 

0 

1 

0 

1 

0 

0 

1 

1 

1 

0 

(3DH) 

(4EH) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

Sreg:  R0,  R0=  0002H 

the  transparency  and  dithering  modes  are  set  when 
CMODE 
is  executed. 


2-9-40 


SNES  DEVELOPMENT  MANUAL 


9.29  CMP  Rn 

Operation:  Sreg-Rn  (n=0~15) 

Description:  This  instruction  subtracts  the  operand  Rn  from  the  source  regis- 

ter and  sets  the  flags  accordingly.  The  result  of  the  subtraction  is 
not  stored. 

The  source  register  is  specified  in  advance  using  a FROM  or 
WITH  instruction.  When  not  specified,  the  source  register  de- 
faults to  R0. 

The  operand  can  be  R0~R15. 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

★ 

* 

* 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

O/V  : Set  on  overflow,  else  reset 

S : Set  when  the  result  is  negative,  else  reset. 

CY  : Set  on  unsigned  borrow,  else  reset. 

Z : Set  on  zero  result,  else  reset 


Opcode: 


(MSB)  (LSB) 

(3FH) 

(6nH) 


CMP  Rr 


0 

0 

1 

1 

1 

1 

1 

1 

0 

1 

1 

0 

n (OH-FH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

Sreg:  R1f  R1=  8000H,  R3=  2FFFH 

the  overflow  and  carry  flags  are  set  and  sign  and  zero  flags  are 
reset  when 

CMP  R3 

is  executed. 


2-9-41 


DESCRIPTION  OF  INSTRUCTIONS 


9.30  COLOR 

Operation:  Sreg  — > Color  register 

Description:  This  instruction  loads  the  lower  8 bits  of  the  source  register  into 

the  color  register  as  the  color  value. 

Note:  The  value  in  the  color  register  is  stored  in  the  color  matrix  (8 

rows  x 8 columns)  with  the  PLOT  instruction.  When  the  PLOT  in- 
struction has  been  executed  eight  times  or  either  of  registers  Ri 
or  R2  is  changed,  the  data  is  changed  automatically  to  character 
data  format  and  stored  in  the  game  pak  RAM. 


Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

“ 

- 

- 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

Opcode: 

(MSB) 

(LSB) 

COLOR 


0 

1 

0 

0 

1 

1 

1 

0 

(4EH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions: 

Sreg-  ^6’  ^6=  9830H 
the  color  register  becomes  30H  when 
COLOR 
is  executed. 


2-9-42 


9.31  DEC  Rn 

Operation:  Rn-1->Rn  (n=0~14) 

Description:  This  instruction  decrements  the  register  specified  in  the  operand 

Rn  by  1 and  stores  the  result  back  in  the  same  register.  The  reg- 
ister used  can  be  R0-R14. 

Flags  affected: 


B 

ALT1 

ALT2  O/V  S 

CY 

Z 

0 

0 

0 

- 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset 

Opcode:  (MSB)  (LSB) 

DEC  Rn  1110  n (OH-EH)  (EnH) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions: 

R9=  A3F7H 

when  the  following  instruction  is  executed 
DEC  R9 

R9  becomes  A3F6H. 


2-9-43 


DESCRIPTION  OF  INSTRUCTIONS 


9.32  DIV2 


Operation:  If  (Sreg)  = -1  then  0 ->  (Dreg) 

else  ASR  (Sreg)  ->  (Dreg) 

Description:  This  instruction  automatically  shifts  all  bits  in  the  source  register 

right  one  place.  The  result  is  stored  in  the  destination  register. 
(Refer  to  ASR  instruction  for  details.)  If  the  source  register  data 
is  FFFFH,  the  result  stored  in  the  destination  register  is  0000H. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  ON 

S 

CY 

Z 

0 

0 

0 

★ 

* 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Set  when  the  result  is  negative,  else  reset. 

CY 

: Set  when  Bit  0 of  the  source  register  is  “1” 
and  reset  when  “0”. 

Z 

: Set  on  zero  result,  else  reset 

Opcode: 

DIV2 


(MSB)  (LSB) 

(3DH) 
(96H) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 


2-9-44 


SNES  DEVELOPMENT  MANUAL 


Example: 


CY 


CY 


Under  the  following  conditions, 

^reg-  ^reg-  ^2 

Bitl  5 

; i 

BitO 

ZD 

o 

o 

o 

o 

o 

o 

o 

0 1 Oil  (4635 H) 

becomes 

Bitl  5 

BitO 

R2:  0010001  1 0001 

10  10  (231  AH) 

when 

DIV2 

is  executed. 


2-9-45 


DESCRIPTION  OF  INSTRUCTIONS 


9.33  FMULT 

Operation: 

D15  Sreg  DO  D15  R6  DO 

\ I . . . , . I ^ I X I I I . . . . . I 


I 


Dreg  (^reg<>R4) 

Description:  This  instruction  performs  a 16  xl 6-bit  signed  multiplication  with 

the  source  register  and  R6.  The  upper  16  bits  of  the  32-bit  result 
are  stored  in  the  destination  register.  Bit  15  of  the  32-bit  result 
becomes  the  carry  flag. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

Note:  Any  register,  R0~R-|5,  except  R4  may  be  assigned  as  the 
destination  register. 

Flags  affected: 


B 

ALT1 

ALT2 

o/v 

s 

CY 

z 

0 

0 

0 

- 

* 

★ 

★ 

Opcode: 


FMULT 


B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Set  when  the  result  is  negative, 

CY 

: Set  when  Bit  1 5 of  the  result  is  ‘ 
and  reset  when  “0”. 

Z 

: Set  if  the  upper  1 6 bits  of  result 
else  reset. 

(MSB) 

(LSB) 

1 

0 

0 

1 

1 

1 

1 

1 

(9FH) 


else  reset. 

‘1” 

are  zero, 


2-9-46 


SNES  DEVELOPMENT  MANUAL 


Machine  Cycles:  ROM  execution  time  1 1 or  7 cycles 

RAM  execution  time  1 1 or  7 cycles 

Cache  RAM  execution  time  8 or  4 cycles 

Note:  The  number  of  machine  cycles  depends  on  the  CFGR  register. 

Example:  Under  the  following  conditions, 

Sreg:  R5,  Dreg:  R2,  R5=  4AAAH,  R6=  DAABH 

R2  becomes  F51CH  and  the  carry  flag  and  sign  flag  are  set 
when 

FMULT 

is  executed. 


2-9-47 


DESCRIPTION  OF  INSTRUCTIONS 


9.34  FROM  Rn 

REGISTER  PREFIX  INSTRUCTION 


Operation: 


Description: 


Opcode: 


If  B =0 


then  set  Sreg  to  Rn 
else  Rn  — > Dreg 


(n=0~15) 


This  instruction  specifies  which  of  the  registers,  R0~R15,  is  to  be 
used  as  the  source  register.  If  the  B flag  is  set,  the  contents  of 
the  specified  operand  Rn  are  stored  in  the  destination  register 
Dreg,  which  is  specified  using  the  WITH  instruction.  (Refer  to  the 
MOVES  instruction.) 


Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


FROM  Rr 


(MSB) 

1 

0 

1 

1 

(LSB) 


n (OH-FH) 


(BnH) 


Machine  Cycles: 

ROM  execution  time 

3 cycles 

RAM  execution  time 

3 cycles 

Cache  RAM  execution  time 

1 cycles 

Example:  Execute 

FROM  R2 

to  set  R2  as  the  source  register. 


To  perform  R2+  R3=  R0,  write: 

FROM  R2  ;Sets  the  source  register  to  R2 

ADD  R3  ;Executes  R2  + R3-^R0 


2-9-48 


9.35  GETB 


Operation: 

D7  ROM  Buffer  DO 


00H 


Description:  This  instruction  loads  one  byte  of  data  stored  in  the  ROM  buffer 

into  the  lower  8 bits  of  the  destination  register  and  resets  the  up- 
per 8 bits  of  the  destination  register.  Register  R14  is  the  ROM  ad- 
dress pointer  when  data  is  loaded  from  the  game  pak  ROM  into 
the  ROM  buffer.  Using  the  value  stored  at  R14  for  the  game  pak 
ROM  address,  data  is  read  from  game  pak  ROM  to  the  ROM 
buffer. 

Banks  are  specified  in  advance  using  the  ROMB  instruction. 
However,  changing  banks  using  the  ROMB  instruction  does  not 
in  itself  trigger  a ROM  load. 

The  destination  register  is  specified  in  advance  using  a WITH  or 
TO  instruction.  When  not  specified,  this  register  defaults  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  OA/ 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode:  (MSB)  (LSB) 

GETB  1110  1111  (EFH) 

Machine  Cycles:  ROM  execution  time  3-8  cycles 

RAM  execution  time  3-9  cycles 

Cache  RAM  execution  time  1 -6  cycles 

Note:  Because  the  ROM  buffer  is  used,  the  number  of  execution  cycles 

varies  with  each  program. 


2-9-49 


DESCRIPTION  OF  INSTRUCTIONS 


Example:  Under  the  following  conditions, 

ROM  buffer=0075H,  Dreg:R0 
R0  becomes  0075H  when 
GETB 
is  executed. 


2-9-50 


SNES  DEVELOPMENT  MANUAL 


9.36  GETBH 


Operation: 


Description:  This  instruction  loads  the  data  contained  in  the  ROM  buffer  to 

the  high  byte  of  the  destination  register  and  the  low  byte  of  the 
source  register  to  the  low  byte  of  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

Note:  Refer  to  the  GETB  instruction  and  “Memory  Mapping”  for  infor- 

mation to  load  data  from  game  pak  ROM  to  the  ROM  buffer. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 

GETBH 


(MSB)  (LSB) 


0 

0 

1 

1 

1 

1 

0 

1 

1 

1 

1 

0 

1 

1 

1 

1 

(3DH) 

(EFH) 


Machine  Cycles:  ROM  execution  time  6-10  cycles 

RAM  execution  time  6-9  cycles 

Cache  RAM  execution  time  2-6  cycles 

Note.  Because  the  ROM  buffer  is  used,  the  number  of  execution  cycles 

varies  with  each  program. 


2-9-51 


DESCRIPTION  OF  INSTRUCTIONS 

I 

Example:  Under  the  following  conditions, 

(ROM  buffer)  = 75H,  Sreg:  R2,  Dreg:  R6,  R2=  4ABDH 

R6  becomes  75BDH  when 
GETBH 
is  executed. 


2-9-52 


SNES  DEVELOPMENT  MANUAL 


9.37  GETBL 

Operation: 

D15 


Upper  Byte 


^reg 

D8D7 


DO  D7  ROM  Buffer  DO 


D8  D7 


Upper  Byte 


Lower  Byte 


Description: 


Note: 


Flags  affected: 


This  instruction  loads  the  data  contained  in  the  ROM  buffer  to 
the  low  byte  of  the  destination  register  and  the  high  byte  of  the 
source  register  to  the  high  byte  of  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

Refer  to  the  GETB  instruction  and  “Memory  Mapping”  for  infor- 
mation to  load  data  from  game  pak  ROM  to  the  ROM  buffer. 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

Opcode: 


GETBL 


Machine  Cycles: 


B 

ALT1 

ALT2 

(MSB) 


: Reset 
: Reset 
: Reset 


(LSB) 


0 

0 

1 

1 

1 

1 

1 

0 

(3EH) 

1 

1 

1 

0 

1 

1 

1 

1 

(EFH) 

ROM  execution  time  6~10  cycles 

RAM  execution  time  6~9  cycles 

Cache  RAM  execution  time  2-6  cycles 


Because  the  ROM  buffer  is  used,  the  number  of  execution  cycles 
varies  with  each  program. 


2-9-53 


DESCRIPTION  OF  INSTRUCTIONS 

I 

Example:  Under  the  following  conditions, 

(ROM  buffer)  = 75H,  Sreg:  R2,  Dreg:  R6,  R2=  4ABDH 

R6  is  4A75H  when 
GETBL 
is  executed. 


2-9-54 


9.38  GETBS 

Operation: 


D7  D6 


ROM  Buffer 


Description: 


Note: 


Flags  affected: 


315  D8  D7  D6  DO 

This  instruction  loads  the  data  contained  in  the  ROM  buffer  to 
the  low  byte  of  the  destination  register  and  the  data  contained  in 
Bit  7 of  the  ROM  buffer  to  Bits  8~1 5 of  the  destination  register. 

The  destination  register  is  specified  in  advance  using  a WITH  or 
TO  instruction.  When  not  specified,  this  register  defaults  to  R0. 

Refer  to  the  GETB  instruction  and  “Memory  Mapping”  for  infor- 
mation to  load  data  from  game  pak  ROM  to  the  ROM  buffer. 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

Opcode: 


B 

ALT1 

ALT2 

(MSB) 


Reset 

Reset 

Reset 


(LSB) 


GETBS 


0 

0 

1 

1 

1 

1 

1 

1 

(3FH) 

1 

1 

1 

0 

1 

1 

1 

1 

(EFH) 

Machine  Cycles: 


Note: 


ROM  execution  time  6-  1 0 cycles 

RAM  execution  time  6~9  cycles 

Cache  RAM  execution  time  2-6  cycles 

Because  the  ROM  buffer  is  used,  the  number  execution  cycles 
varies  with  each  program. 


2-9-55 


DESCRIPTION  OF  INSTRUCTIONS 

- " ZD 

Example:  Under  the  following  conditions, 

(ROM  buffer)  = 85H,  Dreg:  R8 

R8  becomes  FF85H  when 
GETBS 
is  executed. 


2-9-56 


SNES  DEVELOPMENT  MANUAL 


9.39  GETC 

Operation: 

Description: 

Note: 


Flags  affected: 


Opcode: 


(ROM  buffer)  — » (COLOR  register) 

This  instruction  loads  the  data  contained  in  the  ROM  buffer  into 
the  color  register  as  color  data. 

Refer  to  the  GETB  instruction  and  “Memory  Mapping”  for  infor- 
mation to  load  data  from  game  pak  ROM  to  the  ROM  buffer.  Re- 
fer to  COLOR  and  “Bitmap  Emulation”  for  information  concerning 
the  color  register  and  how  to  plot. 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B 

ALT1 

ALT2 

(MSB) 


: Reset 
: Reset 
: Reset 


GETC 


Machine  Cycles: 


(LSB) 


1 

1 

0 

1 

1 

1 

1 

1 

(DFH) 


Note: 


Example: 


ROM  execution  time  3~1 0 cycles 

RAM  execution  time  3~9  cycles 

Cache  RAM  execution  time  1 ~6  cycles 

Because  the  ROM  buffer  is  used,  the  number  of  execution  cycles 
varies  with  each  program. 

Under  the  following  conditions, 

(ROM  buffer)  = 4BH 


4BH  is  loaded  to  the  color  register  when 
GETC 
is  executed. 


2-9-57 


9.40  HIB 


Operation: 


Description:  This  instruction  loads  the  high  byte  of  the  source  register  into  the 

low  byte  of  the  destination  register.  The  high  byte  of  the  destina- 
tion register  is  loaded  with  00H. 


The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified, 
these  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

★ 

- 

* 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  if  a negative  number  is  loaded  to  the  low 

byte  of  the  destination  register,  else  reset. 

Z : Set  if  zero  is  loaded  to  low  byte  of 

the  destination  register,  else  reset. 

(MSB)  (LSB) 

1 1 0 0 0 0 0 0 (C0H) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


Opcode: 

HIB 


2-9-58 


SNES  DEVELOPMENT  MANUAL 


Example: 


— . I 

Under  the  following  conditions, 

Sreg-  Rli>  ^reg=^1>  R-|-)=8A43H 

Ri  becomes  008AH  and  the  sign  flag  is  set  when 
HIB 

is  executed. 


2-9-59 


DESCRIPTION  OF  INSTRUCTIONS 


9.41  IBT  Rn,  #pp 

Operation: 


D7  D6 


DO 


Rr 


D15 


D8  D7  D6 


DO 


Description:  This  instruction  loads  one  byte  of  immediate  data  (hexadecimal) 

into  the  low  byte  of  register  Rn.  Bit  7 of  the  immediate  data  is 
loaded  into  bits  8 through  15  of  Rn. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode:  (MSB) 


(LSB) 


IBT  Rn>  #pp 


1 


n (OH-FH) 


pp  (00H~  FFH) 


(AnH) 

(PPH) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Since  hexadecimal  numbers  are  handled  in  the  assembler  as 

intergers,  without  signs,  a hexadecimal  number  of  80H  or  greater 
that  is  entered  as  an  operand  is  processed  as  a number  greater 
than  +128,  exceeding  the  range  -128-+127.  When  this  occurs, 
the  assembler  will  specify  the  low  byte  as  the  immediate  data  of 
the  IBT  instruction. 


IBT 

R8> 

#4 

...  0004 H ->  R8 

IBT 

R8> 

#-128 

...  FF80H  — ¥ R8 

IBT 

R8> 

#0A4H 

...  FFA4H  ->  R8 

2-9-60 


SNES  DEVELOPMENT  MANUAL 


9.42  INC  Rn 

Operation:  Rn  + 1 -»  Rn  (n  = 0-14) 

Description:  This  instruction  increments  the  contents  of  the  register  specified 

in  the  operand  Rn  by  one  and  stores  the  result  back  into  the 
same  register. 

The  operand  can  be  R0~Ri4- 

Flags  affected: 


B 

ALT1 

ALT2 

OA/ 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

★ 

Opcode: 


INC  Rn 


B 

ALT1 

ALT2 

S 

Z 

(MSB) 


: Reset 
: Reset 
: Reset 

: Set  if  result  is  negative,  else  reset. 
: Set  on  zero  result,  else  reset. 


(LSB) 


1 

0 

1 

1 

n (OH-EH) 

(DnH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  When  register  R12  is  65B1 H,  R12  becomes  65B2H  when 

INC  R12 
is  executed. 


2-9-61 


DESCRIPTION  OF  INSTRUCTIONS 


9.43  IWT  Rn,  #xx 

Operation:  #xx  (2-byte  hexadecimal  immediate  data)  — > Rn 

(n  = 0-15,  #xx=0-65535) 

Description:  This  instruction  loads  two  bytes  of  immediate  data,  #xx  (hexa- 

decimal), to  the  register  specified  in  the  operand,  Rn. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  = Reset 


The  two-byte  immediate  data  in  the  op  code  is  loaded  low 
byte  first,  followed  by  the  high  byte. 


Machine  Cycles:  ROM  execution  time  9 cycles 

RAM  execution  time  9 cycles 

Cache  RAM  execution  time  3 cycles 

Example:  Register  R0  becomes  4583H  when 

IWT  R0,  #4583H 
is  executed. 


2-9-62 


9.44  JMP  Rn 


Operation:  Rn  — > R15  (PC)  (n=8~13) 

Description:  This  instruction  loads  the  contents  of  the  register  specified  in  the 

operand  Rn  to  R-|5  (program  counter)  and  initiates  a program 
fetch  from  the  resulting  location  specified  by  the  program 
counter. 

The  next  instruction  to  be  executed  will  already  be  in  the  instruc- 
tion pipeline  of  the  processor.  For  this  reason  one  byte  from  the 
pipeline  will  be  executed  before  the  instruction  at  the  branch  des- 
tination is  executed.  (The  execution  time  for  this  instruction  is  not 
included  in  the  machine  cycles  listed  below.) 

The  operand  can  be  register  R8~R-|3. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

(9nH) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  When  register  Ri0  is  0555H  and  the  following  program  is  execut- 

ed, 

PC  Opcode 

0444H  JMP  R10 

0445 H INC  Ri0 


the  jump  destination  is  0555H. 


2-9-63 


9.45  LDB  (Rm) 

Operation:  (Rm)  — > Dreg  (Low  Byte)  (m=0~1 1) 

00H  — > Dreg  (High  Byte) 

Description:  This  instruction  loads  one  byte  of  data  located  at  the  game  pak 

RAM  address  contained  in  the  register  specified  in  the  operand 
Rm  and  stores  this  data  in  the  destination  register.  The  upper 
byte  of  the  destination  register  is  loaded  with  00H. 

Use  the  RAMB  instruction  to  set  the  RAM  bank.  (Refer  to 
RAMB.) 

The  destination  register  is  specified  in  advance  using  a WITH  or 
TO  instruction.  When  not  specified,  this  register  defaults  to  R0. 

Flags  affected: 


ALT1  : Reset 

ALT2  : Reset 

Opcode:  (MSB)  (LSB) 

(3DH) 

(4m  H) 

Machine  Cycles:  ROM  execution  time  1 1 cycles 

RAM  execution  time  1 3 cycles 

Cache  RAM  execution  time  6 cycles 

Note:  The  GSU  waits  while  the  data  is  loaded  from  game  pak  RAM. 

The  cycles  required  for  this  are  included  in  the  execution  times 
given  above. 


2-9-64 


SNES  DEVELOPMENT  MANUAL 


Example:  Under  the  following  conditions, 

Dreggy.  Ri=  3482H,  (70:3482H)=  51 H 

RAMBR:70H 

and  when  the  following  program  is  executed, 

LDB  (R^ 

R7  becomes  0051 H. 


2-9-65 


9.46  LDW  (Rm) 

Operation:  (Rm)  — » Dreg  (Low  Byte)  (m=0~1 1 ) 

(Rm±1 ) —>  Dreg  (High  Byte)  When  the  contents  of  Rm  is: 

even,  (Rm+1) 
odd,  (Rm-1) 

is  loaded  to  the  high  byte. 

Description:  The  word  data  located  in  the  game  pak  RAM  address  that  equals 

the  contents  of  register  Rm  are  stored  in  the  destination  register. 
The  game  pak  RAM  address  bank  is  specified  using  the  RAMB 
instruction  (refer  to  RAMB). 

The  destination  register  is  specified  in  advance  using  a WITH  or 
TO  instruction.  When  not  specified,  this  register  defaults  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT  1 : Reset 

ALT2  : Reset 


0pcode:  (MSB)  (LSB) 

LDW  (Rm)  0 10  0 m (OH-BH)  (4mH) 

Machine  Cycles:  ROM  execution  time  10  cycles 

RAM  execution  time  1 2 cycles 

Cache  RAM  execution  time  7 cycles 

Note:  While  a load  is  performed  from  the  game  pak  ROM,  the  GSU  is 

in  the  WAIT  state.  This  execution  time  is  included  in  the  above 
machine  cycles. 

Example:  Under  the  following  conditions, 

Dreg:R5,  R3=6480H,  (70:6480H)=C0H,  RAMBR=70H 
and  when  the  following  program  is  executed, 

LDW  (R3) 

the  register  R5  becomes  C02EH. 


2-9-66 


SNES  DEVELOPMENT  MANUAL 


9.47  LEA  Rn,  xx  (Refer  to  IWT  Rn,  #xx) 

Operation:  Rn<-xx  (n=0~15,  xx=0~65535) 

Description:  This  instruction  loads  two  bytes  of  immediate  data,  #xx  (hexa- 

decimal), to  the  register  specified  in  the  operand  Rn. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


The  two-byte  immediate  data  in  the  op  code  is  loaded  low 
byte  first,  followed  by  the  high  byte. 


Machine  Cycles: 

ROM  execution  time 

9 cycles 

RAM  execution  time 

9 cycles 

Cache  RAM  execution  time 

3 cycles 

Example:  Register  R3  becomes  4853H  when 

LEA  R3,  #4853H 


is  executed. 


2-9-67 


DESCRIPTION  OF  INSTRUCTIONS 


9.48  LINK  #n 

Operation:  R15  + #n  — > R!  i (n=1  ~4) 

Ris  contains  address 
following  LINK  instruction 

Description:  This  instruction  adds  the  operand  #n  to  the  value  contained  in 

register  R15  (program  counter)  and  stores  the  result  in  register 
Ri  i . Operand  #n  can  be  a number  from  1 ~4.  This  instruction  can 
be  used  to  specify  a return  address  in  register  Rn  when  jumping 
to  a subroutine. 

Flags  affected: 


Opcode: 

LINK  #n 


B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

(MSB) 

(LSB) 

1 0 0 

1 n (1H-4H) 

(9nH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions, 

R15:  4368H 

and  when  the  following  program  is  executed, 

4368  LINK  #4 

4369  IWT  R15,  #74FFH 

436C  NOP 

436B  IBT  R-j , #12H 

register  R-,-,  becomes  4369H  + 2=436BH 


2-9-68 


SNES  DEVELOPMENT  MANUAL 

I 


3 


9.49  LJMP  Rn 

Operation:  Rn  — » R15  (PC)  (n=8~13) 

Sreg  — > Program  Bank  Register  (PBR) 

Description:  This  instruction  loads  the  register  specified  as  operand,  Rn,  into 

the  program  counter,  Ri5  and  loads  the  lower  byte  of  the  source 
register  to  the  program  bank  register.  This  allows  the  program  to 
jump  to  addresses  in  different  banks. 

The  next  instruction  to  be  executed  will  already  be  in  the  instruc- 
tion pipeline  of  the  processor.  For  this  reason  one  byte  from  the 
pipeline  will  be  executed  before  the  instruction  at  the  branch  des- 
tination is  executed.  (The  execution  time  for  this  instruction  is  not 
included  in  the  machine  cycles  listed  below.) 

The  operand  can  be  any  of  registers  R8~R13. 

Flags  affected: 


B 

ALT1 

ALT2 

o/v 

s 

CY 

z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 


LJMP  Rn 


(MSB; 


(LSB) 


0 

0 

1 

1 

1 

1 

0 

1 

1 

0 

0 

1 

n (8H-DH) 

(3DH) 

(9nH) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

RvOOOIH 

the  program  jumps  from  00:8006H  to  01 :0002H  when  the  follow- 


ing  program  is  executed. 
Bank  :Address 

Svntax 

00 

:8000H 

IWT  R10,  #0002 H 

00 

:8003H 

FROM  Rt 

00 

:8004H 

LJMP  R10 

00 

:8006H 

NOP 

2-9-69 


DESCRIPTION  OF  INSTRUCTIONS 


9.50  LMRn,  (xx) 

Operation:  RAM  (xx)  — > Rn  (low  byte)  (n=0~15,  xx=0~65535) 

RAM  (xx±1 ) -»  Rn  (high  byte)  When  the  value  of  xx  is: 

even, (xx+1) 
odd,  (xx-1) 

is  loaded  to  the  high  byte. 

Description:  This  instruction  loads  the  data  contained  in  the  game  pak  RAM 

address  specified  in  the  second  operand  xx  and  stores  the  data 
in  the  register  specified  in  the  first  operand  Rn.  The  RAMB  in- 
struction is  used  to  specify  the  bank  of  the  RAM  address. 

Flags  affected: 


B 

ALT1 

ALT2  ON 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode:  (MSB) 


(LSB) 


(3DH) 

(FnH) 

(ADRS  Lower  Byte) 
(ADRS  Upper  Byte) 


Machine  Cycles:  ROM  execution  time  20  cycles 

RAM  execution  time  21  cycles 

Cache  RAM  execution  time  1 1 cycles 

Note:  While  a load  is  performed  from  the  game  pak  RAM,  the  GSU  is 

in  the  WAIT  state.  This  execution  time  is  included  in  the  above 
machine  cycles. 

Example:  Under  the  following  conditions, 

(70:BACCH)  = 28H,  (70:BACDH)  = 96H,  RAMBR=70H 

register  Rg  becomes  9628H  when  the  following  program  is  exe- 
cuted: 

LM  R9,  (OBACCH) 


2-9-70 


SNES  DEVELOPMENT  MANUAL 


9.51  LMS  Rn,  (yy) 

Operation:  RAM  (yy)  Rn  (low  byte)  (n=0~15,  yy=0~510*) 

RAM  (yy+1)  — > Rn  (high  byte) 

‘Note:  Selectable  RAM  address  (yy)  must  be  an  even  number. 

Description:  This  instruction  uses  a short  address  method  to  perform  the  LM 

instruction.  The  address  is  shortened  by  reducing  the  number  of 
bytes  in  the  instruction  opcode.  The  instruction  loads  data  from 
the  game  pak  RAM  address  equal  to  the  immediate  number  yy 
and  stores  the  data  in  register  Rn.  The  selectable  game  pak 
RAM  address  may  be  an  even  number  of  0-510.  The  RAMB  in- 
struction is  used  to  specify  the  bank  of  the  RAM  address. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT  1 : Reset 

ALT2  : Reset 


Opcode: 


LMS  Rn,  (yy) 


0 

0 

1 

1 

1 

1 

0 

1 

1 

0 

1 

0 

n (OH-FH) 

kk  (00H-FFH) 

(3DH) 

(AnH) 

(Address) 


[Short  address  method] 

This  method  is  used  by  LMS,  SMS,  and  other  instructions  to  re- 
duce the  number  of  bytes  in  the  instruction  opcode.  Only  one 
byte  is  used.  The  actual  game  pak  RAM  address  is  twice  that  of 
the  address  code.  The  relationship  between  yy  in  the  above  syn- 
tax and  kk  in  the  opcode  is: 

yy  = kk  x 2 

Machine  Cycles:  ROM  execution  time  17  cycles 

RAM  execution  time  1 7 cycles 

Cache  RAM  execution  time  1 0 cycles 

Note:  The  GSU  waits  while  data  is  loaded  from  game  pak  RAM.  The 

execution  time  required  for  this  is  included  in  the  machine  cycles 
given  above. 


2-9-71 


DESCRIPTION  OF  INSTRUCTIONS 

- ..  . 1 

Example:  Under  the  following  conditions, 

(70:1  AAH)  = 32H,  (70:1ABH)  = 92H,  RAMBR:70H 

register  R3  becomes  9232H  when  the  following  program  is  exe- 
cuted: 


Syntax  Opcode 

LMS  R3,  (1  AAH)  3DA3D5 


2-9-72 


SNES  DEVELOPMENT  MANUAL 


9.52  LMULT 

Operation: 


D15 

Sreg 

DO 

D15 

Re 

DO 

1 

X 

D31 

1 

D16  D15 

DO 

L 

| 

Upper  Word 

Lower  Word 

D15 

/ 

DO 

/ 

D15 

DO 

f | 

I 

^reg 

CY  Flag 

r4 

Description:  This  instruction  performs  16  x 16-bit  signed  multiplication  using 

the  source  register  and  register  R6.  The  upper  16  bits  of  the  re- 
sult are  stored  in  the  destination  register,  and  the  lower  1 6 bits 
are  stored  in  R4.  If  Bit  1 5 of  R6  is  set,  the  carry  flag  is  also  set  to 

u <|  jj  ’ 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0.  If  R4  is  specified 
as  the  destination  register,  the  result  will  be  invalid. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

★ 

* 

* 

Opcode: 


LMULT 


B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  if  the  result  is  negative,  else  reset 

CY  : Set  if  Bit  1 5 of  R6  is  “1  ”,  reset  if  “0” 

Z : Set  if  the  destination  register  result  is  zero, 

else  reset. 

(MSB)  (LSB) 


0 

0 

1 

1 

1 

1 

0 

1 

1 

0 

0 

1 

1 

1 

1 

1 

(3DH) 

(9FH) 


2-9-73 


DESCRIPTION  OF  INSTRUCTIONS 

1 


Machine  Cycles: 

Note: 

Example: 


ROM  execution  time  10  orl  4 cycles 

RAM  execution  time  1 0 orl  4 cycles 

Cache  RAM  execution  time  5 or  9 cycles 

The  number  of  cycles  varies  depending  upon  the  CFGR  register 
setting. 

Under  the  following  conditions, 

Sreg-  ^reg’  ^8 
R9=  B556H,  R6=  DAABH 

the  register  R8  becomes  0AE3H  and  R4  5C72H  when 
LMULT 
is  executed. 


2-9-74 


SNES  DEVELOPMENT  MANUAL 


9.53  LOB 

Operation: 


00H 


D15 

i Sreg  D8  D7 

DO 

U 

Upper  Byte 

1 

Lower  Byte 

D15 

1 

D8  D7 

1 

DO 

Upper  Byte 

■1 

■ 

Lower  Byte 

1 

D 


reg 


Description:  This  instruction  loads  the  lower  byte  of  the  source  register  to  the 

low  byte  of  the  destination  register.  The  high  byte  of  the  destina- 
tion register  is  loaded  with  00H. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

★ 

Opcode: 

LOB 


B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  if  the  low  byte  of  the  source  register  is 

negative,  else  reset. 

2 : Set  if  low  byte  of  the  source  register  is  zero, 

else  reset. 


(MSB) 


(LSB) 


1 

0 

0 

1 

1 

1 

1 

0 

(9EH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-75 


DESCRIPTION  OF  INSTRUCTIONS 


~ 1 

Example:  Under  the  following  conditions, 

Sreg-  RlO.  Dreg-  Rl2>  RlO=  FB23H 
the  register  Ri2  becomes  0023H  when 
LOB 

is  executed. 


2-9-76 


SNES  DEVELOPMENT  MANUAL 

r 


9.54  LOOP 

Operation:  R12  - 1 — » R12 

If  Z Flag=0  then  R13->  Ri5  (PC) 

Description:  This  instruction  decrements  R12  by  1 . If  the  result  does  not  set 

the  zero  flag,  the  contents  of  R13  are  loaded  into  Ri5  and  the 
program  is  fetched  from  the  resulting  location  specified  by  the 
program  counter. 

If  the  zero  flag  is  set,  the  program  counter  is  incremented  and 
the  next  instruction  is  executed. 

The  instruction  at  the  address  following  the  LOOP  instruction  is 
already  loaded  into  the  pipeline.  The  branch  is  taken  after  this  in- 
struction is  executed. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

* 

- 

* 

Opcode: 


LOOP 


B 

ALT1 

ALT2 

S 

Z 

(MSB) 


: Reset 
: Reset 
: Reset 

: Set  if  the  register  R12  is  negative,  else  reset. 
: Set  if  the  register  R12  is  zero,  else  reset. 


(LSB) 


0 

0 

1 

1 

1 

1 

0 

0 

(3CH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


Example:  In  the  following  program, 

00:8014  INCR7 
00:8015  INCR6 
00:8016  LOOP 
00:8017  NOP 
00:8018  ADDR4 

if  Ri3  is  801 4H  and  R-|2  is  other  than  0001 H,  the  program  jumps 
to  00:801 4H  after  the  NOP  instruction  is  executed.  If  R-|2  is 
0001 H,  the  jump  does  not  happen  and  the  instruction  ADD  is  ex- 
ecuted. 


2-9-77 


DESCRIPTION  OF  INSTRUCTIONS 


9.55  LSR 


Operation: 


Description: 


D15 

$reg 

DO 

CY 

0-*-  — !► 

— ► — ► — !►  — 

3 

HI 

D15 

* 

DO 

) 

□ 

] Dreg 

This  instruction  shifts  all  bits  in  the  source  register  one  bit  to  the 
right  and  stores  the  result  in  the  destination  register.  Bit  1 5 be- 
comes “0”  and  the  value  of  Bit  0 is  stored  in  the  carry  flag. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 


Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

0 

★ 

* 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Reset 

CY  : Set  if  Bit  0 in  source  register  is  “1”,  else  reset 

Z : Set  on  zero  result,  else  reset. 

Opcode:  (MSB)  (LSB) 

LSR  0 0 0 0 0 0 1 1 (03H) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions, 

Sreg:  R8>  ^reg-  ^0 

bit  15  bitO 


R8:  101 

1 

0 1 

0 10  0 

1 1 1 

E 

1 1 (B53FH) 

LSR  execution  results  in: 

bitl  5 

bitO  CY 

R0:  0 1 0 

3 

1 0 

10  10 

0 1 1 

3 

1 1 (5A9FH)  7] 

2-9-78 


9.56  MERGE 


Operation: 


Description:  This  instruction  stores  the  high  byte  of  R7  in  the  high  byte  of  the 

destination  register  and  the  high  byte  of  R8  in  the  low  byte  of  the 
destination  register. 

The  destination  register  is  specified  in  advance  using  a WITH  or 
TO  instruction.  When  not  specified,  the  register  defaults  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  O/V  S 

CY 

Z 

0 

0 

0 

★ 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

O/V  : Set  if  the  result  of  (B6  or  B7  or  B1 4 or  B1 5)  is 

“1”,  and  reset  if  “0”. 

S : Set  if  the  result  of  (B7  or  B15)  is  “1”, 

and  reset  if  “0”. 

CY  : Set  if  the  result  of  (B5  or  B6  or  B7  or  B1 3 or 

B14  or  B15)  is  “1”,  reset  if  “0”. 

Z : Set  if  the  result  of  (B4  or  B5  or  B6  or  B7  or  B1 2 

or  B13  or  B14  or  B15)  is  “1”,  reset  if  “0” 

Opcode:  (MSB)  (LSB) 

MERGE  0 1 1 1 0 0 0 0 (70H) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-79 


DESCRIPTION  OF  INSTRUCTIONS 
1 


Example: 


Under  the  following  conditions: 

Dreg!  R9>  R7=05AAH,  R8=FC33H 

R9  becomes  05FCH  and  the  sign,  over  flow,  carry  and  zero  flags 
are  set  when 

MERGE 


is  executed. 


SNES  DEVELOPMENT  MANUAL 


9.57  MOVE  Rn,  Rn’ 

Operation:  Rn’  ->  Rn  (n,  n’  = 0~15) 

Description:  This  instruction  loads  the  contents  of  register  Rn’,  specified  in  the 

second  operand,  to  register  Rn,  specified  in  the  first  operand. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 

MOVE  Rn, 


(MSB)  (LSB) 

(2n’H) 
(InH) 


0 

0 

1 

0 

n’  (OH-FH) 

0 

0 

0 

1 

n (OH-FH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

R14=  4983H,  R8=  9264 H 
the  register  R8  becomes  4983H  when 
MOVE  R8,  R14 
is  executed. 


2-9-81 


9.58  MOVE  Rn,  #xx 

MACRO  INSTRUCTION 


Operation:  #xx  — > Rn  (n  = 0~15,  #xx=-32768~65535) 

(if  unsigned,  #xx=0~65535) 

Conditions:  IF  (-128<xx<127):  (if  unsigned,  (0<xx<1 27)  or 

then,  use  an  IBT  instruction  (65408<xx<65535)) 
else,  use  an  IWT  instruction. 

Description:  This  instruction  directly  loads  hexadecimal  immediate  data  into 

register  Rn,  specified  in  the  first  operand.  This  is  a macro  instruc- 
tion and  is  stored  in  memory  as  “IWT  Rn,  #xx”  or  “IBT  Rn,  #pp.” 
The  assembler  automatically  recognizes  whether  this  should  be 
replaced  with  an  IBT  instruction  or  IWT  instruction,  depending 
upon  the  value  of  immediate  data. 

If  immediate  data  is  -128  ~ 127  (unsigned,  0-127  or 
65408-65535),  it  is  replaced  with  an  IBT  instruction.  Otherwise, 
it  is  replaced  with  an  IWT  instruction.  Refer  to  “IBT  Rn,  #pp”  or 
“IWT  Rn,  #xx”  for  machine  cycles,  flags  affected,  and  opcode. 

Example: 

MOVE  R8,  #070 H ;0070H— >R8  (IBT  R8,  #070H) 

MOVE  R8,  #0A4H;  00A4H^R8  (IWT  Re,  #0A4H) 

MOVE  R8,  #-128;  FF80->R8  (IBT  R8,  #-128) 


2-9-82 


9.59  MOVE  Rn,  (xx) 

MACRO  INSTRUCTION 


Operation:  (xx)  Rn  (low  byte)  (n=0~15,  xx=0~FFFFH) 

(xx±1 ) — > Rn  (high  byte) 

Note:  When  the  value  xx  is  even,  the  contents  of  (xx+1 ) are 

loaded  to  the  high  byte  of  Rn.  When  the  value  of  xx  is 
odd,  the  contents  of  (xx-1 ) are  loaded  to  the  high  byte  of 
Rn. 

Conditions:  If  (0000H<xx<01  FFH)  and  xx  is  even: 

then,  use  an  LMS  instruction 
else,  use  an  LM  instruction. 

Description:  This  instruction  loads  hexadecimal  data  contained  in  the  game 

pak  RAM  address  specified  in  the  second  operand  and  stores 
the  data  in  register  Rn,  specified  in  the  first  operand..  The  RAMB 
instruction  is  used  to  specify  the  bank  of  the  game  pak  RAM  ad- 
dress (refer  to  RAMB). 

This  is  a macro  instruction  and  is  stored  in  memory  as  “LM  Rn, 
(xx)”  or  “LMS  Rn,  (yy).”  The  assembler  automatically  recognizes 
whether  it  should  be  replaced  with  an  LM  instruction  or  an  LMS 
instruction,  depending  upon  the  value  of  the  game  pak  RAM  ad- 
dress specified. 

When  the  game  pak  RAM  address  is  an  even  number  of 
0-1  FFH,  it  is  replaced  with  an  LMS  instruction.  Otherwise,  it  is 
replaced  with  an  LM  instruction.  Refer  to  “LM  Rn,  (xx)”  or  “LMS 
Rn,  (yy)”  for  machine  cycles,  flags  affected,  and  opcode. 

Example:  Linder  the  following  conditions, 

(70:BACCH)  = 28H,  (70:BACDH)  = 96H,  RAMBR=70H 

the  register  R9  becomes  9628H  when  the  following  program  is 
executed: 

MOVE  R9,  (OBACCH)  ;(70:BACCH)— »R9(Low  Byte)  (LM  R9,  (OBACCH)) 

;(70:BACDH)— >R9(High  Byte) 


2-9-83 


DESCRIPTION  OF  INSTRUCTIONS 


I 

Also,  under  the  following  conditions, 

(71:01AAH)  = 32H,  (71:01ABH)  = 92H,  RAMBR=71H 

the  register  R3  becomes  9232H  when  the  following  program  is 
executed: 

MOVE  R3,  (1AAH)  ;(71:01AAH)— >R3(Low  Byte)  (LMS  R3,  (01AAH)) 

;(71 :01  ABH)— >R3(High  Byte) 


2-9-84 


9.60  MOVE  (xx),  Rn 

MACRO  INSTRUCTION 


Operation:  Rn  (low  byte)  ->  (xx)  (n=0~15,  xx=0~FFFFH) 

Rn  (high  byte)  -»  (xx±1) 

Note:  If  the  value  of  xx  is  even,  store  the  high  byte  of  Rn  at 

(xx+1 ).  If  the  value  of  xx  is  odd,  store  the  high  byte  of  Rn 
at  (xx-1). 

Conditions:  If  (0000H<xx<01  FFH)  and  xx  is  even: 

then,  use  an  SMS  instruction, 
else,  use  an  SM  instruction. 

Description:  This  instruction  stores  the  contents  (hexadecimal  data)  of  regis- 

ter Rn  specified  in  the  second  operand  in  the  game  pak  RAM  ad- 
dress specified  in  the  first  operand.  The  RAMB  instruction  is 
used  to  specify  the  bank  of  the  game  pak  RAM  address  (refer  to 
“RAMB”). 

This  macro  instruction  is  stored  in  memory  as  “SM  (xx),  Rn”  or 
“SMS  (yy),  Rn.”  The  assembler  automatically  recognizes  wheth- 
er it  should  be  replaced  with  an  SM  instruction  or  an  SMS  in- 
struction, depending  upon  the  value  of  the  game  pak  RAM 
address  specified. 

When  the  game  pak  RAM  address  is  an  even  number  of 
0-1  FFH,  it  is  replaced  with  an  SMS  instruction.  Otherwise,  it  is 
replaced  with  an  SM  instruction.  Refer  to  “SM  (xx),  Rn”  and 
“SMS  (yy),  Rn”  for  machine  cycles,  flags  affected,  and  opcode. 

Example:  Under  the  following  conditions, 

R9:  BACDH,  and  RAMBR=71H 
when  the  following  program  is  executed, 

MOVE  (9CDEH),  R9  ;R9  (Low  Byte)^(71 :9CDEH)  (SM  (9CDEH),  R9) 

;R9  (High  Byte)— >(71:9CDFH) 

the  result  is  (71:9CDEH)=CDH,  (71 :9CDFH)=BAH 


2-9-85 


DESCRIPTION  OF  INSTRUCTIONS 


Also,  under  the  following  conditions, 

R2:  3248H,  and  RAMBR=70H 

when  the  following  program  is  executed, 

MOVE  (136H),  R2  ;R2  (Low  Byte)— >(70:01 36H)  (SMS  (136H),  R2) 

;R2  (High  Byte)~K70:0137H) 

the  result  is  (70:01 36H)=48H,  (70:01 37H)=32H 


2-9-86 


9.61  MOVEB  Rn,  (Rn’) 


MACRO  INSTRUCTION 

Operation:  (Rn’)  Rn  (Low  Byte)  (n=0~15,  n’=0-1 1) 

00H  — »Rn  (High  Byte) 

Conditions:  If  n=0: 

then,  use  only  LDB  instruction, 

else,  use  TO  instruction  and  LDB  instruction. 

Description:  This  instruction  loads  one  byte  of  data  located  at  the  game  pak 

RAM  address  equal  to  the  contents  of  register  Rn’,  specified  by 
the  second  operand  and  stores  this  data  in  the  register  specified 
in  the  first  operand.  The  high  byte  of  the  destination  register  is 
loaded  with  00H.  The  register  identified  in  the  second  operand  is 
selectable  from  R0~R-|  i . The  RAMB  instruction  is  used  to  specify 
the  game  pak  RAM  bank  (refer  to  “RAMB”). 

This  macro  instruction  is  stored  in  memory  as  “LDB  (Rm)”  or  “TO 
Rn”  + “LDB  (Rm).”  The  assembler  automatically  recognizes 
whether  or  not  the  TO  instruction  is  required.  When  n does  not 
equal  0,  the  TO  instruction  is  added.  Refer  to  “LDB  (Rm)”  and 
‘TO  Rn”  for  machine  cycles,  flags  affected,  and  opcode. 

Example:  Under  the  following  conditions, 

Rl=3482H,  (70:3482H)=51H,  RAMBR=70H 

when  the  following  program  is  executed, 

MOVEB  R7,  (R-|)  ;(Ri)-»R7  (Low  Byte)  (TO  R7+LDB  (R^) 

;00H-4R7  (High  Byte) 

register  R7  becomes  0051 H. 

Also,  under  the  following  conditions, 

R3=3581H,  (70:3581  H)=9AH,  RAMBR=70H 
when  the  following  program  is  executed, 

MOVEB  R0,(R3)  ;(R3)— >R0  (Low  Byte)  (LDB  (R3)) 

;00H— >R0  (High  Byte) 

register  R0  becomes  009AH. 


2-9-87 


9.62  MOVEB  (Rn’),  Rn 

MACRO  INSTRUCTION 


Operation:  Rn  (low  byte)  — > (Rn’)  (n=1  ~1 5,  n’=0~1 1) 

Conditions:  If  n=0: 

then,  use  only  STB  instruction, 

else,  use  FROM  instruction  and  STB  instruction. 

Description:  This  instruction  stores  the  contents  of  the  low  byte  of  register  Rn 

specified  in  the  second  operand  at  the  game  pak  RAM  address 
equal  to  the  contents  of  register  Rn’,  specified  in  the  first  oper- 
and. The  register  identified  in  the  first  operand  is  selectable  from 
Ro~Rn.  The  RAMB  instruction  is  used  to  specify  the  game  pak 
RAM  bank  (refer  to  “RAMB”). 

This  macro  instruction  is  stored  in  memory  as  “STB  (Rm)”  or 
“FROM  Rn”  + “STB  (Rm).”  The  assembler  automatically  recog- 
nizes whether  or  not  the  FROM  instruction  is  required.  When  n 
does  not  equal  0,  the  FROM  instruction  is  added.  Refer  to  “STB 
(Rm)  and  “FROM  Rn”  for  machine  cycles,  flags  affected,  and  op- 
code. 

Example:  Under  the  following  conditions, 

R5=3843H,  R1i=94F1H,  RAMBR=71H 
when  the  following  program  is  executed, 

MOVEB  (Rn),  R5  ;R5  (Low  Byte)-4(Rn)  (FROM  R5+STB  (R^)) 
the  result  is  (71:94F1H)=43H. 

Also,  under  the  following  conditions, 

R0=89EOH,  R3=438BH,  RAMBR=70H 
when  the  following  program  is  executed, 

MOVEB  (R3),  R0  ;R0  (Low  Byte)-»(R3)  (STB  (R3)) 
the  result  is  (70:438BH)=43H. 


2-9-88 


SNES  DEVELOPMENT  MANUAL 


9.63  MOVES  Rn,Rn’ 

Operation:  Rn’  ->  Rn  (n,  n’  = 0~15) 

Description:  This  instruction  loads  the  contents  of  register  Rn’,  specified  in  the 

second  operand,  to  register  Rn,  specified  in  the  first  operand. 
Flags  are  set  according  to  the  data  loaded. 

(Refer  to  MOVE  Rn,  Rn\) 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

* 

* 

- 

* 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

ON  : Set  if  Bit  7 is  “1  ”,  else  reset 

S : Set  if  Bit  1 5 is  “1”,  else  reset 

Z : Set  when  data  is  zero,  else  reset 


Opcode: 

MOVES  Rn,  Rn’ 


(MSB)  (LSB) 

(2n’  H) 

(BnH) 


0 

0 

1 

0 

n’  (OH-FH) 

1 

0 

1 

1 

n (OH-FH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  When  R7  is  4983H  and 

MOVES  Rio,  R7 

is  executed,  the  register  R10  becomes  4983H  and  the  overflow 
flag  is  set. 


2-9-89 


9.64  MOVEW  Rn,  (Rn’) 

MACRO  INSTRUCTION 


Operation:  (Rn’)  — > Rn  (Low  Byte)  (n=0~15,  n’=0~1 1) 

(Rn’±1)  Rn  (High  Byte) 

Note:  If  the  contents  of  Rn’  are  even,  store  the  address  equal 

to  the  contents  of  (Rn’+1)  in  the  high  byte  of  Rn.  If  the 
contents  of  Rn’  are  odd,  store  the  address  equal  to 
(Rn’-1)  in  the  high  byte  of  Rn. 

Conditions:  If  n=0: 

then,  use  only  LDW  instruction, 

else,  use  TO  instruction  and  LDW  instruction. 

Description:  This  instruction  loads  hexadecimal  data  from  the  game  pak  RAM 

address  equal  to  the  contents  of  register  Rn’  specified  in  the  sec- 
ond operand  and  stores  it  into  register  Rn  specified  by  the  first 
operand.  The  game  pak  RAM  address  bank  is  specified  using 
the  RAMB  instruction  (refer  to  RAMB). 

This  macro  instruction  is  stored  in  memory  as  “LDW  (Rm)”  or  ‘TO 
Rn”  + “LDW  (Rm).”  The  assembler  automatically  recognizes 
whether  or  not  the  TO  instruction  is  required.  When  n is  not 
equal  to  0,  the  TO  instruction  is  added.  Refer  to  “LDW  (Rm)”  and 
“TO  Rn"  for  machine  cycles,  flags  affected,  and  opcode. 

Example:  Under  the  following  conditions, 

R3=6480H,  (71 :6480H)=2EH,  (71:6481H)=C0H, 
RAMBR=71H 

and  when  the  following  program  is  executed, 

MOVEW  R5,  (R3)  ;(R3)— >R5(Low  Byte)  (TO  R5  + LDB  (R3)) 

;(R3+1)— >R5(High  Byte) 

register  R5  becomes  C02EH. 

Also,  under  the  following  conditions, 

R6=0822H,  (70:0822H)=43H,  (70:0823H)=96H, 
RAMBR=70H 

and  when  the  following  program  is  executed, 

MOVEW  R0,  (R6)  ;(R6)— >R0(Low  Byte)  (LDB  (R6)) 

;(R6+1)->R0(High  Byte) 

register  R0  becomes  9643H. 


2-9-90 


9.65  MOVEW  (Rn’),  Rn 

MACRO  INSTRUCTION 


Operation:  Rn  (low  byte)  ->  (Rn’)  (n=0~15,  n’=0~1 1) 

Rn  (high  byte)  — » (Rn’  ±1) 

Note:  If  the  contents  of  Rn’  are  even,  store  the  high  byte  of  Rn 

into  the  address  equal  to  the  contents  of  (Rn’+1).  If  the 
contents  of  Rn’  are  odd,  store  the  high  byte  of  Rn  into 
the  address  equal  to  the  contents  of  (Rn’-1). 

Conditions:  If  n=0: 

then,  use  only  STW  instruction, 

else,  use  FROM  instruction  and  STW  instruction. 

Description:  This  instruction  stores  the  contents  (hexadecimal  data)  of  regis- 

ter Rn  specified  in  the  second  operand  into  the  game  pak  RAM 
address  which  is  equal  to  the  value  of  register  Rn’  specified  in 
the  first  operand.  The  game  pak  RAM  address  bank  is  specified 
using  the  RAMB  instruction  (refer  to  RAMB).  The  operand  n’  can 
be  a register  from  R0~Rn. 

This  macro  instruction  is  stored  in  memory  as  “STW  (Rm)”  or 
“FROM  Rn”  + “STW  (Rm).”  The  assembler  automatically  recog- 
nizes whether  or  not  the  FROM  instruction  is  required.  When  n is 
not  equal  to  0,  the  FROM  instruction  is  added.  Refer  to  “STW 
(Rm)  and  “FROM  Rn”  for  machine  cycles,  flags  affected,  and  op- 
code. 

Example:  Under  the  following  conditions, 

R9=BFA3H,  R-|  0=4444 H,  RAMBR=71H 

and  when  the  following  program  is  executed, 

MOVEW  (Rio),  R9  ;R9(Low  Byte)-^(R10)  (FROM  R9+STW  (R10)) 

;R9(High  Byte)-»(R10+1) 

the  result  is  (71:4444H)=A3H,  (71:4445H)=BFH. 


2-9-91 


DESCRIPTION  OF  INSTRUCTIONS 

Also,  under  the  following  conditions, 

R0=3151H,  R6=92A0H,  RAMBR=71H 

and  when  the  following  program  is  executed, 

MOVEW  (R6),  R0  ;R0  (Low  Byte)->(R6)  (STW  (R6)) 

;R0  (High  Byte)->(R6+1) 

the  result  is  (71:92A0H)=51H,  (71:92A1H)=31H. 


2-9-92 


SNES  DEVELOPMENT  MANUAL 


9.66  MULT  Rn 

Operation:  Sreg  (low  byte)  * Rn  (low  byte)  ->  Dreg  (n=0~1 5) 

Description:  This  instruction  performs  8 x 8-bit  signed  multiplication  using  the 

low  byte  of  the  source  register  and  the  low  byte  of  register  Rn. 
The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

The  operand  can  be  a register  R0~R15. 


Flags  affected: 


B 

ALT1 

ALT2  O/V  S 

CY 

Z 

0 

0 

0 

- 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 

MULT  Rn 


Machine  Cycles:  ROM  execution  time  3 or  5 cycles 

RAM  execution  time  3 or  5 cycles 

Cache  RAM  execution  time  1 or  2 cycles 

Note:  The  number  of  cycles  depends  upon  the  CFGR  register. 

Example:  Under  the  following  conditions, 

Sreg:  R5.  Dreg:  R2 
R5=  52CFH,  R-j=  63CFH 

the  register  R2  becomes  0961 H when 

MULT  Rt 

is  executed. 


2-9-93 


9.67  MULT  #n 

Operation: 

Description: 


DESCRIPTION  OF  INSTRUCTIONS 


D 


Sreg  (low  byte)  * #n  ->  Dreg  (n=0~1 5) 

This  instruction  performs  8 x 8-bit  signed  multiplication  using  the 
low  byte  of  the  source  register  and  the  immediate  data  specified 
in  the  operand  #n.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

The  operand  can  be  immediate  data  from  0-15. 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 


MULT  #n 


(MSB)  (LSB) 

(3EH) 
(8nH) 


0 

0 

1 

1 

1 

1 

1 

0 

1 

0 

0 

0 

n (OH-FH) 

Machine  Cycles:  ROM  execution  time  6 or  8 cycles 

RAM  execution  time  6 or  8 cycles 

Cache  RAM  execution  time  2 or  3 cycles 

Note:  The  number  of  cycles  depends  upon  the  CFGR  register. 

Example:  Under  the  following  conditions, 

Sreg-  ^3>  l-Veg-l^4>  ^3=  95C6H 
the  register  R4  becomes  FDF6H  when 
MULT  #9 


is  executed. 


2-9-94 


SNES  DEVELOPMENT  MANUAL 


9.68  NOP 


Operation:  PC  <—  PC+1 

Description:  This  instruction  causes  the  processor  to  idle  for  one  cycle  and  in- 

crement the  program  counter  by  one. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V  S 

O 

-< 

N 

0 

0 

0 

- 

- 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

Opcode: 

(MSB) 

(LSB) 

NOP 

0 

0 0 

0 0 

0 0 1 (01 H) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-95 


DESCRIPTION  OF  INSTRUCTIONS 


1 


9.69  NOT 


Operation:  Sreg  — > Dreg 

Description:  This  instruction  calculates  the  1 ’s  complement  of  the  source  reg- 

ister and  stores  the  result  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 


NOT 


(MSB) 


(LSB) 


0 

1 

0 

0 

1 

1 

1 

1 

(4FH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions, 

^reg-  ^9>  ^reg-  ^13 


□ 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

the  execution  of 
NOT 
results  in: 


R 


13- 


0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

2-9-96 


9.70  OR  Rn 


Operation:  Sreg  OR  Rn  Dreg  (n=1  ~15) 

Description:  This  instruction  performs  logical  bit-wise  OR  on  corresponding 

bits  of  the  source  register  and  the  register  specified  in  the  oper- 
and Rn.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

The  operand  can  be  a register  Ri~R15. 

Flags  affected: 


B 

ALT1 

ALT2  ON  S 

CY 

Z 

0 

0 

0 

* 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 


(LSB) 

n (1H-FH)  I (CnH) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-97 


DESCRIPTION  OF  INSTRUCTIONS 


Example: 


Under  the  following  conditions, 


Sreg:  ^4>  ^reg’  ^5 
Bitl  5 


BitO 


R4: 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

Bitl  5 

BitO 

R2: 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

1 o| 

the  register  R5 

becomes: 

Bitl  5 

BitO 

R5: 

0 

0 

0 

m 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

0 

o| 

when 

OR  R2 
is  executed. 


2-9-98 


9.71  OR  #n 


Operation:  Sreg  OR  #n  — » Dreg  (n=1~15) 

Description:  This  instruction  performs  logical  bit-wise  OR  on  corresponding 

bits  of  the  source  register  and  the  immediate  data  specified  in 
the  operand  #n.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  ON  S 

CY 

Z 

0 

0 

0 

- 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 

OR  #n 


(MSB)  (LSB) 

(3EH) 
(CnH) 


Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

^reg-  ^7>  ^reg:  ^5 


when 

OR  #5H 
is  executed. 


2-9-99 


DESCRIPTION  OF  INSTRUCTIONS 


9.72  PLOT 

Description:  This  instruction  plots  the  color  code  specified  by  the  COLOR  or 

GETC  instruction  to  locations  X and  Y specified  by  R-,  and  R2. 
After  plotting,  Ri  will  be  incremented. 

Flags  affected: 


B 

ALT1 

ALT2 

OA/  S 

CY  Z 

0 

0 

0 

- 

- 

Opcode: 

B 

ALT1 

ALT2 

(MSB) 

: Reset 
: Reset 
: Reset 

(LSB) 

PLOT  0 1 0 0 1 1 0 0 (4CH) 


Machine  Cycles:  ROM  execution  time  3~48  cycles 

RAM  execution  time  3~51  cycles 

Cache  RAM  execution  time  1 ~48  cycles 

Note:  Because  this  instruction  uses  the  RAM  buffer,  the  number  of  ma- 

chine cycles  varies  depending  upon  the  program. 


2-9-100 


9.73  RAMB 


Operation:  Sreg  — » RAMBR 

Description:  This  instruction  moves  the  low  byte  of  the  source  register  into  the 

game  pak  RAM  bank  register  in  order  to  specify  the  game  pak 
RAM  bank  when  transferring  data  between  game  pak  RAM  and 
multi-purpose  registers.  Note  that  the  SCBR  is  used  with  the 
RAMBR  to  specify  the  bank  for  plotting.  The  game  pak  RAM 
bank  register  can  only  be  changed  with  the  RAMB  instruction. 
The  initial  value  of  this  register  is  invalid. 

The  source  register  is  specified  in  advance  using  a FROM  or 
WITH  instruction.  When  not  specified,  the  register  defaults  to 

R0- 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode:  (MSB)  (LSB) 

(3EH) 
(DFH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

Sreg:  R3.  R3=  0170H 

the  RAM  bank  register  becomes  70H  when 
RAMB 
is  executed. 


2-9-101 


DESCRIPTION  OF  INSTRUCTIONS 


9.74  ROL 


Operation: 


T \ 


CY 

D15 

Sreg 

DO 

r 

-H 

- 

- 

- 

- 

mJ 

\ 

DrO 


D15  ureg  DO 

• • • 

Description:  This  instruction  shifts  all  bits  in  the  source  register  one  bit  to  the 

left.  Bit  15  is  shifted  to  the  carry  flag  and  the  carry  flag  is  shifted 
to  Bit  0.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


Opcode: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

★ 

★ 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Set  if  result  is  negative,  else  reset. 

CY 

: Set  if  Bit  15  in  source  register  is  “1” 
else  reset. 

Z 

: Set  on  zero  result,  else  reset. 

(MSB) 

(LSB) 

ROL 


0 

0 

0 

0 

0 

1 

0 

0 

(04H) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-102 


SNES  DEVELOPMENT  MANUAL 


executing  ROL  results  in: 

CY  bit15  bitO 

\o\  R4;  | 0 1 0 1 1 |l  |l  1 0 [ 1 |o[l|o|o|l|o|l|l~[T|  (3A97H) 


2-9-103 


DESCRIPTION  OF  INSTRUCTIONS 


9.75  ROMB 

Operation:  Sreg  — > ROMBR 

Description:  This  instruction  moves  the  low  byte  of  the  source  register  into  the 

game  pak  ROM  bank  register  in  order  to  specify  the  game  pak 
ROM  bank  when  loading  data  from  game  pak  ROM.  The  game 
pak  ROM  bank  register  can  only  be  changed  with  the  ROMB  in- 
struction, but  the  contents  can  not  be  read.  The  initial  value  of 
this  register  is  invalid. 

The  source  register  is  specified  in  advance  using  a FROM  or 
WITH  instruction.  When  not  specified,  the  source  register  de- 
faults to  R0. 

Flags  affected: 


B ALT1 

ALT2  ON  S CY 

2 

f 

0 0 

0 - - - 

- 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

Opcode:  (MSB) 

(LSB) 

ROMB  0 

0 11111 

1 

(3FH) 

1 

10  1111 

1 

(DFH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions, 

Sreg:  r5-  r5=  0046H 
the  ROMBR  becomes  46H  when 
ROMB 
is  executed. 


2-9-104 


9.76  ROR 

Operation: 


Description:  This  instruction  shifts  all  bits  in  the  source  register  one  bit  to  the 

right.  Bit  0 is  shifted  to  the  carry  flag  and  the  carry  flag  is  shifted 
to  Bit  15.  The  result  is  stored  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


Opcode: 


B 

ALT1 

ALT2  ON 

S 

CY 

Z 

0 

0 

0 

* 

* 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Set  if  result  is  negative,  else  reset. 

CY 

: Set  if  Bit  0 in  source  register  is  “1”, 
else  reset. 

Z 

: Set  on  zero  result,  else  reset. 

(MSB)  (LSB) 

ROR  10  0 1 0 1 11  (97H) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-105 


DESCRIPTION  OF  INSTRUCTIONS 


Example:  Under  the  following  conditions, 

Sreg:  R10,  Dreg:  R12 

CY  bit  15  bitO 

[T]  R10;|  0 1 0 1 0 [ 1 |l|l|o|l|o|l|o|o|l|o|l|l|  (1D4BH) 

executing  ROR  results  in: 

CY  bit  15  bitO 

T|  R12|  1 |0  |0  1 0 1 1 |l  1 1 1 0 1 1 1 0 1 1 | 0 1 0 1 1 1 p|  1 | (8EA5H) 


2-9-106 


9.77  RPIX 


Operation:  PIXEL  COLOR  from  game  pak  RAM  — > Dreg 

Description:  This  instruction  loads  the  color  data  stored  in  game  pak  RAM 

and  stores  it  in  the  destination  register.  Because  data  in  game 
pak  RAM  is  in  the  PPU  format,  it  is  first  read  to  the  color  matrix 
and  subsequently  stored  in  the  destination  register.  The  data  is 
then  read  from  game  pak  RAM  to  the  color  matrix. 

Flags  affected: 


B 

ALT1 

ALT2  ON  S 

CY 

Z 

0 

0 

0 

- 

★ 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 

Opcode:  (MSB)  (LSB) 

(3DH) 

(4CH) 

Machine  Cycles:  ROM  execution  time  24-80  cycles 

RAM  execution  time  24-78  cycles 

Cache  RAM  execution  time  20-74  cycles 


2-9-107 


9.78  SBC  Rn 

Operation:  Sreg  - Rn  - CY  Flag— > Dreg  (n=0~15) 

Description:  This  instruction  subtracts  the  contents  of  the  register  specified  in 

the  operand  and  the  carry  flag  from  the  source  register  and 
stores  the  result  in  the  destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

★ 

* 

★ 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


O/V  : Set  on  signed  overflow,  else  reset 

S : Set  when  the  result  is  negative,  else  reset. 

CY  : Set  on  unsigned  overflow,  else  reset 

Z : Set  on  zero  result,  else  reset 

Opcode:  (MSB)  (LSB) 

(3DH) 

(6nH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions: 

Sreg:  R4,  Dreg:  R6,  R4=5682H,  R5=3609H,  CY  Flag=1 
register  R6  becomes  2079H  and  the  carry  flag  is  reset  when 
SBC  R5 
is  executed. 


2-9-108 


9.79  SBK 


Operation:  Sreg  — > (Last  game  pak  RAM  address  used) 

Description:  The  game  pak  RAM  address  accessed  when  data  is  transferred 

between  game  pak  RAM  and  a multi-purpose  register,  for  exam- 
ple the  LD  and  ST  instructions,  is  buffered  internally.  When  data 
is  to  be  stored  to  the  last  accessed  game  pak  RAM  address,  this 
buffer  is  used  so  that  the  address  does  not  have  to  be  specified 
again  in  the  op  code.  This  is  called  “bulk  processing”. 

This  instruction  uses  bulk  processing  to  store  the  word  data  con- 
tained in  the  source  register  to  RAM. 

The  source  register  is  specified  in  advance  using  a WITH  or 
FROM  instruction.  When  not  specified,  the  register  defaults  to 
R0. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT  1 : Reset 

ALT2  : Reset 

Opcode:  (MSB)  (LSB) 

SBK  1 0 0 1 0 0 0 0 (90H) 

Machine  Cycles:  ROM  execution  time  3~8  cycles 

RAM  execution  time  7~1 1 cycles 

Cache  RAM  execution  time  1 -6  cycles 

Example:  Under  the  following  conditions, 

(70:3230H)=51H,  (70:3231  H)=49H,  RAMBR=70H 
executing, 

LM  R-j , (3230H) 

INC  R1 

SBK 

will  result  in  R1=4952H,  (70:3230H)=52H,  and  (70:3231  H)=49H. 


2-9-109 


DESCRIPTION  OF  INSTRUCTIONS 


3 


9.80  SEX 

Operation: 


D15 

D8  D7 

D6 

DO 

^reg 

Upper  Byte 

r 

Lower  Byte 

U333_lUi 


Dreg 

Lower  Byte 

D15 

D8  D7  D6 

DO 

Description:  This  instruction  performs  signed  expansion  of  the  low  byte  of  the 

source  register,  converts  it  to  word  data  and  stores  it  in  the  desti- 
nation register. 

This  means  that  Bit  7 of  the  source  register  is  stored  in  Bits  8 ~ 
15  of  the  destination  register.  The  low  byte  is  loaded  directly 
from  the  source  register  to  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


Opcode: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

* 

- 

★ 

SEX 


B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

S 

: Set  if  the  result  is  negative,  else  reset. 

Z 

: Set  on  zero  result,  else  reset. 

(MSB) 

(LSB) 

1 

0 

0 

1 

0 

1 

0 

1 

(95H) 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-110 


SNES  DEVELOPMENT  MANUAL 


Example:  Under  the  following  conditions, 

Sreg-  ^5>  ^reg'Rl  > Rs=  9284H 
the  register  R-,  becomes  FF84H  when 
SEX 

is  executed. 


2-9-111 


DESCRIPTION  OF  INSTRUCTIONS 


9.81  SM(xx),  Rn 

(n=0~15,  xx=0~65535) 

When  the  contents  of  Rn  are 
even,  the  high  byte  is 
stored  at  address  (Rn+1); 
When  the  contents  of  Rn  are 
odd,  the  high  byte  is 
stored  at  address  (Rn-1 ). 

Description:  This  instruction  stores  the  contents  of  register  Rn,  specified  in 

the  second  operand,  to  the  game  pak  RAM  address  which 
equals  the  value  of  (xx),  the  first  operand.  The  RAM  bank  must 
be  specified  with  the  RAMB  instruction.  (Refer  to  RAMB.) 


Operation:  Rn  (low  byte)  —>  (xx) 

Rn  (high  byte)  — > (xx+1 ) 


Flags  affected: 


B 

ALT1 

ALT2 

o/v 

s 

CY 

z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 


(MSB) 


(LSB) 


SM  (xx),  Rr 


0 

0 

1 

1 

1110 

1 

1 

1 

1 

n (OH-FH) 

x (00H-FFH) 

x (00H-FFH) 

(3EH) 

(FnH) 

(ADRS 

(ADRS 


Lower  Byte) 
Upper  Byte) 


Machine  Cycles:  ROM  execution  time  12-17  cycles 

RAM  execution  time  1 6-20  cycles 

Cache  RAM  execution  time  4-9  cycles 

Note:  Because  this  instruction  uses  the  RAM  buffer,  the  number  of  cy- 

cles varies  depending  upon  the  program. 

Example:  Under  the  following  conditions, 

R4=  438CH  and  RAMBR=70H 
the  following  program  execution, 

SM  (0B492H),  R4 

will  result  in  (70:B492H)  =8CH,  (70:B493H)  = 43H. 


2-9-112 


9.82  SMS(yy),  Rn 

Operation:  Rn  (low  byte)  ->  (yy)  (n=0~15,  yy=0~510*) 

Rn  (high  byte)  -»  (yy+1) 


*Note:  Selectable  RAM  address  (yy)  must  be  an  even  number. 

Description:  Similar  to  SM,  this  instruction  loads  word  data  from  register  Rn, 

specified  in  the  second  operand,  and  stores  it  in  the  game  pak 
RAM  address  equal  to  the  value  specified  in  the  first  operand, 
yy.  The  selectable  address  is  an  even  number  0-510.  The  bank 
is  specified  with  the  RAMB  instruction.  This  instruction  uses  the 
short  address  method  to  reduce  the  number  of  bytes  in  the  in- 
struction code. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode:  (MSB) 


(LSB) 


(3EH) 

(AnH) 

(Address) 


[Short  address  method] 

This  method  is  used  by  LMS,  SMS  and  other  instructions  to  re- 
duce the  number  of  bytes  in  the  instruction  code.  One  byte  is 
used  for  the  address.  The  selectable  address  may  be  an  even 
number  0-510.  The  relationship  between  yy  in  the  syntax  and  kk 
in  the  opcode  is: 

yy  = kk  x 2 


Machine  Cycles:  ROM  execution  time  9-14  cycles 

RAM  execution  time  13-17  cycles 

Cache  RAM  execution  time  3-8  cycles 

Note:  Because  this  instruction  uses  the  RAM  buffer,  the  number  of  ma- 

chine cycles  varies  depending  upon  the  program. 


2-9-113 


DESCRIPTION  OF  INSTRUCTIONS 


Example:  Under  the  following  conditions, 

Register  R11=ABCDH,  RAMBR=71H 

the  following  program  is  execution, 

Syntax  Opcode 

SMS  (194H),  Rn  3EABCA 

will  result  in  (71 :0194H)  = CDH,  (71 :0195H)  = ABH.  The  relation- 
ship between  syntax  and  opcode  is  as  shown  above. 


9.83  STB  (Rm) 

Operation:  Sreg  (low  byte)  (Rm)  (m=0~1 1) 

Description:  This  instruction  stores  the  low  byte  of  the  source  register  in  the 

game  pak  RAM  address  equal  to  the  value  in  the  register  speci- 
fied in  the  operand.  The  operand  can  be  a register  R0~Rii.  The 
game  pak  RAM  bank  must  be  specified  with  the  RAMB  instruc- 
tion. 

The  source  register  is  specified  in  advance  using  a WITH  or 
FROM  instruction.  When  not  specified,  the  register  defaults  to 

R0- 

Flags  affected: 


ALT1  : Reset 

ALT2  : Reset 

Opcode:  (MSB)  (LSB) 

(3DH) 

(3m  H) 

Machine  Cycles:  ROM  execution  time  6~9  cycles 

RAM  execution  time  8-14  cycles 

Cache  RAM  execution  time  2-5  cycles 

Note:  Because  this  instruction  uses  the  RAM  buffer,  the  number  of  ma- 

chine cycles  varies  depending  upon  the  program. 

Example:  Under  the  following  conditions, 

Sreg:R5,  R5=216CH,  R8=9A34H,  RAMBR=70H 
and  when  the  following  program  is  executed, 

STB  (R8) 
the  result  is  (70:9A34H)=6CH. 


2-9-115 


9.84  STOP 

Operation:  0 — » Go  flag 


Description:  This  instruction  resets  the  GSU  GO  flag  and  stops  the  processor. 

When  this  instruction  is  executed  and  the  GSU  stops,  the  Super 
NES  IRQ  signal  is  initiated. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

Opcode:  (MSB)  (LSB) 

STOP  0000  0 000  (00H) 

Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 


2-9-116 


SNES  DEVELOPMENT  MANUAL 

I 


9.85  STW  (Rm) 

(m=0~1 1) 

When  the  contents  of  Rm  are 
even,  the  high  byte  is 
stored  at  address  (Rm+1); 
When  the  contents  of  Rm  are 
odd,  the  high  byte  is 
stored  at  address  (Rm-1). 

Description:  This  instruction  stores  the  contents  of  the  source  register  into  the 

game  pak  RAM  address  specified  in  the  operand,  Rm.  The  RAM 
bank  must  be  specified  with  the  RAMB  instruction.  The  operand 
can  be  a register  from  R0~Rii. 

The  source  register  is  specified  in  advance  using  WITH  or 
FROM.  When  not  specified,  the  register  defaults  to  R0. 


Operation:  Sreg  (low  byte)  — > (Rm) 

sreg  (high  byte) ->  (Rm +1) 


Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

- 

- 

- 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


Opcode: 

STW  (Rm) 


(MSB)  (LSB) 


0 

0 

1 

1 

m (OH-BH) 

(3mH) 


Machine  Cycles:  ROM  execution  time  3~8  cycles 

RAM  execution  time  7~1 1 cycles 

Cache  RAM  execution  time  1 ~6  cycles 

Note:  Because  this  instruction  uses  the  RAM  buffer,  the  number  of  cy- 

cles varies  depending  upon  the  program. 

Example:  Under  the  following  conditions, 

Sreg:R10,  Rio=9326H,  R2:5872H,  RAMBR=70H 

and  when  the  following  program  is  executed, 

STW  (R2) 

the  result  is  (70:5872H)=26H,  (70:5873H)=93H. 


2-9-117 


DESCRIPTION  OF  INSTRUCTIONS 


9.86  SUB  Rn 

Operation:  Sreg  - Rn  -» Dreg  (n=0~15) 

Description:  This  instruction  subtracts  the  contents  of  the  register  specified  in 

the  operand  from  the  source  register  and  stores  the  result  in  the 
destination  register. 

Source  and  destination  registers  are  specified  in  advance  using 
a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

The  operand  can  be  any  of  registers  R0~R15. 

Flags  affected: 


B 

ALT1 

ALT2  ON 

S 

CY 

Z 

0 

0 

0 

★ 

★ 

★ 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

ON  : Set  on  signed  overflow,  else  reset. 

S : Set  if  the  result  is  negative,  else  reset 

CY  : Set  on  unsigned  overflow,  else  reset 


(Set  on  adder  overflow.) 
Z : Set  if  result  is  zero. 


Opcode: 

(MSB) 

(LSB) 

SUB  Rn 

0 110 

n (0H~ 

FH)  (6nH) 

Machine  Cycles: 

ROM  execution  time 

3 cycles 

RAM  execution  time 

3 cycles 

Cache  RAM  execution  time 

1 cycles 

Example: 

Under  the  following  conditions: 

Sreg:  ^reg:  ^5= 

=735AH, 

, R8=426BH 

the  register  R4  becomes  30EFH  when 
SUB  R8 


is  executed. 


2-9-118 


9.87  SUB  #n 

Operation:  Sreg  - #n  ->  Dreg  (n=0~1 5) 

Description:  This  instruction  subtracts  the  immediate  data  specified  in  the  op- 

erand from  the  contents  of  the  source  register  and  stores  the  re- 
sult in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a WITH,  FROM,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

The  operand  can  be  immediate  data  from  0-15. 

Flags  affected: 


B 

ALT1 

ALT2  ON  S 

CY 

Z 

0 

0 

0 

★ 

* 

B 

: Reset 

ALT1 

: Reset 

ALT2 

: Reset 

ON  : Set  on  signed  overflow,  else  reset. 

S : Set  if  the  result  is  negative,  else  reset 

CY  : Set  on  unsigned  borrow,  else  reset 

Z : Set  if  result  is  zero. 

Opcode:  (MSB)  (LSB) 

(3EH) 

(6nH) 

Machine  Cycles:  ROM  execution  time  6 cycles 

RAM  execution  time  6 cycles 

Cache  RAM  execution  time  2 cycles 

Example:  Under  the  following  conditions: 

Sreg’  Ro>  Dreg:  Ro>  Ro=^29BH 
the  register  R0  becomes  3291 H when 
SUB  #10 
is  executed. 


2-9-119 


9.88  SWAP 


Operation:  Sreg  (low  byte)  — > Dreg  (high  byte) 

sreg  (high  byte)  Dreg  (low  byte) 

Description:  This  instruction  swaps  the  low  byte  and  high  byte  of  the  source 

register  and  stores  the  result  in  the  destination  register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2  O/V 

S 

CY 

Z 

0 

0 

0 

★ 

- 

* 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 

S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 

(MSB) 

(LSB) 

SWAP 

0 10  0 1 1 

0 1 (4DH) 

Machine  Cycles: 

ROM  execution  time 

3 cycles 

RAM  execution  time 

3 cycles 

Cache  RAM  execution  time 

1 cycles 

Example: 

Under  the  following  conditions: 

Sreg-  ^3>  ^reg-  ^13>  R3— 48D0H 
the  register  R13  becomes  D048H  when 
SWAP 
is  executed. 


2-9-120 


9.89  TO  Rn 

REGISTER  PREFIX  INSTRUCTION 

Operation:  If  B Flag  = 0 then  set  Dreg  to  Rn 

else  Sreg  — > Rn  (n=0~1 5) 

Description:  This  instruction  specifies  register  Rn  as  the  destination  register. 

The  destination  register  can  be  any  of  registers  R0  ~ R-15. 

If  the  B flag  has  been  set  (i.e.,  if  a WITH  instruction  was  execut- 
ed immediately  prior  to  this  instruction)  the  contents  of  the 
source  register  are  loaded  to  Rn  (refer  to  MOVE  Rn,  Rn’). 

Flags  affected: 


B 

ALT1 

ALT2 

ON 

S 

CY 

Z 

- 

- 

- 

- 

- 

- 

- 

No  flags  affected 


Opcode: 


TO  Rn 


Machine  Cycles:  ROM  execution  time  3 cycles 

RAM  execution  time  3 cycles 

Cache  RAM  execution  time  1 cycles 

Example:  Under  the  following  conditions: 

R6=  7106H,  R3=0028H 

the  register  R4  becomes  712EH  when  the  following  program  is 
executed. 


FROM  R6 

TO  R4 

ADD  R3 


2-9-121 


DESCRIPTION  OF  INSTRUCTIONS 


1 


9.90  UMULT  Rn 

Operation:  Sreg  (low  byte)  * Rn  (low  byte)  — > Dreg 

Description:  This  instruction  performs  8 x 8-bit  unsigned  multiplication  using 

the  low  byte  of  the  source  register  and  the  low  byte  of  register 
Rn,  specified  in  the  operand.  The  result  is  stored  in  the  destina- 
tion register. 

The  source  and  destination  registers  are  specified  in  advance 
using  a FROM,  WITH,  or  TO  instruction.  When  not  specified,  the 
source  and  destination  registers  default  to  R0. 

Flags  affected: 


B 

ALT1 

ALT2 

O/V 

S 

CY 

Z 

0 

0 

0 

- 

★ 

- 

* 

B : Reset 

ALT1  : Reset 

ALT2  : Reset 


S : Set  when  the  result  is  negative,  else  reset. 

Z : Set  on  zero  result,  else  reset. 


Opcode: 


(MSB) 


(LSB) 


UMULT  Rn 


0 

0 

1 

1 

1 

1 

0 

1 

1 

0 

0 

0 

n (OH-FH) 

(3DH) 

(8nH) 


Machine  Cycles:  ROM  execution  time  6 or  8 cycles 

RAM  execution  time  6 or  8 cycles 

Cache  RAM  execution  time  2 or  3 cycles 

Note:  The  number  of  cycles  depends  on  the  CONFIG  register  setting. 

Example:  Under  the  following  conditions, 

Sreg’  ^3’  Dreg:  ^0>  ^3=  364FH,  R8=  B2CFH 
the  register  R0  becomes  3FE1 H when 
UMULT  R8 
is  executed. 


2-9-122 


SNES  DEVELOPMENT  MANUAL 


INTRODUCTION  TO  DSP1 


Chapter  1 Introduction  to  DSP1 

Digital  Signal  Processor  (DSP  1 ) is  a 1 6-bit  fixed  point  digital  signal  processor  designed  as  a co- 
processor for  the  Super  Nintendo  Entertainment  System  (Super  NES).  It  provides  the  Super  NES 
programmer  with  advanced,  high  speed,  pseudo  three-dimensional  programming  capabilities. 
These  functions  are  possible  through  the  use  of  a command  set  held  by  the  DSPl’s  internal  ROM. 

1 .1  SUPER  NES  CPU  SUPPORT 

DSP1  supports  processing  of  the  Super  NES  CPU  through  parallel  operation.  The 
increased  processing  speed  and  advanced  processing  capability  greatly  improves 
the  realism  of  Super  NES  games. 

1 .2  PSEUDO  3-DIMENSIONAL  GRAPHICS 

Because  numerous  commands  for  3-dimensional  graphics  are  incorporated, 
DSP1  is  especially  useful  for  3-dimensional  games,  such  as  those  involving  flight 
simulation. 

1 .3  COMPLEX  MATH  PROCESSING 

General  purpose  commands  for  complex  math  calculation  are  also  included  within 
the  DSP1  ROM.  Calculations  can  be  executed  much  faster  than  with  the  Super 
NES  CPU.  Therefore,  DSP1  is  useful  in  games  which  require  high  speed  multipli- 
cation, division,  and  calculation  of  trigonometric  functions. 

1 .4  SYSTEM  BLOCK  DIAGRAM 

The  system  block  diagram,  on  the  following  page,  illustrates  the  means  by  which 
the  DSP1  is  connected  to  the  Super  NES. 


3-1-1 


Figure  3-1-1  System  Block  Diagram  (DSP1) 


3-1-2 


INTRODUCTION  TO  DSP1 


[ 


1.5  DSP1  OPERATION 

1.5.1  COMMAND  EXECUTION 

The  DSP1  receives  commands  from  the  Super  NES  CPU  and  returns  the 
results  of  its  computations. 


Super  NES 
CPU 

Command  Parameters  ^ 

Results  of  Computation 

Figure  3-1-2  Super  NES  CPU  and  DSP1  Communications 

Command  execution  between  the  Super  NES  and  DSP1  is  demonstrated 
below. 


1) 

2) 

3) 


Command  (Multiplication:  1 byte) 
Parameter  1 (Multiplicand  16  bits) 
Parameter  2 (Multiplier  16  bits) 


Super  NES 

CPU 


Command  reception 
and  interpretation 


4)  Computation 

5)  Computation  Result  (16  bits) 

DSP 


Figure  3-1-3 


DSP1  Command  Execution 


Super  NES  Memory  Map  (20  Mode/DSP 


1.6.1  MODE  20/DSP 


Figure  3-1-4  Mode  20/DSP  Memory  Map 


3-1-4 


Super  NES  Memory  Map  (21  Mode/DSP) 


INTRODUCTION  TO  DSP1 


1.6.2  MODE  21/DSP 


Figure  3-1-5  Mode  21/DSP  Memory  Map 


3-1-5 


Note  1 : Use  6000H/7000H  as  the  read/write  port  for  DSP1  operations. 


SNES  DEVELOPMENT  MANUAL 


~] 


Chapter  2 Command  Summary 


TYPE 

COMMAND 

NAME 

FUNCTION 

General 

Multiply 

16-bit  multiplication 

00H 

26 

3.4 

Calculation 

(decimal,  interger) 

Inverse 

Triangle 

Inverse  calculation 
(floating  point) 

10H 

98 

12.9 

Trigonometric 
calculation  (sin,  cos) 

04H 

59 

7.8 

Vector 

Radius 

Vector  size 

08H 

34 

4.5 

Calculation 

calculation 

Range 

Distance 

Vector  size 
comparison 

18H 

38 

5.0 

Vector  absolute 
value  calculation 

28H 

156 

20.5 

Coordinate 

2-D  coordinate 

65 

8.6 

Calculation 

M8HB 

rotation 

3-D  coordinate 
rotation 

1CH 

147 

19.3 

Projection 

Calculation 

Parameter 

Projection  parameter 

setting 

Raster  data 

02  H 

892 

117.4 

Raster 

OAH 

224+209(n-1) 

29.5+27.5(n-1) 

Project 

calculation 

1AH 

224+208  n-1 

29.5+27.4(n-1 

Object  projection 
calculation 

06H 

627 

82.5 

Target 

Coordinate 
calculation  of  a 
selected  point  on 
the  screen 

OEH 

228 

30.0 

Attitude 

Attitude 

Set  attitude 

01 H 

164 

21.6 

Control 

1 1 H 

164 

21.6 

21 H 

164 

21.6 

Objective 

Convert  from  global 

ODH 

45 

5.9 

to  object  coordinates 

1DH 

45 

5.9 

2DH 

45 

5.9 

Subjective 

Convert  from  object 

03H 

44 

5.8 

to  global  coordinates 

13H 

44 

5.8 

23H 

44 

5.8 

Scalar 

Calculation  of  inner 

OBH 

36 

4.7 

product  with  the 

1BH 

36 

4.7 

forward  attitude  and 
a vector 

2BH 

36 

4.7 

New  Angle 
Calculation 

Gyrate 

3-D  angle 
rotation 

14H 

444 

58.4 

Table  3-2-1  DSP1  Command  Summary 


Note  1 . The  “n”  in  the  processing  speed  and  clock  cycle  columns  indicates  the  number 
of  times  a process  is  repeated. 

- Raster  data  calculation:  The  number  of  rasters  calculated. 

- Data  ROM  read:  Number  of  words  in  the  ROM  read. 

Note  2.  For  commands  with  multiple  codes,  refer  to  the  description  of  each  command. 


3-2-1 


PARAMETER  DATA  TYPE 


Chapter  3 Parameter  Data  Type 

The  conventions  used  in  the  table  below  are  employed  throughout  this  manual  when  re- 
ferring to  parameters. 


PARA- 

METER 

DESCRIPTION 

# 

BITS 

DATA  RANGE 

UNIT 

A 

Angle 

8 

-n~+n  (-180°-+ 180°) 

2tc/216 

T 

Fixed  Point  Decimal 

16 

-1.0~ +0.999969- •• 

2-15 

18 

Integer  with  decimal  part  (fixed  point) 

16 

-128.0 -+127.996093- 

2-8 

1 

Integer 

16 

-32768  - +32767 

1 

21 

Double  integer 

17 

-65536  - +65534 

2 

Cl 

Cyclic  integer 

16 

1 

U 

Integer  without  a sign 

16 

0 - 65535 

1 

D 

Double  precision  integer 

32 

-2147483648  - 
+2147483647 

1 

L 

Low  digit  of  double  precision  integer 

El 

— 

— 

H 

High  digit  of  double  precision  integer 

El 

— 

D2 

Double  precision  half  integer 

32 

-1073741824  - 
+1073741823 

2-i 

L2 

Low  digit  of  double  precision  half  integer 

16 

— 

— 

H2 

High  digit  of  double  precision  half  integer 

16 

— 

— 

M 

Floating  point  coefficient 

16 

-1.0  - +0.999969- •• 

1 

C 

Floating  point  exponent 

16 

-32768  - +32767 

1 

Table  3-3-1  Parameter  Data  Type 


Note  1 . The  data  transfer  between  the  Super  NES  CPU  and  DSP1  is  carried  out 
in  16  bits  regardless  of  the  number  of  bits  in  each  parameter  selection 
shown  in  the  above  table. 

Note  2.  Though  the  resolution  of  the  double  precision  semi-integer  (D2)  is  2'1,  it  is 
actually  handled  as  an  integer  because  the  lowest  bit  is  always  used  as 
0. 

Note  3.  The  exponent  of  a floating  point  number  (C)  can  be  stored  in  the  range  of 
8002H  to  7FFFH  (-32766  to  32767). 


3-3-1 


SNES  DEVELOPMENT  MANUAL 


Chapter  4 Use  of  DSP1 
4.1  DSP1  DR  REGISTER 

DSP1  processes  Super  NES  CPU  commands  and  parameters  using  an  internal 
DR  register  that  is  mapped  in  the  Super  NES  CPU  “A”  bus. 

Commands  and  parameters  are  sent  from  the  Super  NES  CPU  to  DSP1 . Specifi- 
cally, data  is  written  to  the  memory-mapped  DR  register  using  the  STORE  com- 
mand. The  Super  NES  CPU  and  DSP1  do  not  perform  handshaking  operations. 
The  Super  NES  CPU  waits  while  DSP1  processes  data,  before  sending  the  next 
data. 


Super  NES 

Memory  Map  DSP1 


Figure  3-4-1  Super  NES/DSP1  Memory  Mapping  (Mode  21) 

DSP1  decodes  commands,  processes  them  according  to  the  assigned  parame- 
ters, and  writes  the  results  to  the  DR  register.  The  Super  NES  CPU  waits,  while 
DSP1  processes  the  data,  then  reads  the  DR  register  using  the  LOAD  command 
to  obtain  the  results. 

The  DR  register  has  2 input/output  modes,  8 bit  and  16  bit.  The  DSP1  receives 
each  command  in  the  8 bit  mode.  Once  the  command  is  received,  the  DR  register 
is  changed  to  the  16  bit  mode.  All  input/output  data  is  transferred  in  the  16  bit 
mode.  The  DR  register  mode  is  controlled  by  the  DSP1  Status  register. 


3-4-1 


[ 


USE0FDSP1 


3 


4.2  DSP1  STATUS  REGISTER 

The  status  register  is  a 16-bit  register  which  holds  the  status  bits  needed  by  the 
DSP1  to  transfer  data  to  and  from  external  devices.  The  upper  8 bits  can  be  read 
from  an  external  device  through  pins  DO  through  D7  of  DSP1 . Only  bit  15  is  used 
by  the  Super  NES.  This  bit  is  referred  to  as  “RQM” 


D15  D14  D13  D12  Dll  DIO  D9  D8 


Figure  3-4-2  DSP1  Status  Register  Configuration 

4.3  RQM 

This  bit  indicates  that  the  DSP1  is  requesting  data  read  from  the  Super  NES  CPU. 
The  bit  is  “0”  when  the  DSP1  is  busy  and  “1”  when  it  is  ready  to  read  or  write. 

4.4  DMA  TRANSFER 

Although  DSP1  is  capable  of  DMA  data  transfer,  it  is  not  supported  by  the  Super 
NES  system  due  to  current  hardware  configuration. 


3-4-2 


SNES  DEVELOPMENT  MANUAL 


4.5  OPERATION  SUMMARY 


The  following  figure  shows  the  relationship  and  basic  operations  of  the  Super 
NES  CPU  and  DSP1 . 


Figure  3-4-3  DSP1  Operations  Flow  Diagram 


3-4-3 


Super  NES  CPU/DSP1  Operational  Timing 


USEOFDSP1 

~~1 


Figure  3-4-4  Super  NES  CPU/DSP1  Operational  Timing 


3-4-4 


DSP1  Clock 
(7.6  MHz) 


Chapter  5 Description  ofDSPl  Commands 


5.1  GENERAL  CALCULATION 

5.1.1  16-BIT  MULTIPLICATION  (DECIMAL,  INTEGER) 


Name: 

Multiply 

Code: 

00H*3 

Parameters: 

Input 

k[T/l] 

l[T/l] 

Multiplicand 

Multiplier 

Output 

M[T/H2] 

Product  (rounded  fraction  < 15 
bits) 

Function:  This  command  determines  the  product,  M,  of  decimal  K 

and  I.  The  command  can  also  determine  the  product  of 
integers  [I],  wherein  the  result  of  the  calculation  is  a dou- 
ble precision  half  integer  (H2). 

Equation  5-1 : 

kxl  = M 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 

2.  k input  12 

3. 1 input  4 

Output  1 . M output  4 

‘Notes:  1 . Parameters  are  input/output  via  the  DR  register. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

3.  00H  is  a hexadecimal  code. 

Example:  This  is  a general  command  used  in  all  types  of  calculations. 


3-5-1 


DESCRIPTION  OF  DSP1  COMMANDS 

I 1 


INVERSE  CALCULATION  (FLOATING 

POINT) 

Name: 

Inverse 

Code: 

10H 

Parameters: 

Input: 

a[M] 

Coefficient 

b[C] 

Exponent  (8002-7FFFH) 

Output: 

A[M] 

Coefficient 

B[C] 

Exponent  (8002-7FFFH) 

Function:  This  command  determines  the  inverse  of  a floating  point 

decimal  number. 

Equation  5-2: 


1 

ax2b 


Number  of  Process  Cycles: 


A x 2b 

Input 

1.  Command  Input 

6 

2.  a input 

13 

3.  b input 

73 

Output 

1 . A output 

2 

2.  B output 

4 

‘Notes:  1 . Parameters  are  input/output  via  the  DR  register. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 


Example:  This  is  a general  command  used  in  all  types  of  calculations. 


3-5-2 


5.1.3  TRIGONOMETRIC  CALCULATION 

Name:  Triangle 

Code:  04H 

Parameters:  Input:  0[A]  Angle 

r[T/l]  Radius 

Output:  S[T/I]  sin 

C[T/I]  cos 

Function:  This  command  determines  the  product  of  the  sin  of  an- 

gle 0 and  radius  r,  and  the  product  of  the  cosine  and  ra- 
dius r.  When  the  radius  is  an  integer  [I],  the  results  are 
also  an  integer. 

Equation  5-3: 

C = r(cos0)  S = r(sin0) 


Y 


Figure  3-5-1  Trigonometric  Calculation 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  0 input  12 

3.  r input  34 

Output  1 . S output  3 

2.  C output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [sin0,  cos0  calculation] 

Set  r=1  to  calculate  sin0  and  cos0. 

[Vector  component  calculation] 

Determines  the  X and  Y components  for  a two-dimensional 
vector  whose  size  and  direction  are  known. 

This  is  a general  command  which  can  be  used  in  other  types 
of  calculations. 


3-5-3 


DESCRIPTION  OF  DSP1  COMMANDS 


5.2  VECTOR  CALCULATION 


5.2.1  VECTOR  SIZE 

Name: 

Radius 

Code: 

08H 

Parameters: 

Input: 

x[l] 

X component  of  the  vector 

y[i] 

Y component  of  the  vector 

z[l] 

Z component  of  the  vector 

Output: 

Ll[L2] 

Vector  size  squared  (lower) 

Lh[H2] 

Vector  size  squared  (upper) 

Function: 

This  command  determines  vector  size  (square  of  the 

absolute  value). 

Equation  5-4: 

(x2  + y2  + z2)  = L 


Figure  3-5-2  Vector  Calculation 

The  absolute  value  of  the  vector  R = JL  is  determined 
by  the  Distance  command. 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  x input  14 

3.  y input  4 

4.  z input  4 

Output  1 . L|_  output  2 

2.  Lh  output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 


3-5-4 


SNES  DEVELOPMENT  MANUAL 


] 


Example:  [Distance  between  two  points] 

This  command  is  useful  for  calculating  the  distance  between 
two  points.  The  command  calculates  the  square  of  distance 
between  two  points,  and  may  be  used  for  calculating  compar- 
ative data.  One  point  of  the  vector  is  assumed  to  be  X=0,  Y=0 
and  Z=0. 


3-5-5 


DESCRIPTION  OF  DSP1  COMMANDS 


5.2.2  VECTOR  SIZE  COMPARISON 

Name:  Range 

Code:  18H 

Parameters:  Input:  x[T/l]  X component  of  the  vector 

y[T/lj  Y component  of  the  vector 
z[T/l]  Z component  of  the  vector 
r[T/l]  Range  to  be  compared  against 
the  vector  size  (sphere  radius) 

Output:  D[T/H2]  Difference  between  the  vector 

size  and  the  specified  range. 

Function:  This  command  subtracts  the  square  of  the  specified 

range  from  the  square  of  the  vector  size.  This  command 

compares  the  vector  size  and  the  distance  from  a partic- 
ular point,  and  so  may  be  used  to  determine  if  a point  is 
within  the  sphere.  The  parameters  can  be  either  decimal 
or  integer. 

Equation  5-5: 

x2  + y2  + z2  — r2  = D 

Z 


X 

Figure  3-5-3  Vector  Size  Comparison 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  x input  12 

3.  y input  4 

4.  z input  4 

5.  r input  8 

Output  1 . D output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Detects  a collision  in  three-dimension] 

This  command  determines  if  an  object  is  within  a certain 
range  of  a point.  It  can  be  used  to  detect  three-dimensional 
collisions. 


3-5-6 


SNES  DEVELOPMENT  MANUAL 


5.2.3  VECTOR  ABSOLUTE  VALUE  CALCULATION 


Name: 

Code: 

Parameters: 


Function: 


Distance 

28H 


Input: 

x[l/T] 

X component  of  the  vector 

m] 

Y component  of  the  vector 

z[\fT] 

Z component  of  the  vector 

Output: 

R[l/T] 

Vector  size 

This  command  determines  vector  size  (absolute  value). 
The  parameters  can  be  either  decimal  or  integer. 


Equation  5-6:  Jx2  + y2  + z2  = R 


Z 


Figure  3-5-4  Vector  Absolute  Value  Calculation 


Number  of  Process  Cycles:  Input 


Output 


1 . Command  Input 

6 

2.  x input 

15 

3.  y input 

4 

4.  z input 

127 

1 . R output 

4 

‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 


Example:  [Distance  between  two  points] 

This  commands  calculates  the  distance  between  two  3-D 
points  on  the  coordinate.  In  contrast  to  the  Radius  command. 


3-5-7 


DESCRIPTION  OF  DSP1  COMMANDS 


5.3  COORDINATE  CALCULATION 

5.3.1  TWO-DIMENSIONAL  COORDINATE  ROTATION 


Name: 

Rotate 

Code: 

OCH 

Parameters: 

Input: 

0[A] 

Angle  of  rotation  about  the  Z 
axis  (counterclockwise) 

Xi[l] 

X coordinate  before  rotation 

Yill] 

Y coordinate  before  rotation 

Output: 

x2[l] 

X coordinate  after  rotation 

y2[i] 

Y coordinate  after  rotation 

Function:  This  command  determines  the  (X,Y)  coordinates  after 

rotating  (x,y)  counterclockwise  for  0. 

Equation  5-7: 


Figure  3-5-5  Two-Dimensional  Coordinate  Rotation 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.0  input  12 

3.  x-i  input  3 

4.  y!  input  37 

Output  1 . x2  output  2 

2.  y2  output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Coordinate  calculation  for  rotating  an  object  on  a surface] 

This  command  calculates  the  coordinates  of  an  object  after  it 
is  rotated  on  a surface. 


3-5-8 


5.3.2  THREE-DIMENSIONAL  COORDINATE  ROTATION 


Name: 

Polar 

Code: 

1CH 

Parameters 

Input: 

©[A] 

Angle  of  rotation  about  the  Z 
axis  (positive  from  the  Y axis  to 
the  X axis) 

9 [A] 

Angle  of  rotation  about  the  X 
axis  (positive  from  the  Z axis  to 
the  Y axis) 

<P[A] 

Angle  of  rotation  about  the  Y 
axis  (positive  from  the  X axis  to 
the  Z axis) 

x[l] 

X coordinate  before  rotation 

y[i] 

Y coordinate  before  rotation 

z[l] 

Z coordinate  before  rotation 

Output: 

X[l] 

X coordinate  after  rotation 

Y[l] 

Y coordinate  after  rotation 

Z[l] 

Z coordinate  after  rotation 

Function:  This  command  determines  the  (X,Y,Z)  coordinates 

when  rotating  (x,y,z)  three-dimensionally.  Rotation  is 
performed  in  the  order  of  9 about  theY  axis,  9 about  the 
X axis,  and  0 about  the  Z axis. 

Equation  5-8: 

costp  0 sin<p  1 0 0 cos0  -sin0  0 

(x>y>z)  0 10  0 cos<()  -sin9  sin0  cos0  0 = (X,  Y,  Z) 

-sin  9 0 COS9J  [O  sin 9 cos9  0 0 


Rotation  on  Y axis 


Rotation  on  X axis 


3-5-9 


Note:  To  be  compatible  with  the  projection  and  attitude- 
control  commands,  the  X axis  shall  be  east-west 
(east  = +),  the  Y axis  shall  be  north-south  (north  = 
+),  and  the  Z axis  shall  be  up  and  down  (up  = +). 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.0  input  13 

3.  <|>  input  3 

4.  tp  input  2 

5.  x input  2 

6.  y input  2 

7.  z input  107 

Output  1 . X output  6 

2.  Y output  2 

3.  Z output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Coordinate  calculation  for  three-dimensional  rotation  of  an 

object] 

This  command  calculates  the  coordinates  of  an  object  after 
three-dimensional  rotation.  (Refer  to  the  diagram  on  the  fol- 
lowing page.) 


3-5-10 


5.4  PROJECTION  CALCULATION 


5.4.1  PROJECTION  PARAMETER  SETTING 

Name:  Parameter 

Code:  02H 

Parameters:  Input:  FX[CI]  X coordinate  of  base  point  (glo- 

bal coordinates) 

Fy[CI]  Y coordinate  of  base  point  (glo- 
bal coordinates) 

FZ[CI]  Z coordinate  of  base  point  (glo- 
bal coordinates) 

Lfe[U]  Distance  between  base  point 

and  viewpoint  (Sets  screen- 
sprite  ratio.) 

Les[U]  Distance  between  viewpoint  and 

screen  (The  effect  of  screen  an- 
gle considered;  the  screen  hori- 
zontal distance  is  256) 

Aas[A]  Azimuth  angle  of  view  line  with 
respect  to  global  coordinates. 
(East  is  0°  and  positive  toward 
the  north) 

AZS[A]  Zenith  angle  of  view  line  with  re- 
spect to  global  coordinates.  (Ze- 
nith is  0°,  0°~  180°). 

Output:  Vof[l]  Raster  number  of  imaginary 

center 

Vva[l]  Raster  number  representing 

horizontal  line. 

CX[CI]  X coordinate  of  the  point  pro- 
jected on  the  center  of  the 
screen  (ground  coordinates) 

Cy[CI]  Y coordinate  of  the  point  pro- 

jected on  the  center  of  the 
screen  (ground  coordinates) 

Function:  This  command  sets  various  projection  parameters  and 

calculates  the  basic  data  used  in  subsequent  process- 
es. The  command  places  the  viewer  behind  a fixed  point 
such  as  an  airplane.  If  the  distance  between  the  fixed 
point  and  the  view  point  is  set  to  0,  then  the  viewer  sees 
the  display  from  the  perspective  of  the  airplane. 


3-5-12 


X (East) 


Assignment  of  Projection  Parameter 

Figure  3-5-7  Assignment  of  Projection  Parameter 

Vva  (number  of  the  raster  used  to  display  a horizontal 
line)  indicates  the  border  between  background  environ- 
ments such  as  sky  or  cloud  and  a horizontal  plane  such 
as  earth  or  sea.  For  raster  numbers  larger  than  Vva  (rep- 
resenting the  area  below  the  horizon  line),  a horizontal 
plane  is  displayed  on  the  screen,  but  the  matrix  ele- 
ments for  each  raster  are  calculated  individually  using 
the  RASTER  command. 


Relation  between  sight  and  projected  plane  (side  view) 
Figure  3-5-8  Relationship  of  Sight  and  Projected  Plane 


3-5-13 


DESCRIPTION  OF  DSP1  COMMANDS 


Cx  and  Cy  (global  coordinates  for  the  point  projected  on 
the  center  of  the  screen)  are  the  center  coordinates 
used  for  rotation,  and  must  be  specified  to  the  PPU. 


Number  of  Process  Cycles:  Input 


Output 


1 . Command  Input 

6 

2.  Fx  input 

11 

3.  Fy  input 

2 

4.  Fz  input 

2 

5.  Lfe  input 

3 

6.  Les  input 

3 

7.  Aas  input 

4 

8.  Azs  input 

839 

ivof 

2 

2.  Vva 

10 

3.  Cx 

5 

4.  Cy 

5 

Example:  [Parameter  setting  necessary  for  projection] 

Pilot  Wings  displays  the  view  seen  from  the  view  point  direct- 
ly behind  an  airplane  which  is  at  the  fixed  point.  When  the 
distance  between  the  screen  and  view  point  is  set  to  256 
(when  the  horizontal  width  of  the  screen  is  256),  the  horizon- 
tal screen  angle  is  50°. 


3-5-14 


5.4.2  RASTER  DATA  CALCULATION 


Name:  Raster 

Code:  OAH  (To  output  result  of  calculation  via  DMA.) 

1 AH  (When  result  of  calculation  is  not  output  via  DMA.) 

Parameters:  Input:  Vs[l]  Raster  number  where  projection 

display  begins. 

Output:  An[l8]  Linear  transformation  matrix  el- 

ement A for  each  raster 
Bn[l8]  Linear  transformation  matrix  el- 

ement B for  each  raster 
Cn[l8]  Linear  transformation  matrix  el- 

ement C for  each  raster 
Dn[l8]  Linear  transformation  matrix  el- 

ement D for  each  raster 

Function:  This  command  calculates  the  linear  transformation  ma- 

trix elements  (A,  B,  C,  D)  for  each  raster  based  on  the 
various  projection  parameters  specified  with  the  Param- 
eter command  in  internal  RAM.  Effects  of  Perspective 
can  be  achieved  by  specifying  the  matrix  elements  for 
each  raster  to  the  PPU  to  display  distant  objects  (small) 
and  near  objects  (large).  Results  of  these  calculations 
can  be  output  in  one  of  two  modes.  Normally,  the  results 
are  read  from  the  Super  NES  CPU  using  software.  The 
results  are  output  successively  in  the  order  of  A=>B=>- 
C=>D=>A=>B  • • • until  the  command  is  completed.  The 
command  is  ended  by  writing  8000H  to  the  DR  instead 
of  reading  element  D. 


3-5-15 


DESCRIPTION  OF  DSP1  COMMANDS 


Figure  3-5-9  Calculation  of  Raster  Data 


Figure  3-5-10  BG  Screen  and  Displayed  Area 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 

2.  Vs  input  21 1 

Output  1 . An  3 

2.  Bn  3 

3. Cn  3 

4.  Dn  200*1 

5.  Dn  7*2 

‘Notes:  1 . Until  An+-,  is  output. 

2.  Until  the  command  is  interrupted  and  the  next  command  can 
be  selected. 


3-5-16 


SNES  DEVELOPMENT  MANUAL 


Example:  [Calculation  of  linear  transformation  matrix  elements  for  pro- 

jection] 

This  command  is  used  frequently  for  projection  of  the  ground 
objects  (airplane  runway,  sky  diving  target  point,  etc.)  in  Pilot 
Wings. 


3-5-17 


DESCRIPTION  OF  DSP1  COMMANDS 


OBJECT  PROJECTION  CALCULATION 

Name: 

Project 

Code: 

06H 

Parameters: 

Input: 

x[l] 

X coordinate  of  the  object  (glo- 
bal coordinates) 

y[i] 

Y coordinate  of  the  object  (glo- 
bal coordinates) 

z[l] 

Z coordinate  of  the  object  (glo- 
bal coordinates) 

Output: 

H[l] 

H coordinate  of  the  object  pro- 
jected on  the  screen  (screen  co- 
ordinates, right  is  positive). 

V[l] 

V coordinate  of  the  object  pro- 
jected on  the  screen  (screen  co- 
ordinates, down  is  positive). 

M[l] 

Enlargement  ratio  for  projected 
object. 

Function:  This  command  calculates  the  location  and  size  of  the 

projection  of  an  object  on  the  screen  based  on  various 
projection  parameters  specified  with  the  Parameter 
command  in  internal  RAM.  The  center  of  the  screen  is 
the  origin  of  the  screen  coordinates  (0,0). 

Z (Sky) 


-Y  (South) 


Figure  3-5-1 1 Calculation  of  Projected  Position  of  Object 


3-5-18 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2. x  input  12 

3.  y input  4 

4.  z input  596 

Output  1 . H output  3 

2.  V output  2 

3.  M output  4*1 


‘Notes:  1 . Until  the  next  command  can  be  selected. 

Example:  [Calculation  of  the  projected  location  (on  the  screen)  of  a 

floating  object] 

This  command  is  used  in  Pilot  Wings  to  project  a ring  consist- 
ing of  floating  balls.  The  location  and  size  of  the  balls  project- 
ed on  the  screen  are  calculated  based  on  the  balls’  global 
coordinates.  By  changing  the  location  and  size  of  the  balls’ 
sprite,  three-dimensional  display  of  the  ring  projected  on  the 
screen  can  be  achieved. 


Viewpoint 


Figure  3-5-12  Projection  Image  of  Object 


3-5-19 


DESCRIPTION  OF  DSP1  COMMANDS 


3 


5.4.4  COORDINATE  CALCULATION  OF  A SELECTED  POINT  ON  THE 
SCREEN 


Name: 

Target 

Code: 

OEH 

Parameters: 

Input: 

h[l] 

H coordinate  of  selected  point 
on  the  screen  (screen  coordi- 
nates, right  is  positive) 

v[l] 

V coordinate  of  selected  point 

on  the  screen  (screen  coordi- 
nates, down  is  positive) 


Note:  The  origin  coordinates  of  the  screen  designate  the 
center  of  the  screen. 


Output:  X[l] 

X coordinate  of  selected  point 
(global  coordinates,  east  is  posi- 
tive). 

Y[l] 

Y coordinate  of  selected  point 
(global  coordinates,  south  is 
positive). 

Function:  This  command  calculates  the  coordinates  of  a selected 

“ground”  point  on  the  screen.  The  command  calculates 
the  global  coordinates  (X,Y)  (the  Z coordinate  is  zero)  of 
the  point  projected  on  a point  selected  by  a cursor  or  tar- 
get mark  based  on  the  screen  coordinates  (H,V)  of  the 
selected  point. 


ViewDoint 


Figure  3-5-13  Calculation  of  Coordinates  for  the  Indicated  Point  on  the  Screen 


3-5-20 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  h input  1 1 

3.  v input  203 

Output  1 . X output  4 

2.  Y output  4*1 


‘Notes:  1 . Until  the  next  command  can  be  selected. 

Example:  [Calculation  of  the  target  on  the  ground  when  attacking  from 

the  sky] 

This  command  is  used  in  Pilot  Wings  when  the  helicopter  at- 
tacks a target  on  the  ground  using  a missile  scope.  When  the 
missile  launch  button  is  pressed,  the  location  of  the  point  on 
the  ground  which  is  targeted  in  the  scope  is  calculated  and  a 
missile  is  launched  on  that  vector.  The  trajectory  of  the  mis- 
sile is  a straight  line  toward  that  point  and  is  not  affected  by 
the  velocity  of  the  helicopter  at  the  time  of  the  launch. 


Viewpoint 


Figure  3-5-14  Attack  Point  and  Position  Indicated  on  Screen  (Side  View) 


3-5-21 


5.5  ATTITUDE  CONTROL 

5.5.1  SET  ATTITUDE 

Name:  Attitude 

Code:  01 H (To  select  attitude  matrix  A) 

1 1 H (To  select  attitude  matrix  B) 

21 H (To  select  attitude  matrix  C) 

Parameters:  Input:  m[T]  Constant 

0[A]  Rotational  angle  about  the  Z 

axis  (from  Y axis  to  X axis  is  +) 

4>  [A]  Rotational  angle  about  the  X 
axis  (from  Z axis  to  Y axis  is  +) 
<p[A]  Rotational  angle  about  the  Y 

axis  (from  X axis  to  Z axis  is  +) 

Function:  This  command  calculates  a matrix  which  represents  a 

three-dimensional  rotation  (attitude  change).  The  order 
of  rotation  is  4>  about  the  Y axis  (north-south),  cp  about 
the  X axis  (east-west),  and  6 about  the  Z axis  (up- 
down).  By  applying  the  attitude  matrix  to  the  object  coor- 
dinates (FLU  coordinates),  the  global  coordinates  (XYZ 
coordinates)  can  be  obtained  (the  SUBJECTIVE  com- 
mand). By  applying  the  inverse  of  the  attitude  matrix 
(transpose  matrix)  to  the  global  coordinates,  the  object 
coordinates  can  be  calculated  (the  OBJECTIVE  com- 
mand). 

Calculates  attitude  matrix  A when  the  code  is  01 H 
(M=A) 

Calculates  attitude  matrix  B when  the  code  is  1 1 H 
(M=B) 

Calculates  attitude  matrix  C when  the  code  is  21 H 
(M=C) 

Equation  5-9: 

coscp  0 -sin(p  1 0 0 cos6  sin0  0 

m 0 1 0 0 cos<(>  sin<f>  -sin0  cos0  0 = M 

sinq>  0 coscpj  [0  -sin<j>  cos<pJ  0 0 1 


3-5-22 


SNES  DEVELOPMENT  MANUAL 


X (East) 


Z (Sky) 

Direction  of 
Rotation 

■€- 


U(Up) 


►Y  (North) 


F (Forward) 


L (Left) 


Global  Coordinates  Object  Coordinates  Before  Rotation 
(X,  Y,  Z Axes)  (F,  L,  U Axes) 

Figure  3-5-15  Attitude  Computation 


Rotation  on  Y Axis  Object  Coordinates  After  Rotation 

(F,  L,  U Axes) 


Figure  3-5-16  Object  Coordinate  Rotated  on  Y Axis 


Rotation  on  X Axis 


F 


Object  Coordinates  After  Rotation 
(F,  L,  U Axes) 


Figure  3-5-17  Object  Coordinate  Rotated  on  X Axis 


Rotation  on  Z Axis  Object  Coordinates  After  Rotation 

(F,  L,  U Axes) 

Figure  3-5-18  Object  Coordinate  Rotated  on  Z Axis 


3-5-23 


DESCRIPTION  OF  DSP1  COMMANDS 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  m input  13 

3.  0 input  4 

4.  <(>  input  4 

5.  cp  input  137'1 


‘Notes:  1 . Until  the  next  command  can  be  selected. 


Example:  [Calculation  of  attitude  matrix  for  global-object  coordinate 

conversion] 

This  command  is  used  to  calculate  necessary  attitude  matri- 
ces using  3 commands  for  attitude  control.  When  the  attitude 
changes,  this  command  must  be  used  to  renew  attitude  con- 
trol matrices. 


3-5-24 


5.5.2  CONVERT  FROM  GLOBAL  TO  OBJECT  COORDINATES 

Name:  Objective 

Code:  ODH  (To  select  attitude  matrix  A) 

1 DH  (To  select  attitude  matrix  B) 

2DH  (To  select  attitude  matrix  C) 

Parameters:  Input:  x[l]  X coordinate  of  object  (global 

coordinates,  east) 

y[l]  Y coordinate  of  object  (global 

coordinates,  north) 

z[l]  Z coordinate  of  object  (global 

coordinates,  up) 

Output:  F[2I]  F coordinate  of  object  (object 

coordinates,  forward) 

L[2I]  L coordinate  of  object  (object 
coordinates,  left) 

U[2I]  U coordinate  of  object  (object 
coordinates,  up) 

Function:  Attitude  matrices  (A,B,C)  represent  the  three-dimen- 

sional relationship  between  rotation  angles  of  the  object 
coordinates  (the  FLU  axes)  and  global  axes  (the  XYZ 
axes).  The  global  coordinates  are  obtained  by  multiply- 
ing the  object  coordinates  with  attitude  matrices  (i.e.,  by 
rotating  three-dimensionally).  Inversely,  the  object  coor- 
dinates are  obtained  by  multiplying  the  global  coordi- 
nates with  inverse  of  the  attitude  matrices  (i.e.,  by 
rotating  in  the  opposite  direction  and  order). 

Calculates  the  product  with  inverse  of  the  matrix  A when 
the  code  is  ODH  (M'^A'1). 

Calculates  the  product  with  inverse  of  the  matrix  B when 
the  code  isIDH  (M'W). 

Calculates  the  product  with  inverse  of  the  matrix  C when 
the  code  is  2DH  (M'W). 

Equation  5-10: 

|(x,y,z)M-'  = (F.L.U) 


3-5-25 


DESCRIPTION  OF  DSP1  COMMANDS 


U(Up) 


F (Front)  \Jy 

rX  (East) 

Figure  3-5-19  Conversion  of  Global  to  Objective  Coordinates 

Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  x input  14 

3.  y input  4 

4.  z input  7 

Output  1 . F output  5 

2.  L output  5 

3.  U output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Conversion  from  the  global  coordinates  to  object  coordi- 

nates] 

In  Pilot  Wings,  the  conversion  of  objective  coordinates  to  glo- 
bal coordinates  for  the  aircraft  is  calculated  using  wind  ef- 
fects. Using  these  calculations,  the  course  and  speed  of  the 
aircraft  may  be  altered  by  wind  direction  and  speed. 


3-5-26 


SNES  DEVELOPMENT  MANUAL 


5.5.3  CONVERSION  FROM  OBJECT  TO  GLOBAL  COORDINATES 

Name:  Subjective 

Code:  03H  (To  select  attitude  matrix  A) 

13H  (To  select  attitude  matrix  B) 

23H  (To  select  attitude  matrix  C) 

Parameters:  Input:  F[21]  F coordinate  of  object  (object 

coordinates,  forward) 

L[21  ] L coordinate  of  object  (object 
coordinates,  left) 

U[21]  U coordinate  of  object  (object 
coordinates,  up) 

Output:  X[l]  X coordinate  of  object  (global 

coordinates,  east) 

Y[l]  Y coordinate  of  object  (global 

coordinates,  north) 

Z[l]  Z coordinate  of  object  (global 

coordinates,  up) 

Function:  Attitude  matrices  (A,B,C)  represent  the  three-dimen- 

sional relationship  between  rotation  angles  of  the  object 
coordinates  (FLU  axes)  and  global  axes  (XYZ  axes). 
The  global  coordinates  are  obtained  by  multiplying  the 
object  coordinates  with  attitude  matrices  (i.e.,  by  rotating 
three-dimensionally). 

Calculates  product  with  attitude  matrix  A when  the  code 
is  03H  (M=A) 

Calculates  product  with  attitude  matrix  B when  the  code 
is  13H  (M=B) 

Calculates  product  with  attitude  matrix  C when  the  code 
is  23H  (M=C) 

Equation  5-1 1 : 

| (F,  L,  U)  M = (X,  Y,  Z) 


3-5-27 


DESCRIPTION  OF  DSP1  COMMANDS 


1 


Z (Sky) 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  F input  13 

3.  L input  4 

4.  U input  7 

Output  1 . X output  5 

2.  Y output  5 

3.  Z output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 


Example:  [Calculation  of  the  global  coordinates  after  change  in  the  ob- 

ject’s attitude] 

In  Pilot  Wings,  the  object  coordinates  of  the  ring  of  balls  re- 
main the  same  unless  the  size  of  the  balls  or  the  shape  or 
size  of  the  ring  is  changed  because  there  is  one  object  coor- 
dinate system  dedicated  for  the  ring.  When  the  direction  (atti- 
tude) of  the  ring  is  changed,  the  ATTITUDE  command  is 
used  to  renew  the  attitude  matrices.  The  ring  with  the  new  at- 
titude can  be  displayed  by  calculating  the  global  coordinates 
using  the  new  attitude  matrices  and  calculating  the  location  of 
balls’  projection  using  the  PROJECT  command.  The  same 
process  takes  place  when  the  object  coordinates  change 
without  a change  in  attitude  or  when  both  attitude  and  object 
coordinates  change. 


3-5-28 


SNES  DEVELOPMENT  MANUAL 


ZZ1 


5.5.4  CALCULATION  OF  INNER  PRODUCT  WITH  FORWARD  ATTITIDE 
AND  A VECTOR 


Name:  Scalar 

Code:  OBH  (To  select  attitude  matrix  A) 

1BH  (To  select  attitude  matrix  B) 

2BH  (To  select  attitude  matrix  C) 


Parameters:  Input: 

x[l] 

X component  of  vector. 

y[i] 

Y component  of  vector. 

z[l] 

Z component  of  vector. 

Output: 

S[l] 

Inner  product 

Function:  This  command  selects  an  attitude  matrix  based  on  the 

code.  It  calculates  the  inner  product  of  a vector  and  the 
first  row  of  the  selected  matrix. 


When  the  code  is  OBH,  S = x • Afx  + y • Afy  + z • Afz 
When  the  code  is  1 BH,  S = x • Bfx  + y • Bfy  + z • Bfz 
When  the  code  is  2BH,  S = x • C{X  + y • Cfy  + z • CfZ 


Figure  3-5-21  Calculation  of  Inner  Product  with  Forward  Attitude 

Note:  As  shown  below,  the  first  row  of  the  attitude  matrix 
represents  global  coordinates  of  a unity  vector  (1 ,0,0)  in 
the  forward  direction  in  the  object  coordinate  system. 

Equation  5-12: 


S 


(X,  Y,  Z)  (1,0,0) 


M,x  ^fy  Mfz 
M,x  M|y  M|z 

Mux  ^uy  ^uz 


= (MfxMfyMfz) 


M is  equal  to  A,  B,  or  C;  depending  upon  selected  code. 


3-5-29 


DESCRIPTION  OF  DSP1  COMMANDS 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  x input  15 

3.  y input  4 

4.  z input  7 

Output  1 . S output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Detection  of  three-dimensional  collision] 

This  command  is  used  in  Pilot  Wings  to  see  if  the  airplane 
flew  through  the  ring  of  balls.  The  sign  of  the  inner  product  of 
the  forward  vector  of  an  object  and  the  vector  connecting  the 
object  and  the  airplane  changes  when  the  airplane  crosses 
the  plane  containing  the  ring  (the  inner  product  is  zero  when 
the  airplane  is  on  the  plane).  When  the  sign  change  occurs, 
the  distance  from  the  center  of  the  ring  to  the  airplane  and 
the  radius  of  the  ring  can  be  compared  with  the  RANGE  com- 
mand to  see  if  the  airplane  was  able  to  fly  through  the  ring. 


Vector  passes  through 
the  plane  and  ring. 


> 0 


Figure  3-5-22  Position  of  Aircraft  and  Vector  Code 


3-5-30 


5.6  NEW  ANGLE  CALCULATION 


5.6.1  THREE-DIMENSIONAL  ANGLE  ROTATION 

Name:  Gyrate 

Code:  14H 

Parameters:  Input:  0j[A]  Angle  of  rotation  about  the  Z 

axis  (+  from  the  Y axis  to  the  X 
axis) 

4*  j[A]  Angle  of  rotation  about  the  X 
axis  (+  from  the  Z axis  to  the  Y 
axis) 

(pj[A]  Angle  of  rotation  about  the  Y 
axis  (+  from  the  X axis  to  the  Z 
axis) 

d9[A]  U axis  displacement  angle.  (+ 
from  the  L axis  to  the  F axis) 

d4>[A]  F axis  displacement  angle.  (+ 
from  the  U axis  to  the  L axis) 

d(p[A]  L axis  displacement  angle.  (+ 
from  the  F axis  to  the  U axis) 

Output:  0O[A]  Rotational  angle  about  the  Z 

axis. 

4>  0[A]  Rotational  angle  about  the  X 
axis. 

<p0[A]  Rotational  angle  about  the  Y 
axis. 

Note:  F,  L,  U axes  represent  the  X,  Y,  Z axes  when  ro- 
tated <f>  j,  cpj,  0j  only. 

Function:  This  command  determines  the  attitude  angles  (0O,  <t>0, 

cp0)  of  the  body  coordinates  after  the  body  with  the  atti- 
tude angle  (0j,  <t>j,  (pj)  with  respect  to  the  global  coordi- 
nates are  rotated  by  the  minor  displacement  (d9,  d§ , 
di p).  The  body  axes  are  rotated  about  the  XYZ  axes  by 
(0j,  <J>  j,  (pj)  to  obtain  the  FLU  axes.  The  FLU  axes  are 
then  rotated  by  (d0,  d<\> , c/cp).  This  command  calculates 
the  angles  of  the  new  FLU  axes  with  respect  to  the  XYZ 
axes.  The  order  of  rotation  is  Y axis,  X axis,  and  Z axis 
(L,  F,  and  U axis). 

Equation  5-13: 

0|  + sec^i  (dOcostpj-d^sincpj)  = 0O 

<J>j+  (d0sin(pj  + d^coscpj)  = <p0 

cpj  - tan^i  (d0cos<pj  + d(psin(p|)  +d(p  = cp0 


3-5-31 


DESCRIPTION  OF  DSP1  COMMANDS 


Rotate  6),  4>it  cpi 
to  X,  Y,  Z Axis 


/ 


Rotate  90,  <j)0,  <p0 
to  X,  Y,  Z Axis 


Objective  Coordinates 
(F,  L,  U Axes) 

1 Rotate  dQ,  dty , 
dp  to  F,  L,U  Axis 


Objective  Coordinate  Result  of 
Attitude  Change 
(F,  L’,  U’  Axes) 

Figure  3-5-23  Calculation  of  Rotation  Angle  After  Attitude  Change 


3-5-32 


SNES  DEVELOPMENT  MANUAL 


Number  of  Process  Cycles:  Input  1 . Command  Input  6 


2.  0j  input  14 

3.  4>j  input  2 

4.  cpj  input  2 

5.  d0  input  2 

6.  d<t>  input  2 

7.  dcp  input  406 

Output  1 . 0O  output  2 

2.  <|>0  output  4 

3.  <p0  output  4 


‘Notes:  1 . Parameters  are  input/output  via  the  DR  registers. 

2.  Parameters  are  input/output  in  the  order  shown  above.  The 
number  of  cycles  is  the  period  until  the  next  parameter  can 
be  selected  or  the  results  of  the  calculation  can  be  read. 

Example:  [Calculation  for  object  attitude  (directions)  change] 

This  command  is  used  to  calculate  the  attitude  angles  of  an 
object  that  is  steadily  moving.  The  command  determines  the 
attitude  angles  with  respect  to  the  global  coordinates  by 
specifying  the  angles  of  change  to  the  current  attitude  angles. 
The  command  may  be  used  continuously  to  determine 
changing  attitude  angles. 


3-5-33 


MATH  FUNCTIONS  AND  EQUASIONS 


Chapter  6 Math  Functions  and  Equations 

The  following  is  a summary  of  the  mathematical  functions  and  equations  used  in  this 
manual. 

6.1  MULTIPLY 


k x I = M 


6.2  INVERSE 


l 

ax2b 


A x 2b 


6.3  TRIANGLE 


r(cos0)  = C 
r(sin0)  = S 


6.4  RADIUS 


x2  + y2  + z2  = L 


6.5  RANGE 


x2  + y2  + z2-  r2  = D 


6.6  DISTANCE 

Vx2  + y2  + z2  = R 

6.7  GYRATE 

0j  + secfyfdOcoscpi-d^sintpi)  = 0O 

<}>i  + (dosing  + d<j>cos(pj)  = <J>0 

9j  - tan^i  (d0coscpj  + d^sincpj)  +dcp  = cp0 


6.8  ROTATE 


(x,  y) 


cos<j)  — sin<(> 
sin<t>  cos4>_ 


(X,  Y) 


3-6-1 


SNES  DEVELOPMENT  MANUAL 


6.9  POLAR 


cos  9 0 sin  9 

1 0 

0 

(X,  y,  z) 

0 1 0 

0 cos<)> 

-sin<t> 

-sin 9 0 cos 9 

_0  sin<|> 

COS<])_ 

cos0  -sine  0 
sine  cose  0 
0 0 1 


(X.Y.Z) 


6.10  ATTITUDE 


m 


cos  9 0 -sin  9 
0 1 0 
sin  9 0 COS9J 


1 0 0 
0 cos  <}>  sin<J> 
0 — sin<j>  cos<^J 


cose  sine  0 
-sine  cos 6 0 
0 0 1 


= M 


6.11  OBJECTIVE 


6.12  SUBJECTIVE 


6.13  SCALAR 


2 (x.  y»  z)  M-1  = (F,  L,  U) 


i (f,  I,  u)  M = (X,  Y,  Z) 


S = (X,  Y,  Z)  (1,0,0) 


Mfx  Mfy  Mfz 
M|x  Mly  Mlz 

MUX  MUy  MyZ 


- (MfxMfyMfz) 


3-6-2 


INTRODUCTION 


Chapter  1.  The  Super  NES  Super  Scope  System 

1 .1  INTRODUCTION  TO  THE  SUPER  NES  SUPER  SCOPE  SYSTEM 


The  Super  NES  Super  Scope  is  a light  sensitive  system  for  use  with  the  Super 
NES.  The  Super  NES  Super  Scope  was  developed  to  give  the  Super  NES  added 
value  and  eliminate  all  of  the  problems  of  heretofore  existing  devices.  Features  of 
the  Super  NES  Super  Scope  are  as  follows.  It  is  composed  of  two  units;  the  Super 
NES  Super  Scope  (light  sensitive  device)  and  a receiver/transmitter  (Super  NES 
Super  Scope-RX). 

1.1.1  TARGETING 

The  Super  NES  Super  Scope  detects  where  the  device  is  aimed,  unlike 
the  existing  Nintendo  Entertainment  System  device  (Zapper),  which  de- 
tects targets.  The  wireless  system  utilizes  an  infra-red  beam. 


Super  NES  Super  Scope-RX  Super  NES  Super  Scope 

(Receiver) 


Figure  4-1-1  Signal  Flow 


The  Super  NES  Super  Scope  utilizes  the  external  latch  function  of  the 
Super  NES  horizontal/vertical  counters.  The  Super  NES  Super  Scope  de- 
tects CRT  scanner  timing  with  a light  receiver,  and  transmits  the  timing 
pulse  to  the  Super  NES  external  latch  pin  to  detect  the  aim  location  on 
the  CRT.  (Same  principle  as  a light  pen.) 

When  the  Super  NES  Super  Scope  is  triggered,  the  Super  NES  Super 
Scope  sends  a beam  of  infra-red  light  to  the  Super  NES  and  transmits 
raster  timing  pulses  for  a few  frames. 

When  the  CPU  in  the  Super  NES  Super  Scope  RX  recognizes  the  trigger 
signal,  it  opens  the  gate  for  an  appropriate  duration  to  provide  the  Super 
NES  with  the  timing  pulses. 


4-1-1 


1 .1 .2  SUPER  NES  SUPER  SCOPE  SIGHT  ADJUSTMENT 

The  most  precise  alignment  of  the  Super  NES  Super  Scope’s  sight  oc- 
curs when  the  end  of  its  barrel  is  3 meters  (about  1 0 feet)  away  from  the 
television  screen.  Please  refer  to  the  illustration  below. 


Optical 


Visual 

Figure  4-1-2  Optical  Alignment 

The  line  of  sight  (visual  axis)  virtually  “sees”  what  the  lens  (optical  axis) 
“sees”  when  the  distance  between  the  television  screen  and  the  end  of 
the  Super  NES  Super  Scope  barrel  is  3 meters  (10  feet).  As  demonstrat- 
ed above,  an  offset  occurs  as  this  range  is  moved  away  from  3 meters,  in 
either  direction.  The  function  of  the  “ADJUST  AIM”  and  “TEST  AIM”  por- 
tion of  the  game  is  to  adjust  the  optical  axis  for  proper  sight  alignment 
through  software  at  the  beginning  of  the  game.  This  adjustment  takes  into 
account  all  electrical  delay  times.  When  the  adjustment  is  performed,  an 
insensitive  area  is  created  at  the  edge  of  the  screen.  The  greater  the  off- 
set adjustment,  the  larger  this  insensitive  area  becomes. 

The  following  illustration  demonstrates  an  example  of  the  difference  be- 
tween what  your  eye  might  see  through  the  Super  NES  Super  Scope  and 
what  the  lens  sees,  during  the  Adjust  Aim  mode. 

# What  your  eye  sees  (visual  axis) 

X What  the  lens  sees  (optical  axis) 

| 1 Television  screen 

j | Virtual  screen  (coordinate) 


Figure  4-1-3  Virtual  Screen  Alignment 


Axis 


4-1-2 


INTRODUCTION 


In  order  for  proper  alignment  to  occur,  the  virtual  screen  must  be  moved 
in  the  direction  of  the  arrow.  As  the  virtual  screen  is  moved  up  and  to  the 
left  an  insensitive  (shaded)  area  is  created  at  the  edges  of  the  screen. 
This  shaded  area  cannot  be  processed.  For  this  reason,  the  Super  NES 
Super  Scope  operation  manual  recommends  that  the  Super  NES  Super 
Scope  be  used  at  a range  of  3 meters  (about  1 0 feet)  from  the  television 
for  optimum  performance.  At  this  distance  the  insensitive  area  at  the 
edge  of  the  screen  is,  for  all  practical  purposes,  eliminated. 

1 .2  BASIC  SUPER  NES  SUPER  SCOPE  SPECIFICATIONS 

• Range:  3.28  ~ 16.4ft  (with  fully  charged  batteries) 

• Resolution:  About  1 character  (8  dots,  in  x and  y orientation) 

• Lens:  f = 150  mm,  30  <|> 

• Batteries:  Six  size  AA  batteries 

• Controls: 

• Power  switch 

• Single  shot/multiple  shot  selection  switch  (This  is  a three-position  switch, 
which  is  also  used  as  the  power  switch.) 

• Pause  switch  (See  Note  1 ) 

• Cursor  switch  (See  Note  2) 

• Trigger  switch 

Note  1 : This  function  varies  depending  on  the  software,  and  is  used  to 
pause  during  a game  or  change  screens. 

Note  2:  The  cursor  is  displayed  on  the  screen  while  this  switch  is  held 
down.  (The  location  signal  is  transmitted  continuously.) 


4-1-3 


SNES  DEVELOPMENT  MANUAL 


1 .3  SUPER  NES  PROGRAM  ADDRESS 


1 .3.1  REGISTER  BIT  ASSIGNMENT 

The  connector  for  #2  controller  serves  as  the  interface  between  the  Su- 
per NES  Super  Scope-RX  and  the  Super  NES.  Like  a standard  controller, 
the  Super  NES  controller  can  read  signals  automatically.  Address  and  bit 
assignments  are  indicated  in  the  following  figures.. 

D7  DO 

421 A (H)  11111111 

I I MULTIPLE  I I 1 

42 IB  (H)  trigger  cursor  shots  p/s  0 0 null  noise 


421 A (H)  is  always  FF  (H).  D7,  6,  5 and  4 of  421A(H)  are  unspecified  bits. 
D3,  2,  1,  and  0 of  421 A (H)  and  D2  and  3 of  421B  (H)  are  Super  NES  Super 
Scope  ID  codes. 

213C  (H)  Horizontal  counter  latch 


2 1 3D  (H)  Vertical  counter  latch 


The  horizontal/vertical  counter  is  a hard  counter  whose  latch  trigger  is  set  by 
the  Super  NES  Super  Scope. 

213F  (H) 


D6  of  213F  (H)  is  the  external  latch  flag. 

Figure  4-1-4  Address  and  Bit  Assignments 


4-1-4 


INTRODUCTION 


ITEM 

ACTIVITY 

LEVEL 

EXPLANATION 

Trigger 

High 

Indicates  that  the  trigger  has  been  pulled. 

Cursor 

High 

Indicates  cursor  mode. 

Single/multiple 

High 

Indicates  single  or  multiple  shot  mode. 

Pause 

High 

Indicates  that  the  pause  button  is  pressed. 

Noise 

High 

Indicates  that  noise  disturbance  is  impairing  operations. 

Null 

High 

Indicates  that  a valid  raster  signal  could  not  be  found. 

H counter 

— 

The  H-position  of  the  hit 

V counter 

— 

The  V-position  of  the  hit 

EXT  latch 

High 

Indicates  that  the  data  was  set  to  the  HV  counter. 

The  external  latch  only  can  be  reset  by  read.  (It  cannot  be  reset  by  the  write  command.) 
Table  4-1-1  Signal  Bit  Definitions 


4-1-5 


SNES  DEVELOPMENT  MANUAL 

l~~ 


3 


Chapter  2.  Principles  of  the  Super  NES  Super  Scope 

2.1  PRINCIPLES  OF  THE  SUPER  NES  SUPER  SCOPE 

A comprehensive  explanation  of  the  Super  NES  Super  Scope’s  operation  would 
involve  a wide  spectrum  of  topics  and  require  more  space  than  is  allowable  here. 
The  following  is  a basic,  if  cursory,  description. 

The  Super  NES  projects  60  pictures  per  second  on  the  television  screen.  That  is, 
every  1/60  second,  a picture  frame  is  projected  on  the  television.  But  before  ex- 
plaining how  the  picture  is  drawn,  it  is  necessary  to  describe  the  Braun  tube  or 
CRT  in  the  television  set. 

A florescent  material  (phosphor  coating)  is  fused  to  the  inside  of  the  Braun  tube’s 
glass  screen.  Light  is  emitted  when  electrons  bombard  this  florescent  material. 

The  inside  of  the  Braun  tube  resembles  a funnel  (refer  to  the  figure  below)  and  an 
“electron  gun”  is  located  at  the  rear  of  the  tube.  (This  is  the  section  which  extends 
from  the  back  of  a television.) 


4-2-1 


PRINCIPLES  OF  THE  SUPER  SCOPE 


The  electron  gun  discharges  a beam  of  electrons  toward  the  screen.  This,  by  it- 
self, would  only  light  a fixed  spot  where  the  electron  beam  hit  the  screen;  howev- 
er, deflecting  coils  are  attached  to  the  base  of  the  tube  and  a signal  is  transmitted 
to  the  coils  to  drive  the  electron  beam  in  the  direction  desired. 


Figure  4-2-2  Scanning 

Using  this  technique,  the  electron  beam  scans  from  left  to  right  beginning  at  the 
top  left  of  the  screen  and  moving  successively  down  the  screen,  as  shown  in  the 
above  figure.  Each  horizontal  line  formed  by  the  scan  is  called  a scan  line  or  a 
raster.  Light  and  dark  areas  are  created  by  varying  the  intensity  of  the  electron 
beam  as  it  scans  across  the  florescent  material.  This  is  how  each  picture  is  drawn. 

The  Super  NES  contains  a PPU  (picture  processing  unit),  for  controlling  the  pic- 
ture projected  on  the  screen.  Inside  the  PPU  is  a “raster  counter”  (or  “HV  counter”) 
with  a register  which  holds  the  X and  Y coordinates  of  the  electron  beam  in  the 
Braun  tube  as  it  scans. 

When  the  Super  NES  Super  Scope  is  aimed  at  the  screen,  a small  area  on  the 
screen  is  seen  by  the  Super  NES  Super  Scope. 


Figure  4-2-3  Area  Seen  by  Super  NES  Super  Scope 


4-2-2 


SNES  DEVELOPMENT  MANUAL 


As  shown  in  the  previous  figure,  the  instant  the  electron  beam  scans  across  the 
area  seen  by  the  Super  NES  Super  Scope,  it  sends  a signal  to  the  Super  NES. 
The  Super  NES  registers  the  value  of  the  PPU  raster  counter  using  this  timing  sig- 
nal. With  this  data,  the  Super  NES  can  detect  the  point  on  the  screen  where  the 
Super  NES  Super  Scope  is  aimed. 

2.2  SUPER  NES  SUPER  SCOPE  PROGRAMMING 

We  assume  that  most  readers  are  involved  in  programming  Super  NES  Super 
Scope  games.. 


The  above  figure  depicts  the  output  of  the  Super  NES  Super  Scope’s  light  recep- 
tion amplifier  under  these  conditions.  Each  of  the  pulses  represents  a raster  in  the 
Braun  tube.  The  Super  NES  Super  Scope  system  picks  a pulse  and  transmits  it  to 
the  Super  NES  raster  counter.  Pulse  selection  determines  the  vertical  location  on 
the  screen  by  the  raster  count.  This  is  done  under  a fixed  set  of  conditions  by  the 
Super  NES  Super  Scope’s  internal  CPU. 

The  horizontal  position  is  determined  by  the  timing  of  pulses  with  respect  to  the 
Super  NES  Control  Deck’s  horizontal  synchronization  signal.  (Refer  to  the  figure 
below.) 

Raster  ^ r 

Pulse  , ^ 


Horizontal 
Sync  Signal 


63-5  |Lts 

Figure  4-2-5  Horizontal  Positioning 


4-2-3 


PRINCIPLES  OF  THE  SUPER  SCOPE 


The  time  corresponding  to  one  dot  on  the  screen  is  an  amazing  1 80  nsec.  This 
processing  speed  cannot  be  achieved  by  most  micro-computers,  and  in  the  Super 
NES  Super  Scope  system,  the  raster  pulse  is  not  processed  directly  by  the  CPU. 
Signal  transmission  and  selection  is  done  by  opening  and  closing  the  raster  gate, 
controlled  by  the  CPU,  and  is  depicted  in  the  block  diagram  in  Chapter  1 . An  area 
of  caution  for  Super  NES  Super  Scope  programs  is  that  Super  NES  Super  Scope 
operations  are  not  synchronized  with  the  Super  NES.  The  timing  relationship  be- 
tween the  Super  NES  Super  Scope,  the  Super  NES  screen  scan,  and  the  pro- 
gram, described  later,  should  be  kept  in  mind  when  programming. 

2.3  THE  SUPER  NES  HORIZONTAL/VERTICAL  COUNTER 

The  horizontal/vertical  counter  of  the  Super  NES  plays  a critical  role  in  the  Super 
NES  Super  Scope  system,  yet  is  not  described  in  much  detail  in  the  Super  NES 
programming  manual  or  other  documents.  For  this  reason,  we  will  present  an 
overview  here. 


Vertical  Sync  Signal 


External  Latch  Pins 


Figure  4-2-6  Horizontal/Vertical  Counter 

The  horizontal  counter  value  corresponds  to  the  horizontal  location  of  the  raster 
and  the  vertical  counter  value  corresponds  to  the  vertical  location  of  the  raster. 

These  values  can  be  stored  by  sending  a pulse  to  the  external  latch  pin.  The  Su- 
per NES  software  then  reads  this,  and  is  able  to  detect  the  location  on  the  screen 
which  corresponds  to  the  external  latch  pulse. 

In  the  Super  NES  Control  Deck,  a flag  is  set  when  the  horizontal/vertical  latch  is 
set.  This  flag  does  not  operate  in  synchronization  with  the  programming  flow,  and 
interrupts  are  not  supported  by  the  Super  NES  Control  Deck.  Hence,  program- 
ming precautions  should  be  taken. 


4-2-4 


SNES  DEVELOPMENT  MANUAL 


a 


Chapter  3.  Super  NES  Super  Scope  Functional  Operation 


3.1  SUPER  NES  SUPER  SCOPE  CPU 

The  Super  NES  Super  Scope  CPU  is  a one-chip  CPU  for  processing  Super  NES 
Super  Scope  key  input  (trigger,  cursor,  etc.),  data  pulse  generation,  and  transmis- 
sion of  screen  timing  signals. 

3.1.1  KEYS 

Trigger 

Continuous  input 
One-shot  input 

Switches  between  continuous  trigger  in- 
put and  one-shot  input 

3.1.2  KEY  PRIORITY 

Priority  is  given  in  the  order  of  the  trigger,  cursor  and  pause  keys.  Two 
types  of  trigger  codes  are  generated  by  switching  between  the  multiple 
and  single  shot  modes. 

3.1.3  KEY  RECOGNITION 

A key  is  recognized  as  “on”  after  it  is  on  for  1 msec  or  more,  and  “off  after 
20  msec  or  more. 

3.1.4  SIMULTANEOUS  KEY  INPUT 

Only  the  trigger  and  cursor  keys  can  be  input  at  the  same  time.  Other  key 
combinations  are  not  recognized. 


Trigger 

Cursor 

Pause 

Multiple/single  shot 


3.2  SUPER  NES  SUPER  SCOPE  BLOCK  DIAGRAM 


Figure  4-3-1  Super  NES  Super  Scope  Block  Diagram 


4-3-1 


FUNCTIONAL  OPERATION 


] 


3.2.1  LIGHT  RECEIVER/AMPLIFIER 

The  light  receiver/amplifier  receives  the  light  signal  from  the  CRT,  con- 
verts it  to  pulses,  and  transmits  the  pulses  to  the  Super  NES  Super 
Scope  CPU.  It  consists  of  a pin  photo-diode  H-amp,  and  an  M-amp  for 
signal  amplification  and  pulse  conversion. 

3.2.2  SUPER  NES  SUPER  SCOPE  CPU  (SM595) 

The  Super  NES  Super  Scope  CPU  reads  the  Super  NES  Super  Scope, 
generates  the  corresponding  code,  controls  the  raster  gate,  and  sends 
the  raster  signal  to  the  Super  NES  Super  Scope  receiver. 

3.2.3  LIGHT  OUTPUT 

This  converts  the  pulse  generated  by  the  CPU  into  an  infra-red  beam.  It 
consists  of  an  infra-red  LED  and  its  driver. 

3.3  SUPER  NES  SUPER  SCOPE  FLOW  DIAGRAM 


Figure  4-3-2  Super  NES  Super  Scope  Flow  Diagram 
The  Super  NES  Super  Scope  does  not  process  the  raster  signal. 


4-3-2 


3.4  INFRA-RED  DATA  TRANSMISSION  FORMAT 


3.4.1  Overview 

The  Super  NES  Super  Scope  infra-red  signal  is  composed  of  two  seg- 
ments. The  first  segment  contains  a digital  code,  which  defines  the  sin- 
gle-shot trigger,  multiple-shot  trigger,  cursor,  and  pause.  The  second 
segment  is  the  raster  segment.  The  Super  NES  Super  Scope  CPU  opens 
the  raster  gate  and  connects  the  light  receiver/amplifier  and  light  output. 
The  raster  signal  is  output  from  the  CRT  for  a set  duration  of  time. 


Code  Segment  Raster  Segment 


Figure  4-3-3  Raster  Signal 

3.4.2  DESCRIPTION  OF  ONE  BYTE 

The  Super  NES  Super  Scope  system  can  generate  four  types  of  codes 
based  on  the  status  of  the  keys.  One  byte  is  defined  as  follows. 


1 2 3 4 5 6 7 8 


a = 10  |is  b = 71  |is 


Figure  4-3-4  Definition  of  one  byte 

One  byte  is  composed  of  a block  of  eight  pulses  as  shown  above. 


4-3-3 


FUNCTIONAL  OPERATION 


The  code  is  generated  by  combining  five  one-byte  blocks  as  shown  be- 
low. 


1 2 3 4 5 


c = 577  (J,s  d = 651  |4s 

Figure  4-3-5  Output  Signal  Code 

Byte  1 is  the  switch  byte. 

Byte  5 is  the  end  byte. 

Bits  2,  3 and  4 are  data  bits 

3.4.3  COMMUNICATION  CODES 

Four  codes  are  defined  as  follows. 


Cursor 


Outputs  while  cursor  is  held  down 


Trigger 

(multiple  shots) 


When  the  “multiple  shots”  switch  is  “on”,  pulses  are  output 
while  the  trigger  is  held  depressed. 


Trigger 
(single  shot) 


When  the  “multiple  shots”  switch  is  “off”,  one  output  pulse 
occurs  each  time  the  trigger  is  depressed. 


Pause 


This  output  pulse  occurs  only  when  the  pause  key  is 
depressed. 

Figure  4-3-6  Definitions  of  codes. 


4-3-4 


SNES  DEVELOPMENT  MANUAL 


3 


3.4.4  RASTER  SIGNAL  TRANSMISSION  TIMING 


a.  Trigger  (single 

shot) 

j*  Wait  ! 
f (10  ms)  (i 

Chattering  (1  ms 

5 5ms)V  Raster  Output  (85  ms)  ^ Bounce  (20  ms)  1 

a i 

;)  Wait  (0.6  ms) 

b.  Trigger  (multi) 

Die  shots) 

^Wait*  So 

/ (10msX5.5 
Chattering  (1  ms 

de  y Raster  Output  (85  ms)^H7"WaifjpC 
msj'v  K v y (10msX5.J 

>)  Wait  (0.6  ms)  Chattering  (1  ms) 

Wait  (0.6  ms) 

Figure  4-3-7  Raster  Signal  Transmission  Timing,  part  1 

The  cycle  above  is  repeated  while  the  trigger  is  held  down.  When  the  trig- 
ger is  released,  a single  shot  cycle  occurs  as  the  final  cycle 


4-3-5 


FUNCTIONAL  OPERATION 


c.  Cursor 

J Wait  Cod< 
4 (10msX5.5rr 

Chattering  (1  ms) 

5 W Raster  Output  (85  ms)  >s7Vyait  J 
isf\  K v y (10msX 

Wait  (0.6  ms)  Chattering  (1  ms' 

^Code^  Raster  Output 
5.5  ms)N:  (85  ms) 

) Wait  (0.6  ms) 

d.  Pause 

"7,^  Wait  ^ ^ode 
4 (10  ms)  (5.5  ms 

Chattering  (1  ms)  W 

M H 

Bounce  (20  ms) 

\ 

'ait  (0.6  ms) 

Figure  4-3-7  Raster  Signal  Transmission  Timing,  part  2 

The  raster  gate  opens  during  raster  output  and  the  raster  pulses  are 
transmitted  to  the  Super  NES  Super  Scope  receiver.  The  raster  pulse 
timing  is  not  defined.  The  Super  NES  Super  Scope  and  Super  NES  Con- 
trol Deck  are  not  synchronous. 


4-3-6 


SNES  DEVELOPMENT  MANUAL 


Chapter  4.  Super  NES  Super  Scope  Receiver  Functions 

4.1  SUPER  NES  SUPER  SCOPE  RECEIVER  BLOCK  DIAGRAM 

The  Super  NES  Super  Scope  receiver  first  receives  the  infra-red  signal  from  the 
Super  NES  Super  Scope,  and  transmits  the  key  switches  and  screen  timing  sig- 
nals to  Super  NES  Control  Deck. 


Figure  4-4-1  Receiver  Block  Diagram 

4.1.1  INFRA-RED  LIGHT  RECEIVER/AMPLIFIER 

Receives  the  infra-red  signal  from  the  Super  NES  Super  Scope,  converts 
it  to  pulses,  and  transmits  the  pulses  to  the  Super  NES  Super  Scope  re- 
ceiver CPU.  It  consists  of  a pin  photo  diode  H-amp  and  an  M-amp  for  sig- 
nal amplification  and  pulse  conversion. 

4.1.2  SUPER  NES  SUPER  SCOPE  RECEIVER  CPU 

The  CPU  analyzes  the  code  signal  from  the  Super  NES  Super  Scope, 
controls  the  shift  register  flag  and  raster  gate,  and  sends  the  raster  puls- 
es to  the  Super  NES  external  latch  pin. 

4.1.3  SHIFT  REGISTER 

This  is  the  interface  between  the  Super  NES  Super  Scope  receiver  CPU 
and  the  Super  NES  Control  Deck,  and  is  similar  to  the  type  of  interface 
found  in  a controller. 


4-4-1 


RECEIVER  FUNCTIONS 


1 

4.1 .4  OPERATIONS  FLOW  DIAGRAM 


Figure  4-4-2  Operation  Flow  Diagram 

In  addition,  a pulse  check  is  performed  during  code  detection  for  noise 
detection. 


4-4-2 


SNES  DEVELOPMENT  MANUAL 


4.2  SUPER  NES  SUPER  SCOPE  RECEIVER  INTERFACE 


Figure  4-4-3  Receiver  Interface  Schematic 


4-4-3 


RECEIVER  FUNCTIONS 


4.3  CODE  PULSE  DETECTION 

4.3.1  ONE  BIT  CODE  DETECTION 


Block 

(1) 


(2) 


(3) 


(4) 


(5) 


Figure  4-4-4  One  Bit  Code  Detection 

A block  is  good  if  five  - 81  |isec  pulses  are  detected  in  succession  in  any 
of  the  ranges,  A,  B,  C and  D shown  above. 

A noise  flag  is  set  if  the  “high”  level  is  detected  36-39  |4sec  after  the  ris- 
ing edge  of  a pulse  is  detected. 


4-4-4 


SNES  DEVELOPMENT  MANUAL 


1 


4.3.2  RASTER  PULSE  DETECTION 


The  start  of  detection  and  input  of  raster  pulses  do  not  coincide  in  the  ex- 
ample below. 


Infrared 
amplifier 
output  — i 


0 0 ^ ^ ^6  7 8 9 


Raster  gate; 


1 63us' 

◄ ►! 


Detection  start 

► 

Detection  period 


tf 


28us 


14ms  ^OP 


The  latch  gate  opens  when  pulses  1~6  are  detected  with  the  precise  cy- 
cle time. 


In  the  next  example,  the  start  of  detection  and  input  of  raster  pulses  coin- 
cide. 


Infrared 

amplifier 

output 


Detection  start 


4 


5ms  NOP 


> 


Two  pulses  immediately  following  the  start 


If  two  raster  pulses  are  detected  immediately  following  the  start  of  raster 
pulse  detection,  it  is  determined  that  the  detection  cycle  occurred  at  the 
same  time  as  raster  pulse  input.  In  this  case,  the  receiver  CPU  would  per- 
form time  calculations  for  5 msec.  In  this  frame,  the  CPU  does  not  at- 
tempt to  output  the  raster  signal. 

An  error  occurs  when  a raster  exceeds  5 msec.  (With  the  existing  optical 
system,  this  may  happen  1 .64  feet  away  from  a 14-inch  television 
screen.) 


4-4-5 


RECEIVER  FUNCTIONS 


4.4  FUNCTIONAL  DESCRIPTION 

4.4.1  CURSOR  MODE 


Code, 


\ 


Infrared 

amplifier 

output 


4021 P7  

(CURSOL)1 ,1ms 


Raster  End  cycle  with  the 

signal  trigger  switch  off 

\ ^ v 


Raster 

detection 

cycle 


Figure  4-4-5  Cursor  Mode  Raster  Detection  Cycle 

In  the  cursor  mode,  the  cursor  is  displayed  continuously  on  the  screen. 
To  accomplish  this,  raster  pulses  are  transmitted  for  five  frames  (85 
msec)  after  code  data  is  sent  from  the  Super  NES  Super  Scope. 


4-4-6 


SNES  DEVELOPMENT  MANUAL 


4.4.2  TRIGGER  MODE  (SINGLE  SHOT) 

Trigger  code.  - - 1, 


Infrared 

amplifier 

output 


4021 P8  (TRIG) 


4021 P6  

(single/multiple) 

Raster  

detection 

cycle 


The  next  code  is  prohibited 
in  this  period 


85ms 


102ms 


81ms 


0.2ms 


Figure  4-4-6  Trigger  Mode,  Single  Shot 


4-4-7 


RECEIVER  FUNCTIONS 


4.4.3  TRIGGER  MODE  (MULTIPLE  SHOTS) 


End  cycle  with  the 
trigger  switch  off 


Code. 

Infrared 

amplifier 

output 

4021 P8 
(TRIG) 


4021 P6  

(single/multiple) 


Raster 

detection 

cycle 


Figure  4-4-7  Trigger  Mode,  Multiple  Shots 


4.4.4  NOISE  FLAG 


36  - 39us  J 


Infrared  amplifier 
output  


4021  PI 
(NOISE) 


36  - 39us 


20ms  i 

►; 


Figure  4-4-8  Noise  Flag 

Under  the  timing  shown  above,  the  noise  flag  is  set  when  a pulse  with  a 
cycle  time  different  from  that  used  by  the  Super  NES  Super  Scope  sys- 
tem is  detected  while  waiting  for  the  code. 


4-4-8 


SNES  DEVELOPMENT  MANUAL 


1 


4.4.5  NULL  BIT 


Infrared 

amplifier- 

output 


Raster 

gate 


4021 P2 
(NULL) 


Super  NES  Super  Scope 
is  not  aimed  at  the  screen 


Super  NES  Super  Scope 
is  aimed  at  the  screen 


Figure  4-4-9  Null  Bit 

The  null  flag  is  set  if  a valid  raster  signal  is  not  detected  during  a raster 
detection  cycle.  It  is  reset  if  a valid  raster  signal  is  detected  in  a subse- 
quent cycle  and  the  raster  gate  is  opened. 

4.4.6  PAUSE  BIT 


I 

I 

I 


4021 P5 
(Pause) 


Figure  4-4-10  Pause  Bit 

This  flag  is  set  when  a pause  code  is  received  from  the  Super  NES  Super 
Scope. 


4-4-9 


4.4.7  CURSOR  + TRIGGER  CYCLE 

4.4.7. 1 TRIGGER  (SINGLE  SHOT) 


Figure  4-4-11  Trigger,  Single  Shot 


4-4-10 


SNES  DEVELOPMENT  MANUAL 


4.4. 7.2  TRIGGER  (MULTIPLE  SHOTS) 


Figure  4-4-12  Trigger,  Multiple  Shots 

Same  as  the  cursor  mode  except  the  trigger  flag  and  single/multi- 
ple shot  flags  vary. 

Note:  In  this  section,  the  timing  charts  for  each  4021  Px  flag  (trig- 
ger, cursor,  single/multiple  shot,  etc.)  are  expressed  in  negative 
logic  (active  low);  however,  these  are  positive  logic  (active  high)  in 
the  Super  NES  program. 


4-4-11 


GRAPHICS 


Chapter  5.  Graphics 

5.1  LIMITATIONS  ON  GRAPHICS 

Because  Super  NES  Super  Scope  operations  are  based  on  the  detection  of  ras- 
ters on  a television  screen,  the  screen  used  must  have  a minimum  level  of  bright- 
ness. 

Of  particular  concern  is  the  fact  that  the  Super  NES  Super  Scope  is  not  sensitive 
to  the  color  red.  This  is  due  to  differences  in  the  afterglow  characteristics  of  the 
fluorescent  materials  used  in  the  Braun  tube  for  the  three  colors,  red,  green  and 
blue.  The  period  of  florescence  for  red  is  relatively  longer,  as  shown  in  the  table 
below,  and  hence  the  change  in  the  volume  of  light  over  time  is  smaller  (16  KHz 
horizontal  synchronization  frequency  component),  and  raster  timing  is  more  diffi- 
cult to  detect. 


Red 

1 .2  msec 

Green 

300  jLlsec 

Blue 

250  jLlsec 

The  minimum  level  of  brightness  which  the  Super  NES  Super  Scope  can  detect  is 
very  difficult  to  predict  due  to  the  various  factors  involved  (television  type,  year  of 
make,  screen  adjustment,  etc.).  An  Optical  Color  Sensitivity  Chart  is  provided  on 
the  following  page  for  programming  reference. 

If  you  wish  to  detect  the  location  on  the  screen  in  one-dot  increments  or  draw  a 
dark  picture,  such  as  of  outer  space,  you  may  wish  to  insert  a bright  single-color 
screen  for  one  frame. 

When  accuracy  is  important,  be  careful  of  the  variation  in  luminosity  across  the 
screen.  On  a 14-inch  screen  there  is  about  1.5  times  variation  in  luminosity  be- 
tween the  center  and  the  perimeter  of  the  screen.  When  the  screen  is  dark,  the 
Super  NES  Super  Scope  signal  may  be  delayed,  and  the  location  detected  will  be 
shifted  to  the  right.  This  may  be  corrected  in  the  program  or  the  Super  NES  color 
operation  function  may  be  used  to  correct  for  luminosity. 

NOTE:  Nintendo’s  products  and  game  programs,  designed  in  accordance 
with  these  specifications,  are  subject  to  claims  of  patent  and  patent  pending 
owned  and/or  licensed  by  Nintendo  exclusively  for  the  benefit  of  Nintendo 
and  its  authorized  licensees.  Nintendo  does  not  license  such  rights  for  any 
other  use  or  purpose.  Nintendo  does  not  warrant  or  represent  against 
claims  of  patent  infringement  by  third  parties. 


4-5-1 


SNES  DEVELOPMENT  MANUAL 


5.2  SUPER  NES  SUPER  SCOPE  OPTICAL  COLOR  SENSITIVITY 
CHART 


The  Super  NES  Super  Scope  is  not  sensitive  to  red  at  all.  The  error  increases  in 
area  “A”,  above.  There  is  no  problem  in  area  “B”.  This  chart  is  based  on  the  mea- 
surement of  a single  color  on  the  screen  and  should  be  used  as  a reference  only, 
since  the  screen  pattern  does  introduce  variations. 


4-5-2 


SUPER  NES  MOUSE  SPECIFICATIONS 

1 


Chapter  6.  Super  NES  Mouse  Specifications 

6.1  INTRODUCTION  TO  SUPER  NES  MOUSE 

The  Super  NES  Mouse  is  a special  purpose  serial  mouse.  Displacement  data  de- 
tected in  the  mouse  is  processed  on  a custom  chip.  Data  is  input  to  the  Super 
NES  console  via  the  7 pin  connector  as  key  data.  The  mouse  does  not  burden  the 
program  in  any  way.  The  programmer  need  only  call  the  standard  basic  input/out- 
put system  (BIOS)  subroutine  for  processing  mouse  data.  Thus,  the  Super  NES 
Mouse  is  substituted  for  the  standard  controller.  The  mouse  has  three  tracking 
speeds.  A speed  selection  switch  inside  the  mouse  can  be  controlled  by  the  fol- 
lowing two  methods. 

• Game  software  which  allows  user  selection 

• Game  software  which  provides  a fixed  speed 


4-6-1 


SNES  DEVELOPMENT  MANUAL 

[""  :;"11  X : ■:  ■ : 


6.2  SUPER  NES  MOUSE  DATA  FLOW 

Super  NES  Mouse  data  is  transmitted  to  the  Super  NES  control  deck  in  a serial  in- 
put format,  like  the  standard  controller.  A 32  bit  data  string  is  transmitted;  howev- 
er, only  24  bits  are  used.  The  figure  below  shows  a valid  data  string  transmitted  to 
the  Super  NES  control  deck,  from  the  Super  NES  Mouse.  Signals  from  the  Super 
NES  Mouse  are  transmitted  in  negative  logic  and  converted  to  positive  logic  data 
strings  by  the  input  inversion  buffer  in  the  Super  NES  control  deck.  Note  that  all 
the  data  shown  has  already  been  loaded  into  the  Super  NES  control  deck. 


SDO 

SD1 

SD2 

SD3 

SD4 

SD5 

SD6 

SD7  j 

0 

0 

0 1 

Ul  IUOCU 
0 I 0 

0 1 

0 1 

0 

SD8 

SD9 

SD10 

SD11 

SD12 

SD13 

SD14 

SD15 

R 

Button 

L 

Button 

Speed  data 

1 

0 

Signature 
° i ° i 

1 

SD10  and  11  contain  tracking  speed  data:  00  = slow,  01  = normal,  and  10  = fast. 


-► ► 


SD16 

SD17  SD18  SD19  SD20  SD21  SD22  SD23 

v 

1 

Direction 

^ t uispiacemeni ► 

i i i i i i 

l 

SD16  = 0 for  downward,  1 for  upward. 


SD24  SD25  SD26 

X ' |^~ 

Direction  i 


SD27  SD28  SD29  SD3Q  SD31 
— X Displacement ► 


Figure  4-6-1  Valid  Super  NES  Mouse  Data  String 


4-6-2 


6.2.1  DATA  TRANSMISSION 

The  Super  NES  Mouse  has  four  8-bit  shift  registers.  These  registers  are 
serially  connected  as  indicated  by  the  arrows  in  the  figure  on  the  previous 
page.  The  Super  NES  Mouse  transmits  32  bits  of  data  to  the  Super  NES 
control  deck  following  each  OUTO  pulse,  using  CUPO  as  a clock  pulse. 
The  Super  NES  control  deck  transmits  this  OUTO  pulse  at  a fixed  interval. 
The  sequence  is  from  SDO  to  SD31 . 

6.2.2  READ  METHODS 

For  details  concerning  the  manner  in  which  the  Super  NES  control  deck 
reads  serial  controller  data,  refer  to  “Joy  Controller”  in  the  “Software”  sec- 
tion of  this  manual. 

6.2.2. 1 METHOD  1 

Sixteen  bits  are  read  by  hardware  and  1 6 bits  are  read  by  soft- 
ware. Any  complications  arising  from  the  use  of  this  method 
may  be  avoided  by  using  the  enclosed  standard  BIOS, 
“mouse_read”. 

6.2. 2. 2 METHOD  2 

Thirty-two  bits  are  read  by  software. 


4-6-3 


SNES  DEVELOPMENT  MANUAL 


6.3  SPEED  SWITCHING 

Super  NES  Mouse  speed  can  be  switched  as  described  in  the  following  para- 
graphs. 

6.3.1  USING  SOFTWARE 

The  programmer  should  write  1 in  DO  of  401 6H  (OUTO  is  HI),  and  imme- 
diately read  401 6H.  (Read  401 7H  for  controller  2).  Then,  set  OUTO  to 
LOW,  and  immediately  read  401 6H  again.  (Read  401 7H  for  controller  2). 
The  mouse  speed  will  switch  to  the  next  setting,  in  the  order  of  slow,  nor- 
mal, fast,  and  back  to  slow,  each  time  this  operation  is  performed. 

6.3.2  USE  OF  OUTO  AND  CUP0  SIGNALS 

Set  OUTO  to  HI,  and  set  CUP0  once  to  [LOW  HIGH]  (read  401 6H). 
Next,  set  OUTO  to  LOW,  and  once  again  set  CUP0  to  [LOW  — » HIGH]. 
This  changes  the  mouse  tracking  speed  by  one  setting.  The  speed  is 
changed  by  two  settings  if  CUP0  is  set  LOW  to  HI  twice  while  OUTO  is  HI. 

6.3.3  CAUTIONS 

Once  switched,  the  speed  mode  is  output  to  SD10  and  SD1 1 . Note  that 
the  speed  setting  in  SD10  and  SD1 1 may  not  be  the  same  as  the  speed 
setting  in  the  mouse.  The  mouse  tracking  speed  should  always  be 
switched  once  immediately  after  connecting  the  mouse  to  ensure  that  the 
mouse  tracking  speed  and  the  speed  setting  in  SD10  and  SD1 1 are  the 
same.  This  should  also  be  done  when  the  mouse  is  accidentally  discon- 
nected during  a game. 

The  sample  software  MOUSE. X65  contains  a subroutine  for  switching 
speeds  called  speed_change. 

(Refer  to  “Mouse  Speed  Switching  Routine”  in  the  following  chapter.) 


OUTO 

CUP0 


4-6-4 


SUPER  NES  MOUSE  SPECIFICATIONS 


6.4  DATA 

6.4.1  SIGNATURE  (SD1 2-SD1 5) 

The  signature  is  stored  in  SD12-SD15.  Use  this  code  to  identify  what  is 
currently  connected  to  the  7 pin  console  connector.  (When  using  the 
standard  BIOS,  check  the  connection  with  mouse_con  in  the  Super  NES 
register.  Refer  to  “Using  the  Standard  BIOS”.)  When  the  mouse  is  con- 
nected, the  code  is  0001 B.  Check  the  signature  to  verify  whether  or  not 
the  mouse  is  connected.  If  a different  signature  appears  (signatures  up  to 
1 1 1 1 B may  be  assigned  to  input  devices  other  than  a mouse),  input  data 
should  be  inhibited.  When  nothing  is  connected  or  a standard  controller  is 
connected,  the  signature  is  0000B. 

6.4.2  SPEED  DATA  (SD1 0 and  SD1 1 ) 

The  speed  data  identifies  whether  the  speed  mode  in  the  mouse  is  set  to 
slow  (00B),  normal  (01 B)  or  fast  (10B).  The  mouse  contains  an  internal 
speed  switching  circuit  which  switches  between  the  three  different  track- 
ing speeds.  Switching  between  speeds  is  done  using  software  in  the  Su- 
per NES  console.  (Refer  to  “Speed  Selection  and  Cursor  Movement”  to 
switch  the  tracking  speed).  SD10  and  SD1 1 contain  the  data  the  mouse 
transmits  to  the  Super  NES  console  to  inform  the  Super  NES  console 
which  speed  mode  is  currently  active. 

6.4.3  LEFT  AND  RIGHT  ACTUATORS  (SD8  and  SD9) 

Bit  SD9  is  “1”  when  the  left  mouse  actuator  is  pressed,  and  SD8  is  “1” 
when  the  right  actuator  is  pressed. 


4-6-5 


6.4.4  X,  Y ABSOLUTE  DISPLACEMENT  (SD1 6-SD31 ) 

When  moving  an  object  or  BG  with  the  mouse  in  a positive  direction 
(SD16  and  SD24  = 0),  add  the  X and  Y data  to  the  respective  horizontal 
and  vertical  positions.  When  moving  an  object  or  BG  in  the  negative  di- 
rection (SD16  and  SD24  = 1),  subtract  the  seven  bits,  which  are  the  X 
and  Y data  less  the  direction  bits  (SD16  and  SD24)  from  the  positions. 
Note  that  SD16  and  SD24  are  the  most  significant  bits  and  SD23  and 
SD31  are  the  least  significant  bits. 


SD10 

Ufj>jDer 

SD11 

Lower 

Bit 

Speed 

Mode 

0 

0 

Slow 

0 

1 

Normal 

1 

0 

Fast 

SD16SD17SD18 

j : 

c n 
o 

CO 

SD20 

| SD21 

SD22SD23 

Direction  of 
movement 

0 

| D6 

D5 

1 D4 

D3 

| D2 

D1 

DO 

Down 

1 

i 

| D6 

D5 

1 D4 

D3 

| D2 

D1 

DO 

Up 

Direction 


Y Displacement- 
X Displacement- 


SD24SD25 

SD26 

SD27  SD28SD29 

SD30SD31 

Direction  of 
movement 

0 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

Right 

| 1 [ D6  | D5  [ D4  j D3  | D2  | D1  j DO  | Left 

D6-D0  change  with  the  amount  of  mouse  displacement.  (Max.  3F) 


Figure  4-6-3  Explanation  of  Data  Strings  2 Bits  or  Longer 


4-6-6 


SUPER  NES  MOUSE  SPECIFICATIONS 


6.5  SUPER  NES  MOUSE  SPECIFICATIONS 

6.5.1  ELECTRICAL  SPECIFICATIONS 

Operating  voltage:  5 V ± 1 0% 

Current  consumption:  50  mA  (maximum) 

6.5.2  OPERATIONAL  AND  ENDURANCE  SPECIFICATIONS 

Resolution:  50  counts/inch  ± 1 5% 

Tracking  speed:  250  mm/sec  (maximum) 

Useable  Life:  5000  hours  in  powered  state  (min.) 

(with  vertical  load  of  100  g and  voltage  of  5 V ± 5%.) 

Actuators:  two  tact  switches  (guaranteed  to  endure  at  least  2.5  million  en- 
gagements.) 

6.5.3  DIMENSIONS 

Length:  98  mm 
Width:  64  mm 
Height:  35  mm 
Cable  length:  1 .4  m 
Weight:  approximately  140  g 


Figure  4-6-4  Super  NES  Mouse  Dimensions 


4-6-7 


SNES  DEVELOPMENT  MANUAL 


Chapter  7.  Using  the  Standard  BIOS 
7.1  THE  STANDARD  BIOS 

Nintendo  strongly  recommends  the  use  of  the  following  standard  BIOS  with  all  Su- 
per NES  Mouse  related  programming.  If  the  standard  BIOS  is  not  used,  future 
modifications  to  the  mouse,  the  Super  NES  control  deck,  or  related  software, 
hardware,  or  accessories  will  likely  impair  or  limit  the  future  use  and/or  compat- 
ability  of  such  non-standard  programs. 

The  software  enclosed  contains  a file  called  MOUSE.X65.  This  file  has  two  sub- 
routine programs. 

1.  mouse_read:  reads  serial  data  from  the  mouse. 

2.  speed_change:  switches  the  mouse  speed. 

Whenever  mouse_read  is  used,  speed_change  should  also  be  used.  An  explana- 
tion of  how  to  use  these  sub-routines  is  given  below.  Refer  to”Registers”  for  a 
summary  of  the  registers  needed  to  use  the  standard  BIOS,  mouse_read,  and 
speed_change. 


4-7-1 


USING  THE  STANDARD  BIOS 


7.2  MOUSE  SERIAL  DATA  READ  ROUTINE  (mouse_read) 

This  routine  is  used  in  the  same  way  the  key  data  read  subroutine  is  used  with  a 
standard  controller.  Mouse_read  must  be  called  as  a subroutine  in  the  main  pro- 
gram at  every  frame.  All  information  needed  for  using  the  mouse  can  be  found  in 
the  registers  shown  in  the  figure,  “Standard  BIOS  Output  Register”,  on  the  follow- 
ing page.  (Data  is  read  when  the  mouse  is  connected  to  either  connector  1 or  2.) 

Cautions  concerning  this  program: 

1 . The  program,  mouse_read,  uses  an  automatic  key  data  read  function  to 
read  the  serial  data  from  the  mouse.  Therefore,  the  automatic  read  func- 
tion must  always  be  turned  on  when  the  standard  BIOS,  mouse_read,  is 
used. 

2.  Do  not  call  this  subroutine  during  the  automatic  read  (hardware  read). 

Refer  to  “Joy  Controller”  in  the  Software  section  of  this  manual  to  cir- 
cumvent the  timing  problem. 

3.  Always  use  mouse_read  and  speed_change  together.  The  mouse  track- 
ing speed  must  always  be  switched  once  immediately  after  connecting 
the  mouse  to  the  Super  NES  control  deck,  mouse_read  uses  speed_- 
change  to  do  this  automatically.  The  paragraph  titled  “Super  NES 
Mouse  Speed  Switching  Routine”  describes  how  to  use  the  subroutine, 
speed_change. 


4-7-2 


SNES  DEVELOPMENT  MANUAL 


When  connected  to  connector  1 
mouse_conO  mouse  connection  info. 


D7  D6  D5  D4  D3  D2  D1  DO 


mouse_spO  mouse  speed  information 


D7  D6  D5  D4  D3  D2  D1  DO 


When  connected  to  connector  2 
mouse_con1  mouse  connection  info.  I 


D7  D6  D5  D4  D3  D2  D1  DO 


mouse_sp1  mouse  speed  information 

D7  D6  D5  D4  D3  D2 

D1 

DO 

—f  T”  \ 

□ 

? 

Significance  of  data 

0 / not  connected 

1 / connected 


D1:0  D0:0  slow 
D1:0  D0:1  normal 
D1:1  D0:0  fast 


mouse_swO  mouse  switch  continuous 


D7  D6  D5  D4  D3  D2  D1  DO 

— i — r"1  ] i 

R 

L 

mouse_sw1  mouse  switch  continuous 


D7  D6  D5  D4  D3  D2  D1  DO 

R 

L 

R:  right  button 
L:  left  button 
O/OFF 
1 / ON 


R:  right  button 
L:  left  button 
O/OFF 
1/ON 


Dir:  Direction  bit 

0 / down 

1 / up 


Dir:  Direction  bit 

0 / right 

1 / left 


Figure  4-7-1  Standard  BIOS,  Output  Register 


mouse_swtO  mouse  switch  trigger 

mouse_swt1  mouse  switch  trigger 

D7  D6  D5  D4  D3  D2  D1  DO 

D7  D6  D5  D4  D3  D2  D1  DO 

r l 

r l 

mouse_yO,  Displacement  in  Y direction 

mouse_y1 , Displacement  in  Y direction 

D7  D6  D5  D4  D3  D2  D1  DO 

D7  D6  D5  D4  D3  D2  D1  DO 

Dir. 

<--Displacement  in  Y direction-; 
1 1 1 1 1 1 

Dir. 

^-Displacement  in  Y direction-:* 
li  ii  ii 

mouse_xO,  Displacement  in  X direction 

mouse_x1 , Displacement  in  X direction 

D7  D6  D5  D4  D3  D2  D1  DO 

D7  D6  D5  D4  D3  D2  D1  DO 

Dir. 

^-Displacement  in  X direction-;. 
1 1 1 1 1 I 

Dir. 

<-Displacement  in  X direction-: 
1 1 1 1 1 1 

4-7-3 


USING  THE  STANDARD  BIOS 


7.3  SUPER  NES  MOUSE  SPEED  SWITCHING  ROUTINE  / 

speed_change  (Screen  cursor,  OBJ  and  BG  move  speed 
switching) 

This  section  describes  the  speed  switching  program,  speed_change,  found  in  the 
“MOUSE.X65”  program  (supplied  on  sample  diskette). 

Connector  1 . Set  the  X register  to  “0” 

Set  the  number  corresponding  to  the  desired  speed  in  the 
mouse_sp_setO  register,  where  slow  = 0,  normal  = 1 and 
fast  = 2. 

Connector  2.  Set  the  X register  to  “1 

Set  the  number  corresponding  to  the  desired  speed  in  the 
mouse_sp_set1  register. 

After  setting  the  X and  mouse_sp_setO  or  mouse_sp_set1  registers,  call  the 
speed_change  subroutine.  The  speed  will  be  switched  to  the  desired  setting  in 
one  step.  (Because  the  mouse  tracking  speed  can  only  be  switched  in  a rotary 
switch  fashion,  the  speed_change  subroutine  is  useful  when  switching  the  speed 
twice;  for  example,  to  switch  from  “normal”  to  “slow”.) 

When  the  mouse  tracking  speed  is  changed,  the  new  speed  data  is  transmitted  by 
the  mouse,  and  mouse_sp0  and  mouse_sp1  data  are  rewritten. 

7.3.1  CAUTION 

Do  not  forget  to  set  the  X and  mouse_sp_setO  or  mouse_sp_set1  regis- 
ters. 

Figure  4-7-2  Examples  of  Speed  Switching  Program  Subroutine  Call 

Example  1 

Idx  #$00  ; Connector  1 

Ida  #$01  ; Switch  to  “normal”  speed 

sta  mouse_sp_set0 

jsr  speed_change 

Example  2 

Idx  #$01  ; Connector  2 

Ida  mouse_sp0  ; Look  at  the  current  speed,  and  increase  the  speed 
inc  a ; to  the  next  highest  setting 

cmp  #$03 

bne  change  ; If  the  current  speed  is  “fast”,  it  changes  to  “slow” 

Ida  #$00 
change 

sta  mouse_sp_set0 
jsr  speed_change 


4-7-4 


SNES  DEVELOPMENT  MANUAL 


7.3.2  USING  THE  PROGRAM 

Mouse_read  automatically  completes  the  above  speed  switching  at  the 
time  the  mouse  is  connected.  (Refer  to  “Programming  Cautions”,  Item  3 
later  in  this  section).  If  mouse_sp_setO  and  mouse_sp_set1  have  been 
cleared,  then  the  mouse  speed  is  “slow”  when  the  mouse  is  connected. 

If  the  mouse  becomes  disconnected  and  reconnected  during  a game  and 
this  program  is  not  being  used,  the  speed  must  be  switched  once. 
Mouse_read  does  this  automatically  when  the  mouse  is  re-connected. 
The  speed  setting  in  that  case  is  the  same  as  immediately  before  the 
mouse  became  disconnected. 

If  mouse_read  is  used,  the  entire  process  is  done  automatically.  No  addi- 
tional steps  need  be  taken.  Mouse_read  also  constantly  monitors  the 
speed  data  (mouse_spO  and  mouse_sp1),  thus  allowing  speed  changes 
to  be  programmed  at  any  time  during  a game. 


4-7-5 


USING  THE  STANDARD  BIOS 

I 1 

7.4  SPEED  SELECTION  AND  CURSOR  MOVEMENT 

7.4.1  Fast  (1  OB) 

The  ratio  of  cursor  displacement  to  mouse  displacement  is  automatically 
adjusted  between  6 levels,  from  1:1  to  6:1 . The  ratio  varies  according  to 
the  speed  the  mouse  is  moved.  When  the  mouse  is  moved  slowly,  the  ra- 
tio is  1 :1  and  when  the  mouse  is  moved  quickly,  the  ratio  increases  to  a 
maximum  6:1 . To  move  the  cursor  a short  distance,  the  mouse  is  moved 
slowly.  To  move  the  cursor  a long  distance,  the  mouse  is  moved  quickly. 
When  the  mouse  is  set  to  “fast”,  the  cursor  moves  a longer  distance  the 
faster  the  mouse  is  moved  so  that  the  distance  the  mouse  must  be 
moved  on  the  table  is  minimized. 

7.4.2  Normal  (01 B) 

The  ratio  of  cursor  displacement  to  mouse  displacement  is  also  automat- 
ically adjusted,  as  with  the  “fast”  setting.  The  ratio,  however,  is  smaller. 

7.4.3  Slow  (00B) 

The  ratio  of  cursor  displacement  to  mouse  displacement  is  1:1.  This  ratio 
is  always  fixed.  For  example,  if  the  cursor  moves  5 cm  when  the  mouse  is 
moved  1 0 cm,  then  the  cursor  will  move  1 0 cm  when  the  mouse  is  moved 
20  cm.  The  distance  the  cursor  moves  is  always  proportionate  to  the  dis- 
tance the  mouse  is  moved  whether  the  mouse  is  moved  quickly  or  slowly. 
When  the  mouse  is  set  to  “slow”,  the  mouse  must  be  moved  a long  dis- 
tance on  the  table  to  move  the  cursor  a long  distance. 

Note:  00B,  01 B,  and  10B  are  the  mouse_spO  and  mouse_sp1  D1  and 
DO  bit  data. 


4-7-6 


SNES  DEVELOPMENT  MANUAL 


7.5  REGISTERS 

The  registers  required  for  these  subroutines  are  as  follows. 


mouse_conO, 

mouse_con1 

Mouse  connection  status  (indicates  the  con- 
nector to  which  the  mouse  is  connected.) 

mouse_yO, 

mouse_y1 

Mouse  Y axis  data  for  connectors  1 (YO)  and 
2 (Y1) 

mouse_xO, 

mouse_x1 

Mouse  X axis  data  for  connectors  1(X0)  and 
2 (XI) 

mouse_swO, 

mouse_sw1 

Actuator  status  for  connectors  1 and  2 (01 H 
= right  actuator,  02H  = left  actuator) 

mouse_swtO, 

mouse_swt1 

Trigger  status  for  connectors  1 and  2. 

mouse_spO, 

mouse_sp1 

Mouse  speed  mode  for  connectors  1 and  2 
(00H  = slow,  01 H = normal,  02H  = fast) 

mouse_sbO, 

mouse_sb1 

Work  register  for  trigger  status 

mouse_sp_setO, 

mouse_sp_set1 

For  speed  changes 

connect_stO, 

connect_st1 

DS1  connection  start  check. 

regOI, 

regOh 

Multi-purpose  work  register 

4-7-7 


USING  THE  STANDARD  BIOS 


**********************************************************  ****************************idcic  it  ********* 
,* 

;*  mouse.x65 

;*  Super  NES  Mouse  System  file 

;*  March  11, 1992 

;*  (c)  1992  Nintendo  of  America 

*************************************************************************************************** 

,************************************************************************************************** 

.************************************************************************************************** 

;*  Mouse  Driver  Routine  (Ver  1 .00) 

.*+*****+**+ ********************************************************* ********** ********* **★*★*★*★** 

*************************************************************************************************** 
db  ‘START  OF  MOUSE  BIOS’  ;do  not  delete 


RAM  Definition 


regO 

regOI 

ds 

i 

; Work  registers 

regOh 

ds 

i 

> 

mouse_con 

mouse_con0 

ds 

i 

; Mouse  connection  port  D0=4016 

mouse_con1 

ds 

i 

; Mouse  connection  port  D0=4017 

mouse_sp_set 

mouse_sp_setO 

ds 

i 

; Mouse  speed  setting  (joyl) 

mouse_sp_set1 

ds 

i 

; Mouse  speed  setting  (joy2) 

mouse_sp 

mouse_sp0 

ds 

i 

; Mouse  speed  (joyl) 

mouse_sp1 

ds 

i 

; Mouse  speed  (joy2) 

mouse_y0 

ds 

i 

; Mouse  Y direction  (joy  1) 

mouse_y1 

ds 

i 

; Mouse  Y direction  (joy  2) 

mouse_x0 

ds 

i 

; Mouse  X direction  (joy  1) 

mouse_x1 

mouse_sw 

ds 

i 

; Mouse  X direction  (joy  2) 

4-7-8 


SNES  DEVELOPMENT  MANUAL 


mouse_swO 

ds 

i 

; Mouse  button  turbo 

mouse_sw1 

ds 

i 

; Mouse  button  turbo 

mouse_swt 

mouse_swtO 

ds 

i 

; Mouse  button  trigger 

mouse_swt1 

ds 

i 

; Mouse  button  trigger 

mouse_sb 

mouse_sfc>0 

ds 

i 

; Previous  switch  status 

j 

mouse_sb1 

ds 

i 

cursol_x 

ds 

i 

;Cursor  X position 

cursoLy 

ds 

i 

;Cursor  Y position 

4-7-9 


USING  THE  STANDARD  BIOS 


*************************************************************************************************** 


mouse  read 


* If  this  routine  is  called  every  frame,  then  the  mouse  status  will  be  set  to  the 
appropriate  registers. 

* INPUT 


"'OUTPUT 


None  (Mouse  key  read  automatically) 
Connection  status  (mouse_con) 
Switch  (mouse_sw0,1) 

Switch  (mouse_swt0,1) 


Mouse  movement  (ball)  value 
(mouse_x) 

(mouse_y) 


D0=1  Mouse  connected  to  Joyl 
D1=1  Mouse  connected  to  Joy2 
D0=left  switch  turbo 
D1=right  switch  turbo 
D0=left  switch  trigger 
D1=right  switch  trigger 


D7=0  Positive  turn,  D7=1  Negative  turn 
D6-D0  X movement  value 
D7=0  Positive  turn,  D7=1  Negative  turn 
D6-D0  X movement  value 


.**********★******★****★*********** ★*★*★***★* ★**★*★★**★★★★★*★*******★********★********★★★★*★★****** 


mouse_read 

php 


sep 

#$30 

Ida 

$4212 

and 

#%00000001 

bne 

_10 

; Automatic  read  ok? 

Idx 

#$01 

; Joy2 

Ida 

$42  la 

jsr 

mouse_data 

Ida 

connect_st1 

beq 

_20 

jsr  speed_change 

stz  connect_st1 


4-7-10 


SNES  DEVELOPMENT  MANUAL 


pip 

rts 

_20 

dex 

Ida  $4218  ; joyl 

jsr  mouse_data 

Ida  connect_stO 

beq  _30 

jsr  speed_change 

stz  connect_stO 

_30 

pip 
rts 

mouse_data 

sta  regOI 

and  #%00001111 

cmp  #$01 

beq  _m10 

stz  mouse_con0,x  ; No  connection. 

stz  mouse_x0,x 
stz  mouse_y0,x 
stz  mouse_sw0,x 
stz  mouse_swtO,x 
stz  mouse_sb0,x 

rts 

_m10 

Ida  mouse_con0,x 
bne  _m20 

Ida  #$01 
sta  mouse_con0,x 
sta  connect_stO,x 
rts 


; When  mouse  is  connected,  speed  will  change. 
; Previous  connection  status 
; (mouse.com  judged  by  lower  1 bit) 

; Connection  check  flag  on 


; (421a  4218  save  to  regO) 
; Is  the  mouse  connected? 


4-7-11 


USING  THE  STANDARD  BIOS 


3 


m20 

Idy 

#16 

; Read  1 6 bit  data. 

m30 

Ida 

$401 6, x 

Isr 

a 

rol 

mouse_x0,x 

rol 

mouse_y0,x 

dey 

bne 

_m30 

stz 

mouse_sw0,x 

rol 

regOI 

rol 

mouse_sw0,x 

rol 

regOI 

rol 

mouse_sw0,x 

; Switch  turbo 

Ida 

mouse_sw0,x 

eor 

mouse_sb0,x 

; Get  switch  trigger 

bne 

_m40 

stz 

mouse_swtO,x 

rts 

m40 

Ida 

mouse_swO,x 

sta 

mouse_swtO,x 

sta 

mouse_sb0,x 

rts 

4-7-12 


SNES  DEVELOPMENT  MANUAL 


;*  Set  speed  to  mouse_sp_set.  Give  mouse  port  the  value  of  x and  call  this  routine. 

;*  If  this  routine  is  called  without  setting  mouse_sp_set,  then  the  previous  speed  will  be 
;*  assigned  to  the  current  speed. 

;*  Normally,  the  mouse  speed  data  will  be  saved  to  mouse_sp. 

;*  If  the  mouse  speed  cannot  be  set,  then  the  error  code  will  be  set  to  mouse_sp. 

;*  INPUT 

;*  X=connection  port  (X:0=joy1  1=joy2) 

;*  MOUSE_SP_SETO=  JOY1  setting  speed 

;*  MOUSE_SP_SET  1 = JOY2  setting  speed 

;*  OUTPUT 

;*  MOUSE_SPO  = Joyl  Mouse  speed 

i*  (0=slow,  1=medium,  2=fast,  $80=error  code) 

;*  MOUSE_SP1  = Joy2  Mouse  speed 

>'*  (0=slow,  1=medium,  2=fast,  $80=error  code) 

speed_change 

php 

sep  #$30 


Ida  mouse_con,x 
beq  _s25 


Ida 

#$10 

sta 

regOh 

s10 

Ida 

#$01 

sta 

$4016 

Ida 

$401 6, x 

; Speed  change  (1  step) 

stz 

$4016 

Ida 

#$01 

; Read  speed  data. 

sta 

$4016 

; Shift  register  clear. 

Ida 

#$00 

sta 

$4016 

4-7-13 


USING  THE  STANDARD  BIOS 


sta  mouse_spO,x  ; Speed  register  clear. 


Idy 

#10  ; Shift  register  read  has  no  meaning 

_s20 

Ida 

$401 6, x 

dey 

bne 

_s20 

Ida 

$401 6, x ; Read  speed 

Isr 

a 

rol 

mouse_sp0,x 

Ida 

$401 6, x 

Isr 

a 

rol 

mouse_sp0,x 

Ida 

mouse_sp0,x 

cmp 

mouse_sp_setO,x  ;Set  speed  or  not? 

beq 

_s30 

dec 

regOh  ; For  error  check 

bne 

_s10 

_s25 

Ida 

#$80  ; Speed  change  error. 

sta 

mouse_sp0,x 

_s30 

pip 

rts 

db 

‘NINTENDO  SNES  MOUSE  BIOS  Verl.00’ 

db 

;lf  user  modifies  program,  then  change  to 
.■‘MODIFIED  FROM  SNES  MOUSE  BIOS  Verl.00’ 
‘END  OF  MOUSE  BIOS’ 

;do  not  delete. 


;do  not  delete. 


4-7-14 


SNES  DEVELOPMENT  MANUAL 

m 


Chapter  8 Programming  Cautions 

Programs  should  be  written  so  that  controller  input  can  be  used  from  the  time  the  power 
is  turned  on  until  the  menu  screen  appears.  (From  the  demo  screen  until  the  actual  start 
point). 

8.1  CAUTION  #1 

The  explanation  given  in  Chapter  6 is  based  on  data  read  by  the  Super  NES  con- 
trol deck.  Note  that  the  data  sent  by  the  Super  NES  Mouse  is  in  negative  logic, 
and  is  inverted  inside  the  Super  NES  control  deck.  (There  is  a bit  inversion  buffer 
after  the  Super  NES  controller  connector.) 

8.2  CAUTION  #2 

When  not  using  the  standard  BIOS,  constantly  check  the  mouse  connection  code, 
not  just  at  start  up.  Take  precautions  to  prevent  problems  when  changing  from  a 
mouse  to  another  input  device  during  a game.  This  will  protect  the  software  from 
data  input  through  other  input  devices.  When  using  the  standard  BIOS,  the  mouse 
connection  code  is  automatically  checked  constantly.  If  the  mouse  is  replaced  by 
another  input  device,  data  will  not  be  received  at  that  time. 

This  holds  true  for  other  input  devices  as  well.  If,  when  using  a program  requiring 
the  standard  controller,  the  programmer  constantly  checks  that  the  connection 
code  is  “0000B”,  no  errors  will  occur  even  if  another  input  device  is  connected. 

8.3  CAUTION  #3 

As  mentioned  earlier,  the  mouse  speed  and  speed  data  are  initially  undetermined. 
When  not  using  the  standard  BIOS,  always  switch  the  speed  of  the  mouse  once 
after  connecting  it.  Otherwise,  the  speed  data  (SD10,SD1 1)  and  actual  speed  set- 
ting of  the  mouse  may  be  different.  (Although  they  might  mismatch  initially,  after 
the  speed  is  switched  automatically  or  manually  once,  the  speed  data  and  speed 
setting  are  always  in  agreement.)  The  speed  switching  program  should  be  execut- 
ed before  any  data  is  transmitted  by  the  mouse.  (If  the  mouse  becomes  discon- 
nected during  a game,  always  run  the  speed  switching  program  once  immediately 
after  re-connecting  the  mouse.)  When  using  the  standard  BIOS,  the  speed  switch- 
ing program  is  run  automatically  whenever  the  mouse  is  connected,  and  no  addi- 
tional steps  need  be  taken. 

8.4  CAUTION  #4 

The  standard  BIOS,  mouse_read,  can  be  included  in  the  program  without  modifi- 
cation and  may  be  treated  like  a controller  read  routine.  Call  mouse_read  as  a 
subroutine. 

Note  that  the  standard  BIOS,  mouse_read,  is  designed  for  mouse-only  software. 
Take  caution  when  using  a standard  controller  and  mouse  at  the  same  time. 


4-8-1 


PROGRAMMING  CAUTIONS 
1 


8.5  CAUTION  #5 

The  standard  BIOS  is  written  entirely  in  the  eight-bit  mode.  Therefore,  the  com- 
mands php,  pip  and  sep  are  executed  after  it  is  called  and  before  returning  to  the 
main  program.  They  may  be  removed  when  the  eight-bit  and  sixteen  bit  modes 
are  carefully  managed. 

8.6  CAUTION  #6 

Refer  to  “Mouse  Specifications”,  for  mouse  characteristics  such  as  tracking 
speed  = 250  mm/sec.,  when  writing  any  software. 

Note  about  the  enclosed  software: 

The  disk  contains  sample  software  which  uses  the  standard  BIOS 
(MOUSE.COM).  MOUSE.COM  displays  data  on  the  screen  transmitted  by 
the  mouse  and  stored  in  each  register.  The  number  strings  shown  at  the 
bottom  represent  32-bit  mouse  data  strings.  The  cursor  will  follow  the 
movement  of  the  mouse  horizontally  or  vertically  on  the  screen.  Move  the 
cursor  to  the  heart  symbol  and  push  the  left  mouse  actuator  to  change  the 
cursor  tracking  speed. 


4-8-2 


SNES  DEVELOPMENT  MANUAL 


Chapter  9 MultiPlayer  5 Specifications 

9.1  INTRODUCTION  TO  MULTIPLAYER  5 

The  Super  NES  MultiPlayer  5 is  a standard  term  referring  to  any  controller  or 
adapter  used  to  accommodate  3 - 5 players.  The  adapter  is  connected  to  the  Su- 
per NES  control  deck  and  allows  up  to  five  people  to  play  at  one  time.  The  adapter 
references  all  controller  data  simultaneously,  and  does  not  give  an  unfair  advan- 
tage to  any  one  controller  during  a game.  The  adapter’s  controller  ports  are  identi- 
cal to  the  Super  NES  controller  port.  Therefore,  many  devices  which  can  be 
connected  to  the  controller  port  may  also  be  connected  to  MultiPlayer  5. 

The  adapter  should  be  equipped  with  a switch  which  is  user  selectable  between  a 
2 player  (2P)  mode  and  a 5 player  (5P)  mode  (for  three  to  five  players).  When  the 
adapter  is  in  the  2P  mode,  the  software  treats  MultiPlayer  5 controller  port  #2  as 
an  extension  of  controller  port  #2  of  the  Super  NES  control  deck.  A BIOS  is  pro- 
vided on  3.5”  diskette  to  read  the  multiple  controller  data  input  to  MultiPlayer  5. 

This  chapter  describes  how  data  is  read  from  peripheral  devices  connected  to 
MultiPlayer  5.  For  reliable  operation,  the  supplied  BIOS  should  always  be  used. 
Refer  to  the  following  chapter  for  details  on  the  supplied  BIOS. 

There  are  no  standard  entries  that  are  required  in  manuals  provided  with  games 
that  use  MultiPlayer  5.  However,  the  manual  should  explain  how  to  connect  and 
operate  MultiPlayer  5 when  playing  a multi-player  game.  A MultiPlayer  5 logo  is 
available  for  use  on  packaging  and  advertising.  The  logo  artwork  may  be  obtained 
through  the  NOA  Licensing  Department. 


4-9-1 


MULTIPLAYER  5 SPECIFICATIONS 


3 


9.2  HARDWARE  CONNECTIONS 

The  figure  below  demonstrates  a typical  hardware  arrangement  using  the  Super 
NES  control  deck  and  a MultiPlayer  5 device. 


Figure  4-9-1  MultiPlayer  5 Device  Hardware  Connections 

The  MultiPlayer  5 device  is  connected  to  the  Super  NES  control  deck  through 
controller  port  #2.  The  MultiPlayer  5 device  should  not  be  used  with  controller  port 
#1  of  the  control  deck.  This  should  be  carefully  explained  and  addressed  in  all 
software  and  related  manuals. 


4-9-2 


SNES  DEVELOPMENT  MANUAL 


9.3  MODES  OF  OPERATION 

Each  MultiPlayer  5 device  is  equipped  with  a switch  for  changing  between  the  2P 
and  5P  modes.  The  function  of  this  switch  is  demonstrated  in  the  table  below. 


PIN 

# 

SYMBOL 

2 PLAYER  MODE 

5 PLAYER  MODE  | 

EXPANSION 

CONNECTORS 

© 

EXPANSION 

CONNECTORS 

USD 

© 

© 

1 

+5V 

X 

NC 

X 

X 

X 

X 

2 

CUP 

X 

X 

X 

X 

X 

3 

OUTO 

X 

X 

X 

D 

DO 

X 

X 

X 

X 

X 

5 

D1 

X 

NC 

6 

PP 

X 

D 

GND 

X 

X 

X 

X 

Adapter 

Connection 

Status 

Detection 

NOT 

AVAILABLE 

AVAILABLE 

X = Connected 
NC  = Not  Connected 


Table  4-9-1  MultiPlayer  5 Switch  Function 

9.3.1  TWO  PLAYER  MODE 

In  the  2P  mode,  only  controller  port  #2  of  the  MultiPlayer  5 device  can  be 
used.  In  this  mode,  MultiPlayer  5 controller  port  #2  performs  the  same 
functions  as  controller  port  #2  of  the  Super  NES  control  deck. 

9.3.2  FIVE  PLAYER  MODE 

In  the  5P  mode  all  connectors  of  the  MultiPlayer  5 device  can  be  used.  This 
permits  up  to  5 players  to  play  a game  at  one  time  (counting  controller  port 
#1  of  the  Super  NES  control  deck). 


4-9-3 


MULTIPLAYER  5 SPECIFICATIONS 


9.4  PROGRAMMING  CAUTIONS  FOR  COMPATIBLE  SOFTWARE 

9.4.1  CAUTION  #1 

Games  should  be  programmed  to  use  the  MultiPlayer  5 device  only  when 
the  device  is  connected  to  controller  port  #2  of  the  Super  NES  control  deck. 
Games  should  display  the  following  warning  message  and  the  program 
should  halt,  when  the  MultiPlayer  5 device  is  connected  to  controller  port 
#1  of  the  Super  NES  control  deck  and  the  MultiPlayer  5 is  in  the  5P  mode. 

‘The  Super  NES  MultiPlayer  5 Adapter  must  be  connected  to 
Controller  Socket  #2.” 

9.4.2  CAUTION  #2 

Games  should  be  programmed  so  that  game  play  can  be  continued  if  the 
MultiPlayer  5 or  one  of  the  devices  connected  to  it  becomes  disconnected. 

9.4.3  CAUTION  #3 

The  Super  NES  Super  Scope  can  not  be  used  with  the  MultiPlayer  5.  The 
following  error  message  should  be  displayed  and  the  program  should  halt  if 
the  Super  NES  Super  Scope  is  connected  to  the  MultiPlayer  5 using  the  5P 
mode. 

‘The  Super  NES  MultiPlayer  5 Adapter  is  not  designed  for  use  with 
the  Super  NES  Super  Scope.” 

9.4.4  CAUTION  #4 

The  Super  NES  Mouse  can  not  be  used  with  the  MultiPlayer  5.  The  follow- 
ing error  message  should  be  displayed  and  the  program  should  halt  if  the 
Super  NES  Mouse  is  connected  to  the  MultiPlayer  5 using  the  5P  mode. 

“The  Super  NES  MultiPlayer  5 Adapter  is  not  designed  for  use  with 
the  Super  NES  Mouse.” 

9.4.5  CAUTION  #5 

Use  the  supplied  BIOS  whenever  possible  to  ensure  hardware  and  soft- 
ware compatibility.  If  a custom  BIOS  is  used,  read  connector  #2  and  #3, 
followed  by  connector  #4  and  #5;  because  PP7  changes  from  a logic  0 to  1 
slowly.  Refer  to  “Reading  Data”  on  the  following  page. 

9.4.6  CAUTION  #6 

Programs  can  not  detect  whether  the  MultiPlayer  5 is  connected  when  the 
MultiPlayer  5 is  in  the  2P  mode. 

9.4.7  CAUTION  #7 

Software  should  be  evaluated  using  the  MultiPlayer  Development  Assem- 
bly prior  to  submission.  This  assembly  may  be  obtained  through  the  NOA 
Parts  Department.  Refer  to  “Super  NES  Parts  List”  in  the  “Supplemental  In- 
formation” section  of  this  manual. 


4-9-4 


SNES  DEVELOPMENT  MANUAL 


] 


9.4.8  CAUTION  #8 

When  using  the  MultiPlayer  5 with  the  supplied  BIOS,  use  caution  in  the  or- 
der of  the  BIOS  call  (refer  to  “Supplied  BIOS  Execution”  in  the  following 
chapter). 


9.5  READING  DATA 


9.5.1  STANDARD  CONTROLLER  CONNECTED  (5P  MODE) 

When  the  MultiPlayer  5 is  in  the  5P  mode,  data  from  the  four  connected 
controllers  is  read  in  two  groups;  controllers  2 and  3,  and  controllers  4 and 
5.  Data  from  each  of  these  groups  is  read  in  parallel  starting  from  <401 7H> 
DO  and  D1 . The  bit  at  PP7  (<4201  H>  D7)  is  used  to  switch  between  the 
two  groups.  The  normal  condition  of  PP7  is  1 . If  changed  to  0,  it  should  be 
set  back  to  1 immediately. 

PP7  = 1 Read  controller  2 data  from  <401 7H>  DO 

Read  controller  3 data  from  <401 7H>  D1 
PP7  = 0 Read  controller  4 data  from  <401 7H>  DO 

Read  controller  5 data  from  <401 7H>  D1 


9.5.1. 1 READ  TIMING 

Read  timing  is  demonstrated  in  the  figure  below. 


OUTOWR  “1” 
( write  to  \ «n» 
V4016HD0/ 


PP7  WR 
/ write  to  \ 
'4201 H D7/ 


“0” 


Note 


401 7D0  RD 
(read) 


401 7D1  RD 
(read) 


Controller  2 Data 


Controller  3 Data 


L 


1 7 Bits 


Controller  4 Data 


Controller  5 Data 


17  Bits 


Figure  4-9-2  MultiPlayer  5 Read  Timing  Chart,  5P  Mode 

Note:  The  normal  state  outputs  “1”  to  PP7.  After  reading  Controller  Data  4 
and  5,  the  state  should  be  returned  to  “1”. 


4-9-5 


MULTIPLAYER  5 SPECIFICATIONS 


E 


9.5. 1.2  DATA  FORMAT 

The  following  table  lists  the  MultiPlayer  5 data  format  when  con- 
trollers are  connected  to  connectors  2 through  5.  An  asterisk  (*)  is 
used  to  show  that  the  indicated  data  is  0 when  that  controller  is  not 
connected. 


1 

Output  “1”  in  advance  to  PP7  (<420 1H>  D7) 

Change  OUTO  (<4016H>  DO)  from  “0”  to  “1”  to  “0” 

2 

Content  of  <4017H> 

D7-D2 

D1 

DO 

<4017H>  1st  read 

undefined 

Controller  3 B button 

Controller  2 B button 

<4017H>  2nd  read 

undefined 

Controller  3 Y button 

Controller  2 Y button 

<4017H>  3rd  read 

undefined 

Controller  3 select  button 

Controller  2 select  button 

* 

* 

<4017H>  15th  read 

undefined 

0 

0 

<4017H>  16th  read 

undefined 

0 

0 

<4017H>  17th  read 

undefined 

1 (*) 

1 (*) 

E 

Change  the  output  going  to  PP7  (<420 1H>  D7)  from  “1”  to  “0” 

4 

<4017H>  18th  read 

undefined 

Controller  5 B button 

Controller  4 B button 

<4017H>  19th  read 

undefined 

Controller  5 Y button 

Controller  4 Y button 

<4017H>  20th  read 

undefined 

Controller  5 select  button 

Controller  4 select  button 

<4017H>  32nd  read 

undefined 

0 

0 

<4017H>  33rd  read 

undefined 

0 

0 

<4017H>  34th  read 

undefined 

1 (*) 

1 (*) 

5 

After  controller  data  has  been  read,  change  the  output  to  PP7  (<420 1H>  D7)  from  “0”  to  “1” 

Table  4-9-2  MultiPlayer  5 Data  Format 


4-9-6 


SNES  DEVELOPMENT  MANUAL 


9.5.2  PERIPHERAL  DEVICE  CONNECTIONS 

The  MultiPlayer  5 connectors  are  identical  in  shape  to  the  controller  ports 
of  the  Super  NES  control  deck.  Peripheral  devices  other  than  controllers 
can  be  connected.  However,  some  types  of  devices  are  not  compatible 
with  the  MultiPlayer  5. 

9.5.2. 1 INCOMPATIBLE  DEVICES 

The  following  devices  cannot  be  used  with  MultiPlayer  5 except  for 
those  devices  marked  with  an  asterisk  (*),  which  can  be  used  only 
when  MultiPlayer  5 is  in  the  2P  mode.  If  any  of  the  devices  marked 
with  an  asterisk  (*)  are  used  when  MultiPlayer  5 is  in  the  5P  mode, 
they  either  will  not  operate  or  may  not  operate  normally. 

1*.  Any  device  which  uses  <401 6H>  D1  or  <401 7H>  D1  for  its 
data  read. 

2*.  Any  device  which  uses  <4201  H>  or  <421 3H>. 

3.  Any  device  with  an  electrical  consumption  of  17mA  or  more 
per  unit. 

4*.  Any  device  which  detects  a CUP  signal  while  OUT  0 is  “1”. 

5.  Any  device  which  transmits  data  while  OUT  0 is  “1”. 

6.  Any  adapter  used  to  connect  other  devices. 

Examples  of  devices  which  can  not  be  used  with  MultiPlayer  5: 

Super  NES  mouse  (for  reason  3). 

Super  NES  Super  Scope  (for  reason  2) 

MultiPlayer  5 (for  reason  6) 


4-9-7 


MULTIPLAYER  5 SPECIFICATIONS 


3 


9. 5. 2.2  DISSIMILAR  DEVICES 

Dissimilar  devices  can  be  used  simultaneously  as  long  as  any  one 
device  is  not  contained  in  the  previous  incompatibility  list.  Differ- 
ences in  data  composition  and  length  between  the  various  devices 
will  not  result  in  any  problems.  An  example  of  data  read  timing  for 
dissimilar  devices  is  provided  below. 


<401 7H>  DO  RD 

Device  A Data 

I 

Device  C Data 

<401 7H>  D1  RD 

Device  B Data 

Device  D Data 

PP7WR  “1” 1 

(write)  «o”  

I I I I 

DO  (No  Data)  D1  (No  Data) 


Device  Physical  Connections: 

Device  A = Connector  2 Device  C = Connector  4 

Device  B = Connector  3 Device  D = Connector  5 


Figure  4-9-3  Data  Read  Timing  for  Dissimilar  Devices 

When  the  data  length  between  two  devices  that  are  read  in  parallel 
is  different,  the  excess  part  (shaded)  is  read  in  with  no  data.  The 
above  setting  is  only  one  example  and  all  four  devices  do  not  need 
to  be  connected. 


4-9-8 


SNES  DEVELOPMENT  MANUAL 


9.6  IDENTIFYING  DEVICES  CONNECTED  TO  MULTIPLAYER  5 

9.6.1  SIGNATURES 

Nintendo  has  a standard  for  each  “signature”  which  allows  software  to  de- 
tect the  type  of  device  connected.  Software  uses  the  signature  to  select  the 
appropriate  operations  mode  and  menu  for  the  connected  device  and  to  in- 
hibit data  from  being  read  from  incompatible  devices. 

The  peripheral  device  signature  is  contained  in  bits  13  ~ 16  of  the  OUT  0 
latch  pulse  (<401 6H>  DO  WR)  when  read  serially  from  <401 6H>  DO 
(<401 7H>  DO).  Refer  to  the  chapter  “CPU  Registers”  in  book  1 for  more  in- 
formation concerning  these  registers. 

The  signature  for  a standard  controller  is  0000.  Refer  to  device  program- 
ming documentation  for  the  signature  of  other  devices. 

9.6.2  MULTIPLAYER  5 SIGNATURE 

MultiPlayer  5 simply  passes  on  the  signature  codes  for  devices  connected 
to  controller  ports  2 ~ 5 and  does  not  have  a signature  code  of  its  own. 
However,  the  following  procedure  will  verify  that  MultiPlayer  5 is  connect- 
ed. When  performing  this  procedure,  it  does  not  matter  whether  or  not  a 
device  is  connected  to  MultiPlayer  5 controller  ports  2 ~ 5. 

1 . Output  “1”  to  register  <401 6H>  DO. 

2.  Read  register  <401 7H>  D1  eight  times  and  verify  that  it  is 
“11111111  (FFH)”. 

3.  Output  “0”  to  register  <401 6H>  DO. 

4.  Read  register  <401 7H>  D1  eight  times  and  verify  that  it  is  not 
“11111111  (FFH)”. 

If  items  1 ~4  are  all  satisfied,  MultiPlayer  5 is  connected  to  controller  port  #2 
of  the  Super  NES  control  deck  and  the  2P/5P  mode  switch  is  in  the  5P 
mode.  The  Super  NES  cannot  detect  if  MultiPlayer  5 is  connected  when 
MultiPlayer  5 is  in  the  2P  mode.  To  verify  that  MultiPlayer  5 is  connected  to 
controller  port  #1  of  the  Super  NES  control  deck,  complete  the  same  test 
procedure  using  register  <401 6H>  D1 . 


4-9-9 


SUPER  NES  MultiPlayer  5 - SCHEMATIC  DIAGRAM  (Rev  2.3)  May  1, 1992 


MULTIPLAYER  5 SPECIFICATIONS 


9.7  MULTIPLAYER  5 SCHEMATIC  DIAGRAM 


4-9-10 


SNES  DEVELOPMENT  MANUAL 


3 


9.8  READING  CONTROLLER  DATA 

In  order  to  understand  the  process  by  which  MultiPlayer  5 data  is  read,  the  user 
must  first  understand  the  method  by  which  normal  controller  data  is  read.  This 
method  is  described  in  the  following  paragraphs. 

9.8.1  CONTROLLER  DATA  STORAGE 

Controller  data  is  stored  at  <421 8H>  ~ <421  BH>  in  the  Super  NES  CPU. 
This  data,  originally  transmitted  in  serial  form  by  the  controller,  has  been 
automatically  expanded  by  the  CPU  internal  hardware.  The  controller  auto- 
matic read  function  operates  during  the  PPU  V-blank  period.  Therefore,  the 
controller  status  for  the  previous  V-blank  is  stored  at  <421 8H>  - <421  BH>. 
Refer  to  “Joy  Controller”  in  the  “Software”  section  of  this  manual. 

Note:  Super  NES  CPU  registers  <421  CH>  ~ <421  FH>  are  provided  for 
expansion  of  controller  data  storage.  However,  no  data  is  stored  in 
this  area  by  MultiPlayer  5 and  data  held  by  these  registers  is  ig- 
nored. 

In  addition  to  reading  controller  and  other  external  device  data  automatical- 
ly, the  Super  NES  can  read  data  serially  using  software.  Data  can  also  be 
read  using  a combination  of  the  automatic  read  function  (up  to16  bits)  and 
software  (from  the  17th  bit). 


4-9-11 


MULTIPLAYER  5 SPECIFICATIONS 


9.8.2  CONTROLLER  I/O  PORTS 

There  are  four  Super  NES  I/O  ports  used  for  reading  controller  (or  periph- 
eral device)  data  in  serial  format. 

9.8.2. 1 REGISTER  <4016H>  (DO,  D1  READ) 

Bits  DO  and  D1  of  this  register  read  peripheral  devices  connected 
to  controller  port  #1  of  the  Super  NES  control  deck. 

9. 8.2. 2 REGISTER  <401 7H>  (DO,  D1  READ) 

Bits  DO  and  D1  of  this  register  read  peripheral  devices  connected 
to  controller  port  #2  of  the  Super  NES  control  deck. 

9.8. 2. 3 REGISTER  <4016H>  (DO  WRITE) 

This  is  the  controller  shift  registers’  parallel  load  control. 

9. 8. 2.4  REGISTER  <4201  H>  (D6,  D7  WRITE) 

Bit  D6  enables  serial  output  for  controller  port  #1  and  bit  D7  en- 
ables serial  output  for  controller  port  #2. 

9. 8. 2. 5 REGISTER  <421 3h>  (D6,  D7  READ) 

Bits  D6  and  D7  read  inputs  from  the  parallel  I/O  ports. 

Only  specially  designed  devices  allow  data  input  from  registers  <401 6H> 
bit  D1  and  <401 7H>  bit  D1 . When  a controller  is  used  by  itself  (directly  con- 
nected to  the  Super  NES),  this  data  is  undefined. 

The  following  figure  demonstrates  a valid  controller  data  string.  The  shad- 
ed area  indicates  data  that  is  automatically  read. 


' :''V 

SOI 

0SD2^ 

SD3 

SD4 

SD5 

Etna 

B 

Button 

Y 

Button 

SL 

ST 

UP 

DN 

LEFT 

RIGHT 

Bl 

'm 

R 

Button 

o 

Signature 

0 l o 

3 

—| 

SD16 

SD17 

SD18 

SD19 

SD20 

SD21 

SD22 

SD23 

1 

NOT  USED 

1 1 1 1 1 1 

Figure  4-9-4  Valid  Controller  Data  String 


4-9-12 


SNES  DEVELOPMENT  MANUAL 


The  data  for  each  button  is  transmitted  as  “1”  when  pressed  and  “0”  when 
not  pressed.  The  SD1 6 data  bit  is  used  to  verify  a controller  is  connected.  A 
controller  is  connected  to  the  port  when  the  signature  code  is  0000  and 
SD16  = 1 . When  the  controller  is  not  connected,  the  signature  code  is  0000 
and  SD16  = 0. 


4-9-13 


MULTIPLAYER  5 SUPPLIED  BIOS 


Chapter  10  MultiPlayer  5 Supplied  BIOS 

Super  NES  hardware  and  any  MultiPlayer  5 program  which  does  not  use  the  supplied 
BIOS  may  not  be  fully  compatible.  (When  any  minor  hardware  changes  are  made  in  the 
future,  maintaining  the  compatibility  at  the  BIOS  level  will  have  the  first  priority.) 

The  enclosed  diskette  includes  the  following  two  files,  which  compose  the  BIOS  pro- 
gram. 

• M_CHECK.X65,  Version  X.XX 

• MULTI5.X65,  Version  X.XX 

10.1  FILE  DESCRIPTION 

The  file  “M_CHECK.X65”  determines  whether  a MultiPlayer  5 device  is  connected 
to  the  Super  NES.  The  file  “MULTI5.X65”  reads  controller  data  for  5 players.  The 
diskette  contains  the  following  8 files.  These  files  were  written  using  the  Super 
NES  Emulator  development  system. 

10.1.1  BIOS  FILES 

• MULTI5.  X65 

• M_CHECK.  X65 

10.1.2  SAMPLE  PROGRAM  FILES 

• TEST.  X65 

• I NIT.  X65 

• FONT.  X65 

• MAKE.  BAT 

• TEST.  ISX 

• TEST.COM 

10.2  SAMPLE  PROGRAM  EXECUTION 

The  enclosed  disk  also  contains  a sample  program  for  checking  MultiPlayer  5 op- 
erations. Using  the  MAKE  file  on  the  enclosed  disk,  run  the  program  using  the  Su- 
per NES  Emulator  development  tool  or  the  EPROM  evaluation  board  (1  Mbit  or 
larger  capacity). 

10.2.1  OPERATION  PARAMETERS 

Assign  the  following  parameters  when  running  the  sample  program. 

Memory  map  mode:  20  mode 

Memory  bank  to  be  used:  Bank  00,  80H 

Use  the  high  speed  mode:  (3.58  MHz) 


4-10-1 


SNES  DEVELOPMENT  MANUAL 


10.2.2  SAMPLE  PROGRAM  UTILIZATION 

When  power  is  applied,  the  program  displays  the  button  engagement  sta- 
tus of  the  connected  controller(s).  The  program  displays  a different  num- 
ber of  controllers  depending  on  whether  the  MultiPlayer  5 is  in  the  5P 
mode  or  the  2P  mode.  Button  names  are  not  displayed  when  a controller 
is  not  connected.  An  error  message  is  displayed  when  the  adapter  is  con- 
nected to  controller  port  #1  of  the  Super  NES  control  deck. 

The  program  proceeds  through  the  following  display  format  when  the  Su- 
per NES  reset  button  is  pressed. 


Figure  4-10-1  Sample  Program  Display  Format 

10.3  SUPPLIED  BIOS  EXECUTION 

The  supplied  BIOS  program  assumes  it  is  running  in  synchronization  with  the  Su- 
per NES  PPU’s  NMI  interrupt.  The  program  uses  the  Super  NES  CPU  controller 
data  automatic  read  function,  so  the  automatic  read  function  must  be  enabled 
when  the  BIOS  is  called  (<4200H>  D0=1). 

The  data  for  5 controllers  is  read  when  the  BIOS  is  called  with  the  automatic  read 
function  enabled.  Since  the  supplied  BIOS  uses  the  automatic  read  function,  the 
BIOS  can  not  be  called  more  than  once  per  frame  (the  period  from  one  automatic 
read  to  the  next  automatic  read). 


4-10-2 


MULTIPLAYER  5 SUPPLIED  BIOS 


In  this  BIOS,  the  OUTO  signal  is  controlled  by  the  Controller  Automatic  Read 
function.  The  user  must  ensure  that  the  BIOS  is  called  in  the  proper  order.  After 
the  Super  NES  CPU  Automatic  Read  period  (215  ps  from  the  start  of  NMI),  call 
“MULTI5.ASM  (X65)”  followed  by  ““M_CHECK.ASM  (X65)”.  The  BIOS  must  be 
called  in  this  order  for  proper  operation. 

10.4  SUPPLIED  BIOS  OUTPUT  REGISTER 

M_CHECK.X65 


D7  D6  D5  D4  D3  D2  D1  DO 


status  / / / 

(8-bit)  / / / 

yyy 

A 

k ik  Super  N 

Conned 
Not  com 

Super  N 

ES  Controller  Port  2 MultiPlayer  5 
ted  = 1 
nected  = 0 

IES  Controller  Portl  MultiPlayer  5 

Connected  = 1 
Not  connected  = 0 


MULTI5.X65 


con5 

(16-bit) 


D15 

D14 

D13 

D12 

Dll 

DIO 

D9 

D8 

B 

Y 

SE 

ST 

UP 

DN 

LT 

RT 

D7 

D6 

D5 

D4 

D3 

D2 

D1 

DO 

A 

X 

L 

R 

0 

0 

0 

0 

Controller  5 Button  Information 


The  same  format  is  used  for  con4~con1  (16  bits  each), 
con  4 = Controller  4 
con  3 = Controller  3 
con  2 = Controller  2 

con  1 = Controller  1 (Super  NES  controller  port  #1) 


sgn5 

(8-bit) 


D7  D6  D5  D4  D3  D2  D1  DO 


DO  is  xxxOOOOO  when  no  device  is  connected  to  the  Super  NES  controller  port.  DO 
is  xxxOOOOl  when  a controller  is  connected.  DO  is  undefined  for  all  other  devices. 


4-10-3 


SNES  DEVELOPMENT  MANUAL 


The  same  format  is  used  for  sgn4~sgn1(8  bits  each), 
sgn  4:  Connector  4 
sgn  3:  Connector  3 
sgn  2:  Connector  2 

sgn  1 : Connector  1 (Super  NES  controller  port  #1) 

10.5  SUPPLIED  BIOS  CAUTIONS 

10.5.1  CAUTION  #1 

MULTI5.X65  reads  data  under  the  assumption  that  MultiPlayer  5 is  in  the 
5P  mode  with  all  4 controllers  connected  and  that  a controller  is  connect- 
er to  controller  port  #1  of  the  Super  NES  control  deck.  Therefore,  if  Multi- 
Player  5 is  not  connected  or  a device  other  than  a controller  is  connected, 
the  contents  of  coni  ~5  are  invalid.  Refer  to  status  obtained  by 
M_CHECK.X65  and  data  in  sgnl  -5  to  check  the  status  of  device  connec- 
tions. 

10.5.2  CAUTION  #2 

Since  the  supplied  BIOS  uses  the  automatic  read  function,  the  BIOS  can 
not  be  called  more  than  once  per  frame  (the  period  from  one  automatic 
read  to  the  next  automatic  read).  Do  not  overlap  the  execution  of  the 
BIOS  with  the  automatic  read  execution  period  (about  215  |is  from  the 
start  of  the  NMI).  Refer  to  the  chapter  “Joy  Controller”  under  “Software”  in 
this  manual. 

10.5.3  CAUTION  #3 

Nintendo  does  not  assume  responsibility  for  any  problems  which  arise 
from  using  all  or  part  of  this  BIOS.  Developers  should  use  the  BIOS  only 
after  fully  understanding  its  operations  and  usage. 

10.5.4  CAUTION  #4 

Change  the  BIOS  end  code,  at  the  end  of  the  BIOS,  when  partial  chang- 
es are  made  to  the  BIOS.  This  is  demonstrated  below. 

• M_CHECK.X65 

“NINTENDO  SHVC  MULTI5  CONNECT  CHECK  Ver  X.XX” 
^“MODIFIED  FROM  SHVC  MULTI5  CONNECT  CHECK  Ver  X.XX” 

• MULTI5.X65 

“NINTENDO  SHVC  MULTI5  BIOS  Ver  X.XX” 

=»  “MODIFIED  FROM  SHVC  MULTI5  BIOS  Ver  X.XX” 


4-10-4 


MULTIPLAYER  5 SUPPLIED  BIOS 


10.5.5  CAUTION  #5 

When  consecutively  calling  “MULTI5.ASM  (X65)”  AND  “M_CHECK.ASM 
(X65)”,  the  user  must  call  “MULTI5.ASM  (X65)”  first  to  ensure  the  expect- 
ed results. 


4-10-5 


10.6  MULTIPLAYER  5 SUPPLIED  BIOS  PROGRAM  LISTINGS 

The  following  are  program  listings  contained  on  the  MultiPlayer  5 Supplied  BIOS 
diskette.  These  programs  are  in  the  I.S.  assembler  format. 

[M_CHECK.X65] 

ON816 
PUBALL 
ASSUME  0,0 
MEM  16  macro 
ON16A 
endm 

MEM8  macro 

OFF16A 
endm 

IDX16  macro 

ON16I 
endm 

IDX8  macro 

OFF16I 
endm 

,************************************************************************************ 

; MultiPlayer  connection  check  routine  ver  x.xx 

; Date 

; © 199x  Nintendo 

. ★★★**★****★*★★*★***★★*************************★★★★★*★★*★★ ***************** ★***★★***★ 
.*****★**★***★*★★**★*★★*** ★*★★*★***** ************************** ********* ************* 

BANK80  GROUP  080H 

; MultiPlayer  connection  check  BIOS  start  code 

; Please  do  not  delete  this  code 

DB  ‘START  OF  MULTI5  CONNECT  CHECK’ 


; RAM  define  table 

BANKEQU  GROUP  0 

EXTERN  status 

EXTERN  reg0l,reg0h,reg1l,reg1h 

c_ad1  EQU  401 6H 

c_ad2  EQU  401 7H 


4-10-6 


MULTIPLAYER  5 SUPPLIED  BIOS 


BANK80  GROUP  080H 

,************************************************************************************ 

; MultiPlayer  connection  check  ver  x.xx 

.******★*★**★******★****★*★*********★****★*★**********★****************************★* 

; (Caution) 

; Contents  of  register  A,  B,  X,  Y will  be  destroyed  after  this  routine. 

check_mpa 

PHP 

IDX8 

MEM8 

SEP  #30  H 

STZ  .status 

;<automatic  controller  read  enabled?> 

_c00 

LDA  421 2H 

AND  #01 H 

BNE  _c00 

;<determine  if  MPA  is  connected  or  not?> 

STZ  c_ad1  ;output  “0”  to  outO 

LDA  #01 H 

STA  c_ad1  ; output  “1”  to  outO 

LDX  #08H 

_c10 

LDA  c_ad1 

LSR  A 

LSR  A 

ROL  .regOh  ;read  dl  of  401 6h  and  store  it  to  regOh 

LDA  c_ad2 

LSR  A 

LSR  A 

ROL  .reglh  ;read  dl  of  4017h  and  store  it  to  reglh 

DEX 

BNE  _c10 


STZ  c_ad1  ; output  0 to  outO 

LDX  #08H 

c20 

LDA  c_ad1 

LSR  A 

LSR  A 

ROL  .regOI  ;read  dl  of  401 6h  and  store  it  to  regOI 

LDA  c ad2 


4-10-7 


SNES  DEVELOPMENT  MANUAL 


: 


LSR 

A 

LSR 

A 

ROL 

.regll 

;read  dl  of  401 7h  and  store  it  to  regll 

DEX 

BNE 

_c20 

;<determine  if  special  device  or  MPA  is  connected?> 

» 

;<Check  controller  port1> 

LDA 

.regOh 

CMP 

#0FFH 

;ls  reg0h=$FF? 

BNE 

_c30 

; YES->determine  if  MPA  or  special  device 
; NO->branch,  check  connection  on  port2 

LDA 

.regOI 

CMP 

#0FFH 

;ls  regOI=$FF? 

BEQ 

C30 

; YES->special  device  connected  to  portl , jmp 
; NO->MPA  connected  to  portl , set  status 

LDA 

#80H 

STA 

.status 

;<Check  controller  port2> 

_c30 

LDA 

.reglh 

CMP 

#0FFH 

;ls  reg1h=$FF? 

BNE 

_c40 

; YES->determine  if  MPA  or  special  device 
; NO->branch  and  return  from  routine 

LDA 

.regll 

CMP 

#0FFH 

;ls  reg1l=$FF? 

BEQ 

_c40 

; YES->special  device  connected  to  port2,  rts 
; NO->MPA  connected  to  port2,  set  status 

LDA 

#40H 

ORA 

.status 

STA 

.status 

c40 

PLP 

RTS 


MultiPlayer  connection  check  routine  version  x.xx 
(Caution) 

When  this  routine  is  used  as  is,  please  don’t  delete  this  code. 

If  this  routine  is  modified,  please  use  the  following  code  instead 
‘MODIFIED  FROM  SHVC  MULTI5  CONNECT  CHECK  VER  x.xx’ 


DB  ‘NINTENDO  SHVC  MULTI5  CONNECT  CHECK  Verl  .00’ 


4-10-8 


MULTIPLAYER  5 SUPPLIED  BIOS 


★*★★*★★**★★★★★★★★★★★★★**★★★★★*★★★*★★★★★★*★*★**★**★★★★★★*★★★★★*****★★★★***★★*★***★★***★★★★★•* 

MultiPlayer  BIOS  end  code 
Please  do  not  delete  this  code 

★★★**★★★**★**********★★★★★*★**★*★★*★**★★*★*★**★★***★★***★*★★***★**★*★★★★★★★★*★****★*★**★**★ 


DB  ‘END  OF  MULTI5  CONNECT  CHECK’ 


END 


4-10-9 


SNES  DEVELOPMENT  MANUAL 


m 


[MULTI5.X65] 

ON816 

PUBALL 

ASSUME 

MEM16 

macro 

ON16A 

endm 

MEM8 

macro 

OFF16A 

endm 

IDX16 

macro 

ON16I 

endm 

IDX8 

macro 

OFF16I 

endm 

MultiPlayer  driver  routine  ver  x.xx 
Date 

© 199x  Nintendo 


; (Caution) 

; 1.  Enable  controller  automatic  read  when  read_mpa  routine  is  used. 
; 2.  This  BIOS  is  for  the  standard  controller  only. 

; 3.  This  BIOS  is  called  once  every  frame. 

BANK80  GROUP  080H 


MultiPlayer  BIOS  start  code 
Please  do  not  delete  this  code 


DB  ‘START  OF  MULTI5  BIOS’ 


RAM  define  table 


BANKEQU 

1 GROUP 

0 

ORG 

001  OH 

status 

DS 

1 

; status  of  device  connection 

con5 

DS 

2 

;status  of  controller  #5  (MPA  #4) 

4-10-10 


MULTIPLAYER  5 SUPPLIED  BIOS 


con4 

DS 

2 

;status  of  controller  #4  (MPA  #3) 

con3 

DS 

2 

;status  of  controller  #3  (MPA  #2) 

con2 

DS 

2 

;status  of  controller  #2  (MPA  #1 ) 

coni 

DS 

2 

;status  of  controller  #1  (front  connector  #1 ) 

sgn5 

DS 

1 

[signature  of  controller  #5  (MPA  #4) 

sgn4 

DS 

1 

[signature  of  controller  #4  (MPA  #3) 

sgn3 

DS 

1 

[signature  of  controller  #3  (MPA  #2) 

sgn2 

DS 

1 

[signature  of  controller  #2  (MPA  #1) 

sgnl 

DS 

1 

[signature  of  controller  #1  (front  connector  #1) 

regOI 

DS 

1 

; Work  register 

regOh 

DS 

1 

; Work  register 

regll 

DS 

1 

; Work  register 

reglh 

DS 

1 

; Work  register 

c_ad1 

EQU 

401 6H 

c_ad2 

EQU 

401 7H 

BANK80 

GROUP 

080H 

.★******★******★***★★★★*★* a**************** ************************ **★★★***★★★★***★** 

; (Caution) 

; Contents  of  register  A,  B,  X,  Y will  be  destroyed  after  this  routine. 
read_mpa 

PHP 

IDX8 

MEM8 

SEP  #30  H 

STZ  <status 


;<automatic  read  of  controller  data  enable?> 

_10 

LDA  421 2H 

AND  #01 H 

BNE  _10 

;<store  data  of  controller  #1  > 

LDA  421 9H 

STA  conl+1 

LDA  421 8H 

STA  coni  ;store  data  of  controller  #1  to  coni  (1  byte) 

AND  #0FH 

STA  sgnl 

LDA  c_ad1 


4-10-11 


SNES  DEVELOPMENT  MANUAL 


LSR 

A 

ROL 

sgnl 

;store  signature  of  controller  #1  to  sgnl 

;<store  data  of  controller  #2  and  #3> 

LDA 

421 BH 

STA 

con2+1 

LDA 

421  AH 

STA 

con2 

;store  data  of  controller  #2  to  con2 

AND 

#0FH 

STA 

sgn2 

LDA 

421 FH 

STA 

con3+1 

LDA 

421  EH 

STA 

con3 

;store  data  of  controller  #3  to  con3 

AND 

#0FH 

STA 

sgn3 

LDA 

c ad2 

LSR 

A 

ROL 

sgn2 

;store  signature  of  controller  #2  to  sgn2 

LSR 

A 

ROL 

sgn3 

;store  signature  of  controller  #3  to  sgn3 

;<output  “0”  to  PP7> 
LDA 

#7FH 

STA 

4201 H 

;<read  and  store  data  of  controller  #4  and  #5> 

LDY 

#10H 

_20 

LDA 

c_ad2 

MEM16 

REP 

#20H 

LSR 

A 

ROL 

con4 

;store  data  of  controller  #4  to  con4 

LSR 

A 

ROL 

con5 

;store  data  of  controller  #5  to  con5 

MEM8 

SEP 

#20  H 

DEY 

BNE 

_20 

LDA 

con4 

AND 

#0FH 

STA 

sgn4 

LDA 

con5 

AND 

#0FH 

STA 

sgn5 

4-10-12 


MUL  TIPLA  YER  5 SUPPLIED  BIOS 


LDA  c_ad2 

LSR  A 

ROL  sgn4  ;store  signature  of  controller  #4  to  sgn4 

LSR  A 

ROL  sgn5  ;store  signature  of  controller  #5  to  sgn5 

;<  output  “1”  to  PP7> 

LDA  #0FFH 

STA  4201 H 

PLP 

RTS 


MultiPlayer  driver  routine  ver  x.xx 
(Caution) 

When  this  routine  is  used  as  is,  please  don’t  delete  this  code. 

If  this  routine  is  modified,  please  use  the  following  code  instead. 
‘MODIFIED  FROM  SHVC  MULTI5  BIOS  Ver  x.xx’ 

******************************************************************************************* 
DB  ‘NINTENDO  SHVC  MULTI5  BIOS  Ver  x.xx’ 

******************************************************************************************* 

MultiPlayer  BIOS  end  code 
Please  do  not  delete  this  code 

******************************************************************************************* 

DB  ‘END  OF  MULTI5  BIOS’ 

END 


4-10-13 


SNES  DEVELOPMENT  MANUAL 


10.7  MULTIPLAYER  DEVELOPMENT  ASSEMBLY 

Nintendo  has  created  a breadboard  for  evaluation  of  MultiPlayer  5 programs.  This 
breadboard  is  manufactured  according  to  the  standard  MultiPlayer  5 circuit  speci- 
fications and  is  the  standard  evaluation  tool  for  MultiPlayer  5 programs.  All  master 
programs  should  be  tested  using  this  device  prior  to  submission  for  approval. 

Nintendo  also  uses  this  breadboard  to  test  for  proper  operation  as  part  of  lot 
checks. 

If  the  breadboard  is  desired  for  program  development,  contact  the  NOA  Parts  De- 
partment at  (800)  531-4048.  Ask  for  the  MultiPlayer  Development  Assembly. 


4-10-14 


Chapter  1 . Super  NES  Parts  List 


Part# 

Description 

Remarks 

22945 

21712 
25306 

21713 

23089 

21715 

21716 

23090 
22424 
21943 
25100 
21326 
22423 

22939 

22940 

21940 

21941 
7879 

22536 

22537 

22538 

22539 

22540 
24468 
26424 
27441 
28761 
22427 
21945 
24470 
25474 
26011 
28626 
28760 
28625 
33366 
32321 
22410 
27124 

22742 

22743 

22744 

22745 

22746 

22748 

22749 

Control  Deck  (SNS) 

Control  Deck  (SFX) 

GPK  Super  Mario  World  (SNS) 

GPK  Super  Mario  World  (SFX) 

Cable  AV  (Stereo)  - (ACC) 

AC  Adapter  (SFX) 

Cable  RGB 
Cable  S-VHS  (ACC) 

Cable  AV  Mono 
1C  D411  CIC 
1C  D413CIC  (PAL) 

RAM  S-WRAM  1M  SNS/SHVC  Custom 
Fuse  1 .5A 

Housing  GPK  Front  (SNS) 

Housing  GPK  Back  (SNS) 

Housing  GPK  Front  (SFX) 

Housing  GPK  Back  (SFX) 

Screw  GPK  M2x5.9 
PCB  SHVC-1A0N  (bare) 

PCB  SHVC-1A1B  (bare) 

PCB  SHVC-1A3B  (bare) 

PCB  SHVC-1A5B  (bare) 

PCB  SHVC-1B0N  (bare) 

PCB  SHVC-1B5B  (bare) 

PCB  SHVC-1K1B  (bare)  (Super  Mario  Kart) 

PCB  SHVC-  4PV5B  Evaluation  Kit 

PCB  SHVC-  2P3B  Evaluation  Kit 

PCB  Assy  SHVC-  2P3B 

PCB  Assy  SHVC-  1P0N 

PCB  Assy  SHVC-  2Q5B 

PCB  Assy  SHVC-4PV5B 

PCB  Assy  SHVC-2QW5B 

PCB  Assy  SHVC-8PV5B 

PCB  Assy  SHVC-4QW5B 

PCB  Assy  SHVC-1 RA3B6S 

PCB  Assy  SHVC-4PV7B 

PCB  Assy  SHVC-8X7B 

Multi  Checker  SFX 

Multi  Checker  (20/21  Modes) 

EPROM  64K  MBM27C64  Fujitsu  (blank) 
EPROM  128K  MBM27C128  Fujitsu  (blank) 
EPROM  266K  MBM27C256  Fujitsu  (blank) 
EPROM  51 2K  MBM27C512  Fujitsu  (blank) 
EPROM  1M  NH27C101  Hitachi  (blank) 
EPROM  2M  FUJITSU  MBM  27C2001  (blank) 
EPROM  4M  TC574000D  Toshiba  (blank) 

25  PCBs 
25  PCBs 

FOR  PARTS  ORDERS  CALL:  1 -800-531  -4048 


1 


Part# Description 

21283  Connector  Expansion  28  Pin  Male  (SFX) 

22771  Connector  Expansion  28  Pin  Female 

26882  Super  NES  Emulator-SE 

21321  1C  RF5A22  CPU  SHVC 

21322  1C  RF5C77  PPU1  SHVC 

21323  1C  RF5C78  PPU2  SHVC 

22943  DSP1 

23367  RAM  16K  - S,  Low  Power  Small 

23884  RAM  64K  - S,  Low  Power  Large 

23368  RAM  256K  - S,  Low  Power  Large 

27448  Multiplayer  Development  Assy 

25715  RAM,  TC551001  PL-85  (Emulator  Upgrade) 

24966  Super  NES  Development  Manual,  Book  1 

27457  Super  NES  Development  Manual,  Book  2 


Remarks 


2 


INDEX  (Book  I) 


A 

Absolute  Addressing  1-17-4 
Absolute  Multiplication  1-15-1 
Addition/Subtraction  Screen  1-7-1 
ADSR  Mode  2-7-3 
Audio  Processing  Unit  1-22-1 

B 

BG  Mode  1-3-1,  1-27-3 
Bit  Rate  Reduction  2-2-1 
Brightness  1-27-1 
BRR  2-2-1,  2-7-9 
BRR  Filter  2-2-1,  2-2-2 
BRR  Filter  Number  2-2-1 
BRR  Format  2-2- 1 
BRR  Range  2-2-1,  2-2-2 

C 

CG-RAM  1-8-1,  1-27-11 
Channels  1-17-1 
Clock  Speed  1-21-1 
Color  Constant  1-7-2 

Color  Constant  Addition/Subtraction  1-7-5, 
1-9-1 

Color  Generator  RAM  1-22-2 
Colors  1-2-1 

Controller  1-13-1,  1-14-1 
CPU  Clock  1-21-1 

D 

Data  Bank  Register  3-3-2,  3-4-5,  3-4-8 

Data  Transfer  1-17-1 

Direct  Page  Flag  2-8-7 

Direct  Register  3-4-8 

Direct  Select  1-27-16 

Division  1-15-1 

DMA  1-13-1,  1-17-1 

DMA,  General  Purpose  1-13-1,  1-17-1 


E 

Echo  Delay  2-7-9 
Echo  Enable  2-7-8 
Echo  Feed-Back  2-7-9 
Echo  Filter  Coefficients  2-7-1 
Echo  Start  Address  2-7-9 
Emulation  Mode  3-1-1,  3-2-1 
Expanded  Connector  1-13-1 
ExtBG  Mode  1-5-1,  1-27-19 
External  Latch  Flag  1-27-22, 4-1-3 
External  Synchronization  1-27-19 

F 

Fixed  Color  Addition  1-6-1 
G 

Gain  Mode  2-7-3 

H 

H-Blank  1-17-4 

H-DMA  1-6-1,  1-12-1,  1-17-1 

Horizontal  Blanking  1-1-2 

I 

Indirect  Addressing  1-17-4 
Interface  1-14-1 
Interlace  1-1-1,  1-1-2,  1-18-1 
Interrupt  1-16-1 
IPL  ROM  2-1-1 

J 

Joy  Controller  Enable  1-28-1 
M 

Main  Screen  1-7-1,  1-7-5 
Mode  20  1-21-3 
Mode  21  1-21-4 
Mosaic  1-4-1,  1-27-3 
Multiplication  1-27-20 


(1  of  7) 


INDEX 


N 

Native  Mode  3-2-1 
NMI  1-13-1 

O 

OAM  Priority  Rotation  1-27-2 
Object  Attribute  Memory  1-22-2,  1-27-2 
Object  Size  1-27-1 

P 

Pallets  1-2-1 
Priority  1-2-1 
Priority  Order  1-20-2 
Processor  Status  Register  3-9-2 
Programmable  I/O  Port  1-14-1,  1-28-1 
Program  Bank  Register  3-3-3,  3-4-7 
Program  Counter  3-3-3 
Program  Status  Word  2-8-6 

R 

Resolution  1-3-1,  1-18-1 
S 

Screen  Addition/Subtraction  1-6-1,  1-7-5, 
1-9-1 

Screen  Repetition  1-27-4 
Scroll  1-12-1 

Scroll,  Vertical  Partial  1-12-1 
Sony  SPC700  2-8-1 
Stack  Pointer  3-3-3 
Sub  Screen  1-7-1,  1-7-5 
Synchronization  1-16-1 

T 

Timer  1-16-1 
Timer  Enable  1-28-1 
Transparency  1-7-2 
Two’s  Complement  1-10-1 

V 

Vertical  Blanking  1-1-2 
W 

Window  1-6-1,  1-12-1,  1-27-12 
Window  Logic  1-27-13 


(2  of  7) 


INDEX 


INDEX  (Book  II) 

IWT  Rn,  #xx  2-2-6,  2-9-62 
JMP  Rn  2-2-7,  2-9-63 
LDB  (Rn)  2-2-6,  2-9-64 
LDW  (Rn)  2-2-6,  2-9-66 


COMMANDS/INSTRUCTIONS 

ADC  Rn  2-2-6,  2-9-3 
ADC  #n  2-2-6,  2-9-4 
ADD  Rn  2-2-6,  2-9-5 
ADD  #n  2-2-6,  2-9-6 
ALT  I 2-2-8,  2-9-7 
ALT2  2-2-8,  2-9-8 
ALT3  2-2-8,  2-9-9 
AND  Rn  2-2-7,  2-9-10 
AND  #n  2-2-7,  2-9-11 
ASR  2-2-7,  2-9-12 
ATTITUDE  3-5-22 
BCC  e 2-2-7,  2-9-14 
BCSe  2-2-7,  2-9-16 
BEQe  2-2-7,  2-9-18 
BGE  e 2-2-7,  2-9-20 
BIC  Rn  2-2-7,  2-9-22 
BIC  #n  2-2-7,  2-9-23 
BLT  e 2-2-7,  2-9-24 
BMI  e 2-2-7,  2-9-26 
BNE  e 2-2-7,  2-9-28 
BPL  e 2-2-7,  2-9-30 
BRA  e 2-2-7,  2-9-32 
BVC  e 2-2-7,  2-9-34 
BVS  e 2-2-7,  2-9-36 
CACHE  2-2-8,  2-9-38 
CMODE  2-2-7,  2-9-39 
CMP  Rn  2-2-6,  2-9-41 
COLOR  2-2-7,  2-9-42 
DEC  Rn  2-2-6,  2-9-43 
DISTANCE  3-5-7 
DIV2  2-2-6,  2-9-44 
FMULT  2-2-6,  2-9-46 
FROM  Rn  2-2-8,  2-9-48 
GETB  2-2-6,  2-9-49 
GETBH  2-2-6,  2-9-51 
GETBL  2-2-6,  2-9-53 
GETBS  2-2-6,  2-9-55 
GETC  2-2-6,  2-9-57 
GYRATE  3-5-31 
HIB  2-2-7,  2-9-58 
IBT  Rn,  #pp  2-2-6,  2-9-60 
INC  Rn  2-2-6,  2-9-61 
INVERSE  3-5-2 


LEA  Rn,  xx  2-2-8,  2-9-67 
LINK  #n  2-2-7,  2-9-68 
LJMP  Rn  2-2-7,  2-9-69 
LM  Rn,  (xx)  2-2-6,  2-9-70 
LMS  Rn,  (yy)  2-2-6,  2-9-71 
LMULT  2-2-6,  2-9-73 
LOB  2-2-7,  2-9-75 
LOOP  2-2-7,  2-9-77 
LSR  2-2-7,  2-9-78 
MERGE  2-2-7,  2-9-79 
MOVE  Rn,  Rn’  2-2-8,  2-9-81 
MOVE  Rn,  #xx  2-2-8,  2-9-82 
MOVE  Rn,  (xx)  2-2-8,  2-9-83 
MOVE  (xx),  Rn  2-2-8,  2-9-85 
MOVEB  Rn,  (Rn’)  2-2-8,  2-9-87 
MOVEB  (Rn’),  Rn  2-2-8,  2-9-88 
MOVES  Rn,  Rn’  2-2-8,  2-9-89 
MOVEW  Rn,(Rn’)  2-2-8,  2-9-90 
MOVEW  (Rn’),  Rn  2-2-8,  2-9-91 
MULT  Rn  2-2-6,  2-9-93 
MULT  #n  2-2-6,  2-9-94 
MULTIPLY  3-5-1 
NOP  2-2-8,  2-9-95 
NOT  2-2-7,  2-9-96 
OBJECTIVE  3-5-25 
OR  Rn  2-2-7,  2-9-97 
OR  #n  2-2-7,  2-9-99 
PARAMETER  3-5-12 
PLOT  2-2-7,  2-9-100 
POLAR  3-5-9 
PROJECT  3-5-18 
RADIUS  3-5-4 
RAMB  2-2-7,  2-9-101 
RANGE  3-5-6 
RASTER  3-5-15 
ROL  2-2-7,  2-9-102 
ROMB  2-2-7,2-9-104 


(3  of  7) 


INDEX 


Index  (Continued) 


COMMANDS/INSTRUCTIONS  (Continued)  SUBJECT  - Alphebetical  Listing 


ROR  2-2-7,  2-9-105 
ROTATE  3-5-8 
RPIX  2-2-7,  2-9-107 
SBC  Rn  2-2-6,  2-9-108 
SBK  2-2-6,  2-9-109 
SCALAR  3-5-29 
SEX  2-2-7,  2-9-110 
SM  (xx),  Rn  2-2-6,  2-9-112 
SMS  (yy),  Rn  2-2-6,  2-9-113 
STB(Rn)  2-2-6,  2-9-115 
STOP  2-2-8,  2-9-116 
STW  (Rn)  2-2-6,  2-9-117 
SUB  Rn  2-2-6,  2-9-118 
SUB  #n  2-2-6,  2-9-119 
SUBJECTIVE  3-5-27 
SWAP  2-2-7,  2-9-120 
TARGET  3-5-20 
TO  Rn  2-2-8,  2-9-121 
Triangle  3-5-3 
UMULT  Rn  2-2-6,  2-9-122 
UMULT  #n  2-2-6,  2-9-123 
WITH  Rn  2-2-8,  2-9-124 
XOR  Rn  2-2-7,  2-9-125 
XOR#n  2-2-7,  2-9-126 


A 

Accelerator  Mode  1-5-6 

Access  Modes  2-4-8,  2-5-2,  2-5-4,  2-6-1 

ADC  #n  2-2-6,  2-9-4 

ADC  Rn  2-2-6,  2-9-3 

ADD  #n  2-2-6,  2-9-6 

ADD  Rn  2-2-6,  2-9-5 

ALT1  2-2-8,  2-9-7 

ALT2  2-2-8,  2-9-8 

ALT3  2-2-8,  2-9-9 

AND  #n  2-2-7,  2-9-1 1 

AND  Rn  2-2-7,  2-9-10 

ASR  2-2-7,  2-9-12 

Attitude  2-5-10,  2-5-22,  2-5-24,  2-5-25, 
2-5-27,  2-5-28,  2-5-29,  2-5-31, 
2-5-32,  2-5-33 
Auto-increment  Mode  1-8-3 

B 

Barrel  Shift  1-8-4,  1-8-5 
BCCe  2-2-7,  2-9-14 
BCSe  2-2-7,  2-9-16 
BEQe  2-2-7,  2-9-18 
BGE  e 2-2-7,  2-9-20 
BIC  #n  2-2-7,  2-9-23 
BIC  Rn  2-2-7,  2-9-22 
Bitmap  1-8-14 
Bitmap  Access  1-6-3 
Bitmap  Emulation  1-8-1 
Bitmap  Format  1-6-1 
BLT  e 2-2-7,  2-9-24 
BMI  e 2-2-7,  2-9-26 
BNE  e 2-2-7,  2-9-28 
BPL  e 2-2-7,  2-9-30 
BRA  e 2-2-7,  2-9-32 
Bulk  Processing  2-7-4 
BVC  e 2-2-7,  2-9-34 
BVS  e 2-2-7,  2-9-36 

BW-RAM  1-1-1,  1-1-2,  1-1-3,  1-1-4,  1-2-2, 
1-2-4,  1-6-6 


(4  of  7) 


INDEX 


Index  (Continued) 

H 


C 

Cache  2-6-1,  2-8-4,  2-8-5,  2-8-6,  2-8-7,  2-9-38 
Cache  RAM  2-6-1,  2-6-2,  2-8-8 
Character  Conversion  1 1-6-1,  1-6-7,  1-6-8 
Character  Conversion  2 1-6-2,  1-6-10,  1-6-11 
CMODE  2-8-1,  2-8-9,  2-8-11,  2-8-12,  2-9-39 
CMP  Rn  2-9-41 

Color  2-8-1,  2-8-4,  2-8-6,  2-8-10,  2-8-11, 
2-8-12,  2-8-13,  2-9-41,  2-9-42 
COLR  2-2-3,  2-2-5,  2-4-9,  2-8-4,  2-8-10, 
2-8-11,2-8-12,  2-8-13 
Cumulative  Arithmetic  1-1-2 
Cumulative  Sum  1-7-1,  1-7-3 

D 

DEC  Rn  2-2-6,  2-9-43 

Distance  3-5-4,  3-5-7 

Dither  2-4-9,  2-8-9,  2-8-10,  2-8-11 

DIV2  2-2-6,  2-9-44 

Division  1-7-1,  1-7-2 

DMA  1-9-1 

E 

External  Latch  4-1-4 
External  Latch  Flag  4-1-3 

F 

Fixed  Mode  1-8-2 

FMULT  2-2-6,  2-4-1,  2-8-16,  2-8-17,  2-9-46 
FROM  2-6-4,  2-6-6,  2-6-7,  2-6-11,  2-7-1, 
2-7-2,  2-7-3,  2-7-4,  2-8-10,  2-8-11 
FROM  Rn  2-2-8,  2-9-48 

G 

GETB  2-2-6,  2-9-49 
GETBH  2-2-6,  2-9-51 
GETBL  2-2-6,  2-9-53 
GETBS  2-2-6,  2-9-55 
GETC  2-2-6,  2-8-1,  2-8-4,  2-8-9,  2-8-12, 
2-8-13,  2-9-57 
Gyrate  3-5-31 


H Counter  4-1-4 
HIB  2-2-7,  2-9-58 
Horizontal  Counter  Latch  4-1-3 
HV  Timer  1-1-2,  1-10-1 

I 

IBT  Rn,  #pp  2-2-6,  2-9-60 
INC  Rn  2-2-6,  2-9-61 
Inverse  3-5-2 

I-RAM  1-1-1,  1-1-3,  1-1-4,  1-2-2,  1-2-5,  1-3-5 
IWT  Rn,  #xx  2-2-6,  2-9-62 

J 

JMP  Rn  2-2-7,  2-4-3,  2-9-63 

L 

LDB  (Rn)  2-2-7,  2-9-64 

LDW  (Rn)  2-2-7,  2-9-66 

LEA  Rn,  xx  2-2-8,  2-9-67 

Linear  Timer  1-10-1 

LINK  #n  2-2-7,  2-9-68 

LJMP  Rn  2-2-7,  2-9-69 

LM  Rn,  (xx)  2-2-7,  2-9-70 

LMSRn,  (yy)  2-2-7,  2-9-71 

LMULT  2-2-6,  2-4-1,  2-8-16,  2-8-17,  2-9-73 

LOB  2-2-7,  2-9-75 

LOOP  2-2-7,  2-9-77 

LSR  2-2-7,  2-9-78 


(5  of  7) 


INDEX 


] 


Index  (Continued) 


M 

Masked  Interrupt  1-5-3 
MERGE  2-2-7,  2-9-79 
Message  1-5-3 

Mixed  Processing  Mode  1-5-8 
MOVE  (xx),  Rn  2-2-8,  2-9-85 
MOVE  Rn,  #xx  2-2-8,  2-9-82 
MOVE  Rn,  (xx)  2-2-8,  2-9-83 
MOVE  Rn,  Rn’  2-2-6,  2-9-81 
MOVEB  (Rn’),  Rn  2-2-8,  2-9-88 
MOVEB  Rn,  (Rn’)  2-2-8,  2-9-87 
MOVES  Rn,  Rn’  2-2-6,  2-9-89 
MOVEW  (Rn’),  Rn  2-2-8,  2-9-91 
MOVEW  Rn,(Rn’)  2-2-8,  2-9-90 
MULT  #n  2-2-6,  2-8-16,  2-9-94 
MULT  Rn  2-2-6,  2-8-16,  2-9-93 
Multiplication  1-7-1,  1-7-2 
Multiply  3-5-1 

N 

NOP  2-2-8,  2-6-2,  2-6-3,  2-6-4,  2-6-5,  2-6-7, 
2-6-9,  2-8-10,  2-9-95 
Normal  Color  2-8-1 1 
Normal  DMA  1-9-2 
NOT  2-2-8,  2-9-96 

O 


P 

Parallel  Processing  Mode  1-5-7 
Parameter  3-3-1,  3-5-1 
Pipeline  Processing  2-6-1,  2-6-3,  2-6-5 
Pixel  Cache  2-8-4,  2-8-5,  2-8-6,  2-8-7,  2-8-9 
Plot  2-2-7,  2-4-1, 2-4-8,  2-4-9,  2-8-1, 2-8-4, 2- 
8-5, 2-8-6, 2-8-7, 2-8-8, 2-8-9, 2-8-10, 2- 
8-11,2-8-13,  2-9-100 
Polar  3-5-9 

Project  3-5-10,  3-5-12,  3-5-13,  3-5-14, 

3-5-15,  3-5-17,  3-5-18,  3-5-19, 

3-5-20,  3-5-28 

R 

Radius  3-5-3,  3-5-4,  3-5-6,  3-5-7,  3-5-30 
RAMB  2-2-7,  2-4-6,  2-7-3,  2-9-101 
RAN  2-4-8,  2-5-2,  2-5-4,  2-6-1 
Range  3-5-6,  3-5-30 

Raster  3-2-1,  3-5-12,  3-5-13,  3-5-15,  3-5-16 

Register  Prefix  2-6-6 

ROL  2-2-7,  2-9-102 

ROMB  2-2-7,  2-4-5,  2-7-1,  2-9-104 

RON  2-4-8,  2-5-2,  2-5-4,  2-6-1 

ROR  2-2-7,  2-9-105 

Rotate  3-5-8,  3-5-23 

RPIX  2-2-7,  2-8-6,  2-8-9,  2-8-12,  2-9-107 


Objective  3-5-22,  3-5-25,  3-5-26 
OBJ  Rotation  2-8-1 1 
OBJ  Scaling  2-8-11 
OR  #n  2-2-7,  2-9-99 
OR  Rn  2-2-7,  2-9-97 


(6  of  7) 


Index  (Continued) 


S X 

SBC  Rn  2-2-6,  2-9-108  XOR  #n  2-2-7,  2-9-126 

SBK  2-2-6,  2-9- 1 09  XOR  Rn  2-2-7,  2-9- 1 25 

SBK  Instruction  2-7-2,  2-7-4,  2-7-5 

Scalar  3-5-29 

SCR  2-8-14 

SEX  2-2-7,  2-9-1 10 

Shared  Memory  1-5-4 

SM  (xx),  Rn  2-2-6,  2-9-112 

SMS  (yy),  Rn  2-2-6,  2-9-113 

Sprite  Rotation  2-8- 1 1 

Sprite  Scaling  2-8-1 1 

STB(Rn)  2-2-6,  2-9-115 

STOP  2-2-8,  2-9-116 

STW  (Rn)  2-2-6,  2-9-117 

SUB  #n  2-2-6,  2-9-119 

SUB  Rn  2-2-6,  2-9-118 

Subjective  3-5-22,  3-5-27 

Super  MMC  1-1-1,  1-3-3,  1-3-4 

SWAP  2-2-7,  2-9-120 

T 

Target  3-5-17,  3-5-20,  3-5-21 
TO  2-6-2,  2-6-4,  2-6-6,  2-6-7 
TO  Rn  2-2-8,  2-9-121 
Transparent  2-8-9,  2-8-10,  2-8-1 1,  2-8-13 
Triangle  3-5-3 

U 

UMULT  #n  2-2-6,  2-8-16,  2-9-123 
UMULT  Rn  2-2-6,  2-8-16,  2-9-122 

V 

V Counter  4- 1-4 

Variable-length  Data  1-8-1,  1-8-4 
Vector  Switching  1-5-4 
Vertical  Counter  Latch  4-1-3 
Virtual  VRAM  1-1-2 


WITH  2-6-4,  2-6-6,  2-6-7 
WITH  Rn  2-2-8,  2-9-124 


(7  of  7) 


